---
title: python总结
date: 2024-01-30 15:30:22
tags: python
categories: python总结
index_img: /img/雪.jpg
---
# python考试总结

## 一.程序设计基本方法

### 1.计算机的概念

计算机是根据指令操作数据的设备

具备两个基本特性

   功能性

   对数据的操作，表现为数据计算、输入输出处理和结果存储等。

   可编程性

   根据一系列指令自动地、可预测地、准确地完成操作者的意图  

Python语言诞生于1990年，它是最流行最好用的编程语言

### 2.机器语言

机器语言是一种二进制语言，它直接使用二进制代码表达指令，是计算机硬件可以直接识别和执行的程序设计语言。

### 3.汇编语言

使用助记符与机器语言中的指令进行一一对应，在计算机发展早期帮助程序员提高编程效率

### 4.高级语言

高级语言区别于低级语言在于，高级语言是接近自然语言的一种计算机程序设计语言，更容易地描述计算问题并利用计算机解决计算问题

### 5.编译和解释

编译是将源代码转换成目标代码的过程，通常，源代码是高级语言代码，目标代码是机器语言代码，执行编译的计算机程序称为编译器

解释是将源代码逐条转换成目标代码同时逐条运行目标代码的过程。执行解释的计算机程序称为解释器。



编译是一次性地翻译，一旦程序被编译，不再需要编译程序或者源代码。

对于相同源代码，编译所产生的目标代码执行速度更快。

目标代码不需要编译器就可以运行，在同类型操作系统上使用灵活。



解释则在每次程序运行时都需要解释器和源代码。

解释执行需要保留源代码，程序纠错和维护十分方便。

只要存在解释器，源代码可以在任何操作系统上运行，可移植性好 



高级语言按照计算机执行方式的不同可分成两类

静态语言

脚本语言

这里所说的执行方式指计算机执行一个程序的过程，静态语言采用编译执行，脚本语言采用解释执行



执行方式不同，优势各有不同

**静态语言** 编译器一次性生成目标代码，优化更充分

​         程序执行速度更快

**脚本语言** 执行程序时需要源代码，维护更灵活

​         源代码维护灵活、跨多个操作系统平台



### 6.Python语言的诞生

**Python语言**是由荷兰人Guido van Rossum（吉多·范·罗苏姆）于1989年圣诞节期间在阿姆斯特丹休假时为了打发无聊的假期而编写的一种脚本解释程序，1991年Python第一个发行第一个公开版本。**（灵感源于无聊）



### 7.python语言特点

 Python语言是通用语言

Python语言是脚本语言

Python语言是开源语言

Python语言是跨平台语言

Python语言是多模型语言



## 二.程序设计基本方法

### 1.程序的格式框架

Python语言采用严格的“缩进”来表明程序的格式框架。缩进指每一行代码开始前的空白区域，用来表示代码之间的包含和层次关系。 

1个缩进 = 4个空格

用以在Python中标明代码的层次关系

缩进是Python语言中表明程序框架的唯一手段

### 2.注释

注释：用于提高代码可读性的辅助性文字，不被计算机执行

注释的两种方法：

单行注释以#开头

 \#Here are the comments

多行注释以 ’’’开头和结尾

’’’

 This is a multiline comment

 used in Python

’’’

### 3.命名与保留字

常量：程序中值不发生改变的元素

变量：程序中值发生改变或者可以发生改变的元素



变量命名规则：

①名称第一字符为英文字母或者下划线

②名称第一字符后可以使用英文字母、下划线和数字

③名称不能使用python的关键字或保留字符

④名称区分大小写，单词与单词之间使用下划线连接



**Python 3.x保留字列表 (33个)**

| and      | elif    | import   | raise  |
| -------- | ------- | -------- | ------ |
| as       | else    | in       | return |
| assert   | except  | is       | try    |
| break    | finally | lambda   | while  |
| class    | for     | nonlocal | with   |
| continue | from    | not      | yield  |
| def      | global  | or       | True   |
| del      | if      | pass     | False  |
|          |         |          | None   |

**keyword**包是Python预制的保留关键字及其相关操作的内置库。

import keyword 

keyword.kwlist

keyword.ifkeyword('pass')



### 4.数据类型

**包含数据类型：字符串、整数、浮点数、列表**

**变量：**指向对象的引用。Python属于动态类型定义语言，即变量不需要显式声明数据类型。根据变量的赋值，Python解释器会自动确定其数据类型。如此，变量仅仅是指向某个对象，其类型是由对象本身确定。Python也是一种强类型语言，即某个变量指向的对象均属于某个数据类型。

**字符串**

Python语言中，字符串是用两个双引号“ ”或者单引号‘ ’括起来的一个或多个字符。

Python字符串的两种序号体系

![字符串](https://pic.imgdb.cn/item/65b8eddf871b83018a25211a.png)





### 5.**字符串的使用**

使用[ ]获取字符串中一个或多个字符

-索引：返回字符串中单个字符<字符串>[M]

​       TempStr[-1]

-切片：返回字符串中一段字符子串<字符串>[M:N]

​    TempStr[0:-1]



### 6.**列表类型**

由0个或多个数据组成的有序序列

-列表使用[]表示，采用逗号分隔各元素       

​    [‘F’,’f’]表示两个元素’F’和’f’

-使用保留字in判断一个元素是否在列表中

   TempStr[-1] in ['F','f']



### 7.**赋值语句**

 Python语言中，= 表示“赋值”，即将等号右侧的值计算后将结果值赋给左侧变量，包含等号（=）的语句称为“赋值语句”

**同步赋值语句**：同时给多个变量赋值 

<变量1>, …, <变量N> = <表达式1>, …, <表达式N>

将变量x和y交换

n采用单个赋值，需要3行语句：

即通过一个临时变量t缓存x的原始值，然后将y值赋给x，再将x的原始值通过t赋值给y。

采用同步赋值语句，仅需要一行代码



![赋值语句](https://pic.imgdb.cn/item/65b8eddf871b83018a25217d.png)



### 8.**input()函数**

获得用户输入之前，input()函数可以包含一些提示性文字 

​        <变量> = input(<提示性文字>)



### 9.**分支语句**

分支语句是控制程序运行的一类重要语句，它的作用是根据判断条件选择程序执行路径，使用方式如下：

if <条件1>:

  <语句块1>

elif <条件2>:

  <语句块2>

...

else:

  <语句块N>



### 10.**eval（）函数**

eval(<字符串>)函数是Python语言中一个十分重要的函数，它能够以Python表达式的方式解析并执行字符串，将返回结果输出

**去掉参数最外侧引号并执行余下语句的函数**



**输出函数print（）**

以字符形式向控制台输出结果的函数



**格式化函数format（）**

将字符串格式化<字符串>.format()



### 11.**turtle库和蟒蛇绘制程序**

**Turtle库**

Turtle（海龟）库是Python语言中一个很流行的绘制图像的函数库

Turtle绘图体系：1969年诞生，入门级图形绘制函数库

Python语言的标准库之一

使用turtle库，同学们头脑里需要有这样一个概念：

-想象一个小乌龟，在一个横轴为x、纵轴为y的坐标系原点，(0,0)位置开始

-根据一组函数指令的控制，在这个平面坐标系中移动，从而在它爬行的路径上绘制了图形



**Turtle的绘图窗体**

Turtle.setup(width,height,startx,starty)

-setup()设置窗体大小及位置，不是必须的

Turtle.goto(x,y) 让海龟沿着绝对坐标进行运动

turtle规定以中心为原点（0,0）

turtle.goto(0,300)#代表x为0，中心向上300，y为300
turtle.goto(-100,100)#代表X为-100，代表向左100，y为100，代表向上100
turtle.goto(100,-100)#代表x为向右100，y为向下100

turtle.setheading(angle)/Turtle.seth(angle)

-改变海龟行进方向，angle为绝对角度，只改变方向不行进

turtle.circle(r,angle)  以r为半径的圆移动一定角度

turtle.bk(d) 后退

turtle.fd(d) 前进

turtle.left(angle) 左旋转

turtle.right(angle) 右旋转

turtle.penup()  抬起画笔

turtle.pendown() 落笔

抬起画笔，海龟在飞行，落下画笔，海龟在爬行

turtle.pensize(25) 画笔大小

turtle.pencolor("purple") 画笔颜色

Turtle的RGB色彩模式，默认采用小数值，可切换为整数值。

 turtle.colormode(mode)

-1.0：RGB小数值模式

-255：RGB整数值模式

turtle.done()  “turtle.done()”的作用是暂停程序，停止画笔绘制，但绘图窗体不关闭，直到用户关闭Python Turtle图形化窗⼝为止。



### 12.**库引用与import**

import <库名>

<库名>.<函数名>(参数)

import是一个关键字，用来引入一些外部库，这里的含义是引入一个名字叫turtle的函数库

import turtle

使用from和import保留字共同完成

From<库名>import<函数名>

From<库名> import *

<函数名>(<函数参数>)

使用import和as定义别名

import<库名>as<库别名>

<库别名>.<函数名>(<函数参数>)



### 13.**range（）函数**

range(N):产生0到N-1的整数序列，共N个

range(5)   0,1,2,3,4

Range(M,N):产生M到N-1的整数序列，共N-M个

Range(2,5)   2,3,4



## 三.基本数据类型

### 1.数字类型

Python语言包括三种数字类型

整数类型

浮点数类型

复数类型

#### 1.1整数类型

与数学中的整数概念一致，没有取值范围限制

pow(x, y)函数：计算xy

打开IDLE

程序1：pow(2,10) , pow(2,15)

程序2：pow(2, 1000)

程序3：pow(2, pow(2,15))

示例

1010, 99, -217 

0x9a, -0X89  (0x, 0X开头表示16进制数) 

0b010, -0B101 (0b, 0B开头表示2进制数) 

0o123, -0O456 (0o, 0O开头表示8进制数)

#### 1.2浮点数

带有小数点及小数的数字 

Python语言中**浮点数的数值范围存在限制**，小数精度也存在限制。这种限制与在不同计算机系统有关

取值范围数量级约-10308至10308，精度数量级10-16

 0.0, -77., -2.17 

 96e4, 4.3e-3, 9.6E5 （科学计数法）

科学计数法使用字母“e”或者“E”作为幂的符号，以10为基数。科学计数法含义如下：

​           <a>e<b> = a * 10^b



浮点数间存在不确定尾数，不是bug

\>>>0.1+0.3

0.4

\>>>0.1+0.2

0.30000000000000004



#### 1.3复数类型

与数学中的复数概念一致, z = a + bj， a是实数部分，b是虚数部分，a和b都是浮点类型，虚数部分用j或者J标识

示例：

​     12.3+4j,  -5.6+7j

z = 1.23e-4+5.6e+89j（实部和虚部是什么？）

对于复数z，可以用z.real获得实数部分，z.imag获得虚数部分

z.real = 0.000123  z.imag = 5.6e+89



### 2.数据类型的操作

#### 2.1内置的数值运算操作符

三种类型存在一种逐渐“扩展”的关系：

​     整数 -> 浮点数 -> 复数 

​    （整数是浮点数特例，浮点数是复数特例）

不同数字类型之间可以进行混合运算，运算后生成结果为最宽类型

123 + 4.0 = 127.0 (整数 + 浮点数 = 浮点数)



内置的数值运算操作符

![内置数组操作符](https://pic.imgdb.cn/item/65b8ede0871b83018a252210.png)



数字类型之间相互运算所生成的结果是“更宽”的类型，基本规则是：

整数之间运算，如果数学意义上的结果是小数，结果是浮点数

整数之间运算，如果数学意义上的结果是整数，结果是整数；

整数和浮点数混合运算，输出结果是浮点数；

整数或浮点数与复数运算，输出结果是复数。



#### 2.2 内置的数值运算函数

![内置的数值运算函数](https://pic.imgdb.cn/item/65b8ede8871b83018a2541be.png)

#### 2.3 数字类型的转换

数值运算操作符可以隐式地转换输出结果的数字类型

例如，两个整数采用运算符“/”的除法将可能输出浮点数结果。此外，通过内置的数字类型转换函数可以显式地在数字类型之间进行转换 

![数字类型的转换](https://pic.imgdb.cn/item/65b8ede8871b83018a254230.png)

三种类型可以相互转换

​     函数：int(), float(), complex()

示例：

int(4.5) = 4 （直接去掉小数部分）

float(4) = 4.0 （增加小数部分）

complex(4) = 4 + 0J

#### 2.4 数据类型的判断

函数：type(x)，返回x的类型，适用于所有类型的判断

### 3.math库的使用

math库是Python提供的内置数学类函数库

math库不支持复数类型

math库一共提供了4个数学常数和44个函数。

44个函数共分为4类，包括：16个数值表示函数、8个幂对数函数、16个三角对数函数和4个高等特殊函数



首先使用保留字import引用该库

第一种：import math 

对math库中函数采用math.<b>()形式使用 

第二种，from math import <函数名>

对math库中函数可以直接采用<函数名>()形式使用

#### 3.1math库4个数学常数

![math库4个常数](https://pic.imgdb.cn/item/65b8edf2871b83018a256ccf.png)

#### 3.2math库16个数值表示函数

![16个常值函数](https://pic.imgdb.cn/item/65b8edf3871b83018a256dba.png)

#### 3.3math库中包括8个幂对数函数

![8个幂对数函数](https://pic.imgdb.cn/item/65b8edf3871b83018a256e72.png)

#### 3.4math库包括六个“三角双曲函数

![六个三角双曲函数](https://pic.imgdb.cn/item/65b8edf3871b83018a256f36.png)

#### 3.5math库包括4个高等特殊函数

![四个高等特殊函数](https://pic.imgdb.cn/item/65b8edf3871b83018a256fe9.png)

### 4.字符串类型及其操作

#### 4.1字符串类型

字符串是用一对双引号（”）、单引号（‘）或者三引号（’’’）构成。

字符串可以保存在变量中，也可以单独存在。

可以用type()函数测试一个字符串的类型



Python语言转义符： \

\n表示换行，\\表示反斜杠，\t表示制表符，\’表示单引号，\”表示双引号。

字符串是一个字符序列：字符串最左端位置标记为0，依次增加。字符串中的编号叫做“索引”

单个索引辅助访问字符串中的特定位置    格式为<string>[<索引>]



Python中字符串索引从0开始，一个长度为L的字符串最后一个字符的位置是L-1

Python同时允许使用负数从字符串右边末尾向左边进行反向索引，最右侧索引值是-1



可以通过两个索引值确定一个位置范围，返回这个范围的子串

  **格式：** **<string>[<start>:<end>]**

start和end都是整数型数值，这个子序列从索引start开始直到索引end结束，但不包括end位置



#### 4.2字符串操作符

字符串之间可以通过+或*进行连接

加法操作(+)将两个字符串连接成为一个新的字符串

乘法操作(*)生成一个由其本身字符串重复连接而成的字符串



![字符串操作符](https://pic.imgdb.cn/item/65b8edfb871b83018a258e26.png)

#### 4.3内置的字符串处理函数

![内置的字符串处理函数](https://pic.imgdb.cn/item/65b8edfb871b83018a258f2e.png)

#### 4.4 Python字符串的编码方式

![字符串的编码方式](https://pic.imgdb.cn/item/65b8edfb871b83018a258fd2.png)

#### 4.5 字符串的操作

可以通过 for 和 in 组成的循环来遍历字符串中每个字符

格式如下：

 for <var> in <string>:

​    操作



用转义符可以在字符串中表达一些不可直接打印的信息

例如：用\n表示换行

字符串"Hello\nWorld\n\nGoodbye 32\n"

用print()函数打印后的输出效果如下：

Hello

World



Goodbye 32

#### 4.6 字符串处理方法

![内置的字符串处理函数plus](https://pic.imgdb.cn/item/65b8edfb871b83018a2590ab.png)

#### 4.7字符串类型的格式化

#### 4.7.1 format()方法的基本使用

字符串format()方法的基本使用格式是：

<模板字符串>.format(<逗号分隔的参数>)

![format()方法的基本使用](https://pic.imgdb.cn/item/65b8edfb871b83018a259133.png)

#### 4.7.2 format()方法的格式控制

•format()方法中模板字符串的槽除了包括参数序号 ，还可以包括格式控制信息。此时，槽的内部样式如下：{<参数序号>: <格式控制标记>} 

![format方法的格式化控制](https://pic.imgdb.cn/item/65b8ee08871b83018a25c5b6.png)

![format方法的格式化控制1](https://pic.imgdb.cn/item/65b8ee09871b83018a25c6b7.png)

### 5.文本进度条

利用print()函数实现简单的非刷新文本进度条

基本思想是按照任务执行百分比将整个任务划分为100个单位，每执行N%输出一次进度条。每一行输出包含进度百分比，代表已完成的部分(**)和未完成的部分(..)的两种字符，以及一个跟随完成度前进的小箭头

#### 5.1**静态文本进度条**

![静态文本进度条](https://pic.imgdb.cn/item/65b8ee12871b83018a25eae0.png)

![静态文本进度条结果](https://pic.imgdb.cn/item/65b8ee12871b83018a25eb86.png)

#### 5.2**单行动态刷新**

![单行动态刷新](https://pic.imgdb.cn/item/65b8ee11871b83018a25e952.png)

-函数Print()中更换参数end的默认值为””，即不换行

-增加转义符‘/r’，把输出指针移到行首而不换行

![单行动态刷新1](https://pic.imgdb.cn/item/65b8ee12871b83018a25ea17.png)

#### 5.3**带刷新的文本进度条**

![带刷新的文本进度条](https://pic.imgdb.cn/item/65b8ee09871b83018a25c738.png)

![文本进度条效果](https://pic.imgdb.cn/item/65b8ee09871b83018a25c7ad.png)

#### 5.4五花八门的进度条设计函数

![五花八门的进度条设计函数](https://pic.imgdb.cn/item/65b8ee12871b83018a25ec57.png)

## 四.程序的控制结构

### 4.1程序的流程图

程序流程图用一系列图形、流程线和文字说明描述程序的基本操作和控制流程，它是程序分析和过程描述的最基本方式。

流程图的基本元素包括7种

![程序流程图](https://pic.imgdb.cn/item/65b8ee18871b83018a260589.png)

### 4.2 程序的基本结构

顺序结构是程序的基础，但单一的顺序结构不可能解决所有问题。

程序由三种基本结构组成：

  顺序结构

  分支结构

  循环结构

这些基本结构都有一个入口和一个出口。任何程序都由这三种基本结构组合而成

•**顺序结构**是程序按照线性顺序依次执行的一种运行方式，其中语句块1和语句块2表示一个或一组顺序执行的语句

**分支结构**是程序根据条件判断结果而选择不同向前执行路径的一种运行方式，包括单分支结构和二分支结构。由二分支结构组合形成多分支结构

**循环结构**是程序根据条件判断结果向后反复执行的一种运行方式，根据循环体触发条件不同，包括条件循环和遍历循环结构



IPO描述主要用于区分程序的输入输出关系，重点在于结构划分，算法主要采用自然语言描述

流程图描述侧重于描述算法的具体流程关系，流程图的结构化关系相比自然语言描述更进一步，有助于阐述算法的具体操作过程

Python代码描述是最终的程序产出，最为细致

### 4.3 程序的分支结构

#### 4.3.1 单分支结构: if语句

Python中if语句的语法格式如下：

```python
if <条件>:

  语句块
```

• 语句块是if条件满足后执行的一个或多个语句序列

• 语句块中语句通过与if所在行形成缩进表达包含关系

• if语句首先评估<条件>的结果值，如果结果为True，则执行语句块里的语句序列，然后控制转向程序的下一条语句。如果结果为False，语句块里的语句会被跳过。

if语句中语句块执行与否依赖于条件判断。但无论什么情况，控制都会转到if语句后与该语句同级别的下一条语句 

•if语中<条件>部分可以使用任何能够产生True或False的语句

•形成判断条件最常见的方式是采用关系操作符

•Python语言共有6个关系操作符

![python关系操作符](https://pic.imgdb.cn/item/65b8ee18871b83018a2605f8.png)

#### 4.3.2 二分支结构: if-else语句

Python中if-else语句用来形成二分支结构，语法格式如下：

```python
if  <条件>:
    <语句块1>
else:
    <语句块2>
```

•<语句块1>是在if条件满足后执行的一个或多个语句序列

•<语句块2>是if条件不满足后执行的语句序列

•二分支语句用于区分<条件>的两种可能True或者False，分别形成执行路径

二分支结构还有一种更简洁的表达方式，适合通过判断返回特定值，语法格式如下：

```python
<表达式1>  if  <条件> else <表达式2>   #if…else的紧凑结构非常适合对特殊值处理的情况
```

#### 4.3.2 多分支结构: if-elif-else语句

Python的if-elif-else描述多分支结构，语句格式如下：

```python
if <条件1>:
     <语句块1>
elif <条件2>:
     <语句块2>
... 
else: 
     <语句块N>  
```

•多分支结构是二分支结构的扩展，这种形式通常用于设置同一个判断条件的多条执行路径。

•Python依次评估寻找第一个结果为True的条件，执行该条件下的语句块，同时结束后跳过整个if-elif-else结构，执行后面的语句。如果没有任何条件成立，else下面的语句块被执行。else子句是可选的 

#### 4.3.3多分支结构: match-case语句（补）

Python的match-case描述多分支结构，是python3.10新特性,语句格式如下：

```python
match 变量:
      case 值1:
            <语句块1>
      case 值2 :
            <语句块2>
         ... 
      case _: 
            <语句块N>  
#_ 是一个特殊的“占位符”模式，用于匹配任何值
```

![match-case语句](https://pic.imgdb.cn/item/65b8ee18871b83018a26069f.png)

### 4.4程序的循环结构

#### 4.4.1遍历循环: for语句

**遍历循环**：

  根据循环执行次数的确定性，循环可以分为确定次数循环和非确定次数循环。确定次数循环指循环体对循环次数有明确的定义，循环次数采用遍历结构中元素个数来体现

Python通过保留字for实现“遍历循环” ：

```python
for  <循环变量>  in  <遍历结构>:
    <语句块> 
```

遍历结构可以是字符串、文件、组合数据类型或range()函数：

![遍历循环](https://pic.imgdb.cn/item/65b8ee18871b83018a260706.png)

遍历循环还有一种扩展模式，使用方法如下：

```python
for  <循环变量>  in  <遍历结构>:
    <语句块1>
else:
    <语句块2>
```

•当for循环正常执行之后，程序会继续执行else语句中内容。else语句只在循环正常执行之后才执行并结束。

•因此，可以在<语句块2>中放置判断循环执行情况的语句。

#### 4.4.2 无限循环: while语句

**无限循环**：

•无限循环一直保持循环操作直到特定循环条件不被满足才结束，不需要提前知道确定循环次数。

•Python通过保留字while实现无限循环，使用方法如下：

```python
while <条件>:
    <语句块>
```

•无限循环也有一种使用保留字else的扩展模式：

```python
while  <条件>:
      <语句块1>
else:
      <语句块2>
```

#### 4.4.3 循环保留字: break和continue

•循环结构有两个辅助保留字：break和continue，它们用来辅助控制循环执行

•break用来跳出最内层for或while循环，脱离该循环后，程序从循环后代码继续续执行 

•每个break语句只有能力跳出当前层次循环

•continue用来结束当前当次循环，即跳出循环体中下面尚未执行的语句，但不跳出当前循环。

**continue语句和break语句的区别是：**

•continue语句只结束本次循环，而不终止整个循环的执行。

•break语句则是结束整个循环过程，不再判断执行循环的条件是否成立

**for循环和while循环中都存在一个else扩展用法。**

•else中的语句块只在一种条件下执行，即for循环正常遍历了所有内容没有因为break或return而退出。

•continue保留字对else没有影响

### 4.5 random库的使用

#### 4.5.1 random库概述

•随机数在计算机应用中十分常见，Python内置的random库主要用于产生各种分布的伪随机数序列。random库采用梅森旋转算法（Mersenne twister）生成伪随机数序列，可用于除随机性要求更高的加解密算法外的大多数工程应用。

•使用random库主要目的是生成随机数，因此，读者只需要查阅该库的随机数生成函数，找到符合使用场景的函数使用即可。这个库提供了不同类型的随机数函数，所有函数都是基于最基本的random.random()函数扩展而来。

**random的常用函数**

![random库的常用函数](https://pic.imgdb.cn/item/65b8ee1a871b83018a260ff0.png)

#### 4.5.2 random库解析

![random库解析](https://pic.imgdb.cn/item/65b8ee23871b83018a26312e.png)

对random库的引用方法与math库一样，采用下面两种方式实现：

import random  或   from random import *

#### 4.5.3 **π**的计算

•π（圆周率）是一个无理数，即无限不循环小数。精确求解圆周率π是几何学、物理学和很多工程学科的关键。

•对π的精确求解曾经是数学历史上一直难以解决的问题之一，因为π无法用任何精确公式表示，在电子计算机出现以前，π只能通过一些近似公式的求解得到，直到1948年，人类才以人工计算方式得到π的808位精确小数。

​    随着计算机的出现，数学家找到了另类求解π的另类方法：蒙特卡罗（Monte Carlo）方法，又称随机抽样或统计试验方法。

​    当所要求解的问题是某种事件出现的概率，或者是某个随机变量的期望值时，它们可以通过某种“试验”的方法，得到这种事件出现的频率，或者这个随机变数的平均值，并用它们作为问题的解。这就是蒙特卡罗方法的基本思想

应用蒙特卡罗方法求解π的基本步骤如下：

•随机向单位正方形和圆结构，抛洒大量“飞镖”点

•计算每个点到圆心的距离从而判断该点在圆内或者圆外

•用圆内的点数除以总点数就是π/4值。

随机点数量越大，越充分覆盖整个图形，计算得到的π值越精确。实际上，这个方法的思想是利用离散点值表示图形的面积，通过面积比例来求解π值。 

![π的计算](https://pic.imgdb.cn/item/65b8ee23871b83018a2631e5.png)

### 4.6 异常处理机制

#### 4.6.1**异常处理**: try-except语句

观察下面这段小程序：

```python
num=eval(input("请输入一个整数："))
print(num**2)
```

当用户输入的不是数字呢？

![数字异常](https://pic.imgdb.cn/item/65b8ee23871b83018a263246.png)

Python异常信息中最重要的部分是异常类型，它表明了发生异常的原因，也是程序处理异常的依据。

Python使用try-except语句实现异常处理，基本的语法格式如下：

```python
try:
     <语句块1>
except <异常类型>:
     <语句块2>
```

#### 4.6.2 异常的高级用法

try-except语句可以支持多个except语句，语法格式如下

```python
try:
	<语句块1>
except <异常类型1>:
	<语句块2>
…
except <异常类型N>:
	<语句块N+1>
except:
	<语句块N+2>
```

最后一个except语句没有指定任何类型，表示它对应的语句块可以处理所有其他异常。这个过程与if-elif-else语句类似，是分支结构的一种表达方式，一段代码如下： 

```python
try:
    alp="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    idx=eval(input("请输入一个整数："))
    print(alp[idx])
except NameError:
    print("输入错误，请输入一个整数！")
except:
    print("其他错误")
```

该程序将用户输入的数字作为索引从字符串alp中返回一个字符，当用户输入非整数字符时，except NameError异常被捕获到，提示用户输入类型错误，当用户输入数字不在0到25之间时，异常被except捕获，程序打印其他错误信息

除了try和except保留字外，异常语句还可以与else和finally保留字配合使用，语法格式如下：

```python
try:
	<语句块1>
except <异常类型1>:
	<语句块2>
else:
	<语句块3>
finally:
	<语句块4>
```

![异常的高级用法](https://pic.imgdb.cn/item/65b8ee23871b83018a2632e1.png)

![异常的高级用法1](https://pic.imgdb.cn/item/65b8ee23871b83018a26335a.png)

## 五.函数和代码的复用

### 5.1 函数的定义

•函数是一段具有特定功能的、可重用的语句组，用函数名来表示并通过函数名进行完成功能调用。

•函数是一种功能的抽象，一般函数表达特定功能

•作用：降低编程难度和代码重用

Python定义一个函数使用def保留字，语法形式如下：

```python
def <函数名>(<参数列表>):
    <函数体>
    return <返回值列表>
```

函数定义时，所指定的参数是一种占位符，简称形参。

函数定义后，如果不经调用，不会被执行

函数定义时，参数是输入、函数体是处理、结果是输出

函数中，可以没有return语句

### 5.2 函数调用的过程

函数调用：函数名(参数)

程序调用一个函数需要执行以下四个步骤：

（1）调用程序在调用处暂停执行；

（2）在调用时将实参复制给函数的形参；

（3）执行函数体语句；

（4）函数调用结束给出返回值，程序回到调用前的暂停处继续执行。

### 5.3 lambda函数

Python的有33个保留字，其中一个是lambda，该保留字用于定义一种特殊的函数——匿名函数，又称lambda函数。

匿名函数并非没有名字，而是将函数名作为函数结果返回，如下：

```python
<函数名> = lambda <参数列表>: <表达式>
```

lambda函数与正常函数一样，等价于下面形式：

```python
def <函数名>(<参数列表>):
     return <表达式>
```

简单说，lambda函数用于定义简单的、能够在一行内表示的函数，返回一个函数类型

### 5.4 函数的参数传递

#### 5.4.1可选参数和可变数量参数

在定义函数时，有些参数可以存在默认值，该参数叫可选参数，其位置必须在非可选参数之后。

```python
>>>def dup(str, times = 2):
        print(str*times)
>>>dup("knock~")
knock~knock~
>>>dup("knock~",4)
knock~knock~knock~knock~
```

在函数定义时，可以设计可变数量参数，通过参数前增加星号（*）实现，可变参数只能出现在参数列表的最后。

```python
>>>def vfunc(a, *b):
        print(type(b))
        for n in b:
             a += n
        return a
>>>vfunc(1,2,3,4,5)
<class 'tuple'> #可变参数b是元组类型
15
```

还有一种就是参数带两个星号 ***\***基本语法如下：

```python
def functionname([formal_args,] **var_args_dict ):
   "函数_文档字符串"
   function_suite
   return [expression]
```

加了两个星号 ***\*** 的参数会以字典的形式导入。

```python
#!/usr/bin/python3
  
# 可写函数说明
def printinfo( arg1, **vardict ):
   "打印任何传入的参数"
   print ("输出: ")
   print (arg1)
   print (vardict)
 
# 调用printinfo 函数
printinfo(1, a=2,b=3)
#以上实例输出结果：

输出: 
1
{'a': 2, 'b': 3}
```



声明函数时，参数中星号 ***** 可以单独出现，例如:

```python
def f(a,b,*,c):
    return a+b+c
```

如果单独出现星号 *****，则星号 ***** 后的参数必须用关键字传入：

```python
>>> def f(a,b,*,c):
...     return a+b+c
... 
>>> f(1,2,3)   # 报错
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: f() takes 2 positional arguments but 3 were given
>>> f(1,2,c=3) # 正常
6
>>>
```



#### 5.4.2 参数的位置和名称传递

•1、实参默认采用按照位置顺序传给函数。

•2、按照形参名称输入实参的方式，调用如下：result = func(x2=4, y2=5, z2=6, x1=1, y1=2, z1=3)由于调用函数时指定了参数名称，所以参数之间的顺序可以任意调整。

#### 5.4.3 函数的返回值

•return语句用来退出函数并将程序返回到函数被调用的位置继续执行。

•return语句同时可以将0个、1个或多个函数运算完的结果返回给函数被调用处的变量，例如以下代码：

```python
>>>def func(a, b):
        return a*b
>>>s = func("knock~", 2)
>>>print(s)
knock~knock~
```

函数可以没有return，此时函数并不返回值，如微实例5.1的happy()函数。

函数也可以用return返回多个值，多个值以元组类型保存，例如：

```python
>>>def func(a, b):
        return b,a
>>>s = func("knock~", 2)
>>>print(s, type(s))
(2, 'knock~') <class 'tuple'>
```

#### 5.4.4 函数对变量的作用

一个程序中的变量包括两类：全局变量和局部变量。

•**全局变量**指在函数之外定义的变量，一般没有缩进，在程序执行全过程有效。

•**局部变量**指在函数内部使用的变量，仅在函数内部有效，当函数退出时变量将不存在。

```python
>>>n = 1    #n是全局变量
>>>def func(a, b):
        c = a * b    #c是局部变量，a和b作为函数参数也是局部变量
        return c
>>>s = func("knock~", 2)
>>>print(c)
Traceback (most recent call last):
  File "<pyshell#6>", line 1, in <module>
    print(c)
NameError: name 'c' is not defined
```

这个例子说明，当函数执行完退出后，其内部变量将被释放。如果函数内部使用了全局变量呢？ 

```python
>>>n = 1    #n是全局变量
>>>def func(a, b):
            n = b     #这个n是在函数内存中新生成的局部变量，不是全局变量 
            return a*b
>>>s = func("knock~", 2)
>>>print(s, n)  #测试一下n值是否改变
knock~knock~ 1
```

•函数func()内部使用了变量n，并且将变量参数b赋值给变量n，为何全局变量n值没有改变？

•因为函数内n=b是生成一个局部变量n，虽然同名但是func函数并没有把n当作全局变量。

如果希望让func()函数将n当作全局变量，需要在变量n使用前显式声明该变量为全局变量，代码如下。

```python
>>>n = 1    #n是全局变量
>>>def func(a, b):
           global n
           n = b     #将局部变量b赋值给全局变量n 
           return a*b
>>>s = func("knock~", 2)
>>>print(s, n)  #测试一下n值是否改变
knock~knock~ 2
```

**补充：**在使用global声明全局变量时，不能和形参同名

•错误：**SyntaxError**：name ‘a’ is parameter and global

```python
>>>n = 1    #n是全局变量
>>>def func(a, b):
           global a  #会报错
           n = b     #将局部变量b赋值给全局变量n 
           return a*b
>>>s = func("knock~", 2)
>>>print(s, n)  #测试一下n值是否改变
knock~knock~ 2
```

如果此时的全局变量不是整数n，而是列表类型ls，会怎么样呢？理解如下代码。

```python
>>>ls = []    #ls是全局列表变量
>>>def func(a, b):
        ls.append(b)   #将局部变量b增加到全局列表变量ls中 
        return a*b
>>>s = func("knock~", 2)
>>>print(s, ls)  #测试一下ls值是否改变
knock~knock~ [2]
```

全局列表变量ls发生改变

如果func()函数内部存在一个真实创建过且名称为ls的列表，则func()将操作该列表而不会修改全局变量，例子如下。

```python
>>>ls = []    #ls是全局列表变量
>>>def func(a, b):
        ls = []     #创建了名称为ls的局部列表变量列
        ls.append(b)   #将局部变量b增加到局部列表变量ls中 
        return a*b
>>>s = func("knock~", 3)
>>>print(s, ls)  #测试一下ls值是否改变
knock~knock~ []
```

### 5.5 可更改与不可更改对象

在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。

**不可变类型**：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。

**可变类型**：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。



**不可变类型**：类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。

**可变类型**：类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响

python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。

### 5.6 局部变量作用域

Python函数对局部变量的作用遵守如下原则：

•在函数内部创建简单数据类型变量，无论是否与全局变量重名，函数退出后变量被释放，全局变量值不变；

•在函数内部创建组合数据类型变量，无论是否有同名全局变量，函数退出后变量被释放，全局变量值不变。

**局部变量作用域只在函数内**

**Python函数对变量的作用遵守如下原则：**

•函数内的局部变量作用域要想超出函数，需要给该变量前加global

•在使用global声明全局变量时，不能和形参同名

global：将局部变量声明为全局变量

nonlocal：将局部变量声明为非局部变量，该关键字能将局部变量的作用域增加一个级别，并不是声明为全局变量，且该关键字**只能对局部变量使用**。



### 5.7 全局变量作用域

**Python函数对全局变量的作用遵守如下原则：**

strings, tuples, 和 numbers做全局变量时，传入函数后，函数内的操作并不影响该变量本身的值。

列表，字典做全局变量时，传入函数后：1、函数内创建无同名局部变量，函数内的操作影响全局变量的值；2、函数内创建有同名局部变量，仅对局部变量操作，全局变量值不变。

### 5.8 函数对变量的作用

Python函数对变量的作用遵守如下原则：

•在函数内部创建简单数据类型变量，无论是否与全局变量重名，函数退出后变量被释放，全局变量值不变；

•简单数据类型变量在用global保留字声明后，作为全局变量；

•对于组合数据类型的全局变量，如果在函数内部没有被真实创建的同名变量，则函数内部可直接使用并修改全局变量的值；

在函数内部创建组合数据类型变量，无论是否有同名全局变量，函数退出后变量被释放，全局变量值不变

### 5.9 datetime库的使用

#### 5.9.1 datetime库概述

 以不同格式显示日期和时间是程序中最常用到的功能。**Python**提供了一个处理时间的标准函数库**datetime**，它提供了一系列由简单到复杂的时间处理方法。datetime库可以从系统中获得时间，并以用户选择的格式输出。

**datetime库以类的方式提供多种日期和时间表达方式：**

datetime.date：**日期表示类**，可以表示年、月、日等

datetime.time：**时间表示类**，可以表示小时、分钟、秒、毫秒等

datetime.datetime：**日期和时间表示的类**，功能覆盖date和time类

datetime.timedelta：**时间间隔有关的类**

datetime.tzinfo：**与时区有关的信息表示类**

#### 5.9.2 datetime库解析

使用datetime.now()获得当前日期和时间对象，使用方法如下：

 **datetime.now**()

**作用**：返回一个datetime类型，表示当前的日期和时间，精确到微秒。

```python
>>> from datetime import datetime
>>> today = datetime.now()
>>> today
datetime.datetime(2016, 9, 20, 10, 29, 43, 928549)
```

使用datetime.utcnow()获得当前日期和时间对应的UTC（世界标准时间）时间对象，使用方法如下：

**datetime.utcnow**()

**作用**：返回datetime类型，表示当前日期和时间的UTC表示，精确到微秒。

```python
>>> today = datetime.utcnow()
>>> today
datetime.datetime(2016, 9, 20, 2, 35, 1, 427954)
```

datetime.now()和datetime.utcnow()都返回一个datetime类型的对象，也可以直接使用datetime()构造一个日期和时间对象，使用方法如下：

**datetime(year, month, day, hour=0, minute=0,second=0, microsecond=0**)

**作用**：返回一个datetime类型，表示指定的日期和时间，可以精确到微秒。

调用datetime()函数直接创建一个datetime对象，表示2016年9月16日22:33，32秒7微秒，执行结果如下：

```python
>>> someday = datetime(2016,9,16,22,33,32,7)
>>> someday
datetime.datetime(2016, 9, 16, 22, 33, 32, 7)
```

程序已经有了一个datetime对象，进一步可以利用这个对象的属性显示时间，为了区别datetime库名，采用上例中的someday代替生成的datetime对象

**datatime属性和描述**

![datatime属性和描述](https://pic.imgdb.cn/item/65b8ee2a871b83018a264f4c.png)



datetime对象有3个常用的时间格式化方法，如表所示：

![时间格式化方法](https://pic.imgdb.cn/item/65b8ee2a871b83018a265003.png)

isoformat()和isoweekday()方法的使用如下：

```python
>>> someday = datetime(2016,9,16,22,33,32,7)
>>> someday.isoformat()
'2016-09-16T22:33:32.000007'
>>> someday.isoweekday()
5
```

strftime()方法是时间格式化最有效的方法，几乎可以以任何通用格式输出时间

```python
>>> someday.strftime("%Y-%m-%d %H:%M:%S")
'2016-09-16 22:33:32'
```

**strftime()方法的格式化控制符**

![strftime方法的格式化控制符](https://pic.imgdb.cn/item/65b8ee2a871b83018a2650eb.png)



strftime()格式化字符串的数字左侧会自动补零，上述格式也可以与print()的格式化函数一起使用

```python
>>>from datetime import datetime
>>>now = datetime.now()
>>>now.strftime("%Y-%m-%d")
'2016-09-20'
>>>now.strftime("%A, %d. %B %Y %I:%M%p")
'Tuesday, 20. September 2016 01:53PM'

>>>print("今天是{0:%Y}年{0:%m}月{0:%d}日".format(now))
今天是2016年09月20日
```

5.10 七段数码管绘制

七段数码管（seven-segment indicator）由7段数码管拼接而成，每段有亮或不亮两种情况，改进型的七段数码管还包括一个小数点位置

七段数码管能形成27=128种不同状态，其中部分状态能够显示易于人们理解的数字或字母含义，因此被广泛使用

![七段数码管绘制](https://pic.imgdb.cn/item/65b8ee2a871b83018a26522d.png)

![七段代码管绘制1](https://pic.imgdb.cn/item/65b8ee2b871b83018a265311.png)

### 5.10 代码的复用和模块化设计

  函数是程序的一种基本抽象方式，它将一系列代码组织起来通过命名供其他程序使用。

  函数封装的直接好处是代码复用，任何其他代码只要输入参数即可调用函数，从而避免相同功能代码在被调用处重复编写。代码复用产生了另一个好处，当更新函数功能时，所有被调用处的功能都被更新。

当程序的长度在百行以上，如果不划分模块就算是最好的程序员也很难理解程序含义，程序的可读性就很糟糕了。

​    解决这一问题的最好方法是将一个程序分割成短小的程序段，每一段程序完成一个小的功能。无论面向过程和面向对象编程，对程序合理划分功能模块并基于模块设计程序是一种常用方法，被称为“模块化设计”。

模块化设计一般有两个基本要求：

紧耦合：尽可能合理划分功能块，功能块内部耦合紧密；

松耦合：模块间关系尽可能简单，功能块之间耦合度低。

  使用函数只是模块化设计的必要非充分条件，根据计算需求合理划分函数十分重要。一般来说，完成特定功能或被经常复用的一组语句应该采用函数来封装，并尽可能减少函数间参数和返回值的数量。

### 5.11 函数的递归

#### 5.11.1 递归的定义

  函数作为一种代码封装，可以被其他程序调用，当然，也可以被函数内部代码调用。这种函数定义中调用函数自身的方式称为递归。就像一个人站在装满镜子的房间中，看到的影像就是递归的结果。递归在数学和计算机应用上非常强大，能够非常简洁的解决重要问题。

阶乘的例子揭示了递归的2个关键特征：

（1）存在一个或多个基例，基例不需要再次递归，它是确定的表达式；

（2）所有递归链要以一个或多个基例结尾。



![递归实例1](https://pic.imgdb.cn/item/65b8ee32871b83018a2673ca.png)



![递归实例1原理](https://pic.imgdb.cn/item/65b8ee33871b83018a267448.png)

![递归实例2](https://pic.imgdb.cn/item/65b8ee33871b83018a2674c1.png)

​    观察这个函数的工作过程。s[0]是首字符，s[1:]是剩余字符串，将它们反向连接，可以得到反转字符串。执行这个程序，结果如下：

```python
>>>def reverse(s):
       return reverse(s[1:]) + s[0]
>>> reverse("ABC")
...
RecursionError: maximum recursion depth exceeded
```

![实例2更改png](https://pic.imgdb.cn/item/65b8ee33871b83018a267529.png)

#### 5.11.2 科赫曲线绘制

自然界有很多图形很规则，符合一定的数学规律，例如，蜜蜂蜂窝是天然的等边六角形等。**科赫**(Koch)**曲线**在众多经典数学曲线中非常著名，由瑞典数学家冯·科赫(H·V·Koch)于1904年提出，由于其**形状类似雪花，也被称为雪花曲线**。

科赫曲线的基本概念和绘制方法如下：

  正整数n代表科赫曲线的阶数，表示生成科赫曲线过程的操作次数。科赫曲线初始化阶数为0，表示一个长度为L的直线。对于直线L，将其等分为三段，中间一段用边长为L/3的等边三角形的两个边替代，得到1阶科赫曲线，它包含四条线段。进一步对每条线段重复同样的操作后得到2阶科赫曲线。继续重复同样的操作n次可以得到n阶科赫曲线。

科赫曲线属于分形几何分支，它的绘制过程体现了递归思想，绘制过程代码。

#### 5.12 Python内置函数

Python解释器提供了68个内置函数，其中，前36个已经讲解过，需要掌握。

![python内置函数](https://pic.imgdb.cn/item/65b8ee33871b83018a2675d6.png)



## 六.组合数据类型

  组合数据类型能够将多个同类型或不同类型的数据组织起来，通过单一的表示使数据操作更有序更容易。 

  根据数据之间的关系，组合数据类型可以分为三类：

  序列类型、集合类型和映射类型。

![组合数据类型](https://pic.imgdb.cn/item/65b8ee39871b83018a269064.png)

•序列类型是一个元素向量，元素之间存在先后关系，通过序号访问，元素之间不排他。

•集合类型是一个元素集合，元素之间无序，相同元素在集合中唯一存在。

•映射类型是“键-值”数据项的组合，每个元素是一个键值对，表示为(key, value)。

### 6.1 序列类型

序列类型是一维元素向量，元素之间存在先后关系，通过序号访问。

同样由于元素之间存在顺序关系，所以序列中可以存在相同数值但位置不同的元素。

序列类型支持成员关系操作符（in）、长度计算函数（len()）、分片（[]），元素本身也可以是序列类型。  

Python语言中有很多数据类型都是序列类型，其中比较重要的是：str（字符串）、tuple（元组）和list（列表）。

•**元组**是包含0个或多个数据项的不可变序列类型。元组生成后是固定的，其中任何数据项不能替换或删除。

•**列表**则是一个可以修改数据项的序列类型，使用也最灵活。 

​                                                                            **序列类型的通用操作符**

![序列类型的通用操作符](https://pic.imgdb.cn/item/65b8ee39871b83018a269128.png)

​                                                                            **序列类型的通用函数**

![序列类型的通用函数](https://pic.imgdb.cn/item/65b8ee3a871b83018a2691da.png)

enumerate()函数将一个可遍历的对象（如列表、元组、字符串）组合成索引序列，同时列出数据和数据下标。一般用于for循环中。

 语法格式：enumerate(sequence，[start=0])

•sequence-----一个序列或者其他可迭代对象

•start--------设置下标起始位置，此项可省略

•返回值：enumerate(枚举)对象



#### 6.1.1 字符串

#### 6.1.2 元组

元组（tuple）是序列类型中比较特殊的类型，因为它一旦创建就不能被修改。

元组类型在表达固定数据项、函数多返回值、多变量同步赋值、循环遍历等情况下十分有用。

Python中元组采用逗号和圆括号（可选）来表示。

tuple=（元素1，元素2，...，元素N）

#####                                                               **创建元组**

**创建空元组：**  元组名=() 或 元组名=tuple()

**创建只有一个元素的元组**：  元组名=（元素，）

   **元组只包含一个元素时，需要在元素后面加逗号，否则括号会被当成运算符。**

​    tup=(1)   tup的类型是int

​    tup=(1,)   tup的类型是tuple

**创建多个元素的元组：**   元素名=（元素1,...元素N）元素名=元素1，...，元素N

#####                                                            **元组访问**

**可以使用索引来访问元组中的元素。**

**访问单个元素**，语法：元组名[索引] 

​              返回的数据类型是元素对应的类型

**访问多个元素**，语法：元组名[M：N] 

​              返回的数据类型是元组类型

**访问多级元素**，语法：元组名[第1级索引]   [第2级索引]

#####                                                              **元组操作** 

**元组元素不允许修改、删除**

**元组可以删除，使用del语句删除整个元组**

**元组转换函数 ：tuple(iterable)** 

**将可迭代类型数据转换成元组，iterable可以是字符串、列表、集合、字典。**

```python
 **>>>tuple(‘hello’)   #****类型转换**
('h', 'e', 'l', 'l', 'o')
```

#### 6.1.3 列表

  **列表（list）是包含0个或多个对象引用的有序序列，属于序列类型。**与元组不同，列表的长度和内容都是可变的，可自由对列表中数据项进行增加、删除或替换。列表没有长度限制，元素类型可以不同，使用非常灵活。 列表可以采用标准的比较操作符（<、<=、==、!=、>=、>）进行比较，列表的比较实际上是单个数据项的逐个比较。

#####                                                                **创建列表**

**创建空列表：** 

​        1、列表变量=[]

​        2、列表变量=list()

**创建多个元素的列表：**   

​        1、列表变量=[元素1,...，元素N]

​        2、列表变量=list(seq)    将序列转换为列表

​        3、列表推导式创建

**列表推导式**：是一个表达式，也是一个循环，该循环是可选的、包含在[]中的条件。作用是为列表生成数据项。并且可以使用if语句过滤不需要的数据项。

其语法格式如下：将iterable中的数据项生成列表，等价list(iterable)

```python
[表达式 for 变量 in 列表] 
[out_exp_res for out_exp in input_list]
或者 
[表达式 for 变量 in 列表 if 条件]
[out_exp_res for out_exp in input_list if condition]
out_exp_res：列表生成元素表达式，可以是有返回值的函数。
for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。
if condition：条件语句，可以过滤列表中不符合条件的值。
```



#####                                                              **列表操作示例**

列表用中括号（[]）表示，也可以通过list()函数将元组或字符串转化成列表。直接使用list()函数会返回一个空列表。

![列表操作事例](https://pic.imgdb.cn/item/65b8ee3a871b83018a26929f.png)

#####                                                              **列表类型的概念**

与整数和字符串不同，列表要处理一组数据，因此，列表必须通过显式的数据赋值才能生成，简单将一个列表赋值给另一个列表不会生成新的列表对象。

```python
>>>ls = [425, "BIT", 1024]  #用数据赋值产生列表ls
>>>lt = ls       #lt是ls所对应数据的引用，lt并不包含真实数据
>>>ls[0] = 0     
>>>lt
[0, 'BIT', 1024]
```

#####                                                                  **访问列表**

**可以使用索引来访问列表中的元素。列表可以同时使用正向递增序号和反向递减序号。**

**访问单个元素**，语法：列表变量[索引] 

​              返回的数据类型是元素对应的类型

**访问多个元素**，语法：列表变量[M:N] 

​              返回的数据类型是列表类型

**访问多级元素**，语法：列表变量[第1级索引] [第2级索引]



#####                                                                  **修改列表**

**更新列表元素值：**  

​      列表变量[索引]=值 

**添加新的列表元素：**  

​    1、列表变量.append(x)  将元素x追加到列表最后

​    2、列表变量.insert(i,x)  将元素x插入到列表的第i位



#####                                                                 **删除列表**

**删除列表元素：** 

​      1、del 列表变量[索引] 

​      2、列表变量.remove(元素)

**清空列表：**

​      列表变量.clear() 

**删除列表：**  

​      del 列表变量    

#####                                                            **列表类型的操作符**

列表是序列类型，因此序列的操作符和函数都可应用到列表类型。

由于列表是可变的，表6.4给出了列表类型额外的14个常用函数或方法。

![列表特有的函数或方法](https://pic.imgdb.cn/item/65b8ee3a871b83018a26937a.png)

当使用一个列表改变另一个列表值时，Python不要求两个列表长度一样，但遵循“多增少减”的原则，例子如下。

```python
>>>vlist[1:3]=["new_bit", "new_computer", 123]
>>>vlist
[0, 'new_bit', 'new_computer', 123, 'python', 4]
>>>vlist[1:3]=["fewer"]
>>>vlist
[0, 'fewer', 123, 'python', 4]
```

**一次提取两个或多个数据项时，我们可以使用序列拆分完成，任意可迭代数据类型均可使用。注意：当\*出现在赋值语句左边时，是序列拆分符。**

![序列拆分符](https://pic.imgdb.cn/item/65b8ee3f871b83018a26a94d.png)

  与元组一样，列表可以通过for…in语句对其元素进行遍历，基本语法结构如下：

```python
for <任意变量名> in <列表名>:
    语句块
```

   列表是一个十分灵活的数据结构，它具有处理任意长度、混合类型的能力，并提供了丰富的基础操作符和方法。当程序需要使用组合数据类型管理批量数据时，请尽量使用列表类型。

### 6.2 集合类型

集合类型主要用于三个场景：成员关系测试、元素去重和删除数据项，例子如下。

```python
>>>"BIT" in {"PYTHON", "BIT", 123, "GOOD"} #成员关系测试
True
>>>tup = ("PYTHON", "BIT", 123, "GOOD", 123) #元素去重
>>>set(tup)
{123, 'GOOD', 'BIT', 'PYTHON'}
>>>newtup = tuple(set(tup)–{'PYTHON'}) # 去重同时删除数据项
('GOOD', 123, 'BIT') 
```

集合类型与其他类型最大的不同在于它不包含重复元素，因此，当需要对一维数据进行去重或进行数据重复处理时，一般通过集合来完成。

#### 6.2.1 集合

  集合类型与数学中集合的概念一致，即包含0个或多个数据项的无序组合。

  集合中元素不可重复，元素类型只能是固定数据类型，例如：整数、浮点数、字符串、元组等。

  列表、字典和集合类型本身都是可变数据类型，不能作为集合的元素出现。



#####                              创建集合

集合用{}表示，可以用赋值语句生成一个集合

**创建空集合：** 

​      集合名=set()，不能直接用{}创建

**创建非空集合：**  

​      1、集合名={元素1,...,元素N} 

​      2、集合名=set(x)，x为任意组合数据类型

**集合类型转换：**set()，将任意组合类型转为集合



#####                              操作集合

由于集合无序性，没有索引和位置的概念，不能分片；打印效果与定义顺序可以不一致。

由于集合互异性，使用集合类型能够过滤掉重复元素。

集合中元素可以动态增加或删除。



#####                               修改集合

**添加新的集合元素：**  

1、集合变量.add(x)  将元素x添加到集合中，若x已存在则不进行任何操作

2、集合变量.update(x)  将x添加到集合中，x可以是列表、元组、字典等可迭代对象。



#####                                删除集合

**删除集合元素：** 

​      1、集合变量.discard(x)  x若不存在，不发生错误

​      2、集合变量.remove(x)  x若不存在，会发生错误

​      3、集合变量.pop()     随机删除一个元素

**清空集合：**

​      集合变量.clear()  



#####                            **集合操作**

集合类型具有10个操作符

![集合操作](https://pic.imgdb.cn/item/65b8ee3f871b83018a26aa47.png)

上述操作符表达了集合类型的4种基本操作，交集（&）、并集（|）、差集（-）、补集（^），操作逻辑与数学定义相同



![集合操作1](https://pic.imgdb.cn/item/65b8ee40871b83018a26aac8.png)

集合类型有10个操作函数或方法 



![集合操作2](https://pic.imgdb.cn/item/65b8ee40871b83018a26aba7.png)



### 6.3映射类型

  映射类型是“键-值”数据项的组合，每个元素是一个键值对，即元素是(key, value)，元素之间是无序的。键值对(key, value)是一种二元关系。在Python中，映射类型主要以**字典（dict**）体现。

![映射类型](https://pic.imgdb.cn/item/65b8ee40871b83018a26ac33.png)

#### 6.3.1 字典

#####             字典类型的基本概念

   通过任意键信息查找一组数据中值信息的过程叫映射，Python语言中通过字典实现映射。Python语言中的字典可以通过大括号({})建立，建立模式如下：

{<键1>:<值1>, <键2>:<值2>, … , <键n>:<值n>}

 其中，键和值通过冒号连接，不同键值对通过逗号隔开。

**键必须是唯一的，值可以相同；**

**键必须是不可变的，如字符串，数字，元组。**

**值可以取任何数据类型。**

字典打印出来的顺序与创建之初的顺序不同，这不是错误。字典是集合类型的延续，各个元素没有顺序之分



#####             创建字典

**创建空字典：** 

​      字典变量={}

​      字典变量=dict()

**创建非空字典**：  

​      字典变量={<键1>:<值1>, <键2>:<值2>, … , <键n>:<值n>}



#####            访问字典

字典可以使用key来访问字典中的元素。

采用中括号格式，语法：

​          值=字典变量[键] 

采用字典类型的方法：

​           值=字典变量.get(键,default=None)             

```python
>>>Dcountry={"中国":"北京", "美国":"华盛顿", "法国":"巴黎"}

>>>Dcountry["中国"]
'北京'

>>>Dcountry.get('美国')
‘华盛顿’

```

**get()**中键对应的值存在，就返回值；不存在，就返回默认值



#####       **采用字典类型的方法：**

1、字典变量.keys()，返回字典中所有的键信息。

2、字典变量.values()，返回字典中所有的值信息。

3、字典变量.items()，返回所有的键值对。

可以使用list()将以上返回值类型转换成列表。

```python
>>>Dcountry={"中国":"北京", "美国":"华盛顿", "法国":"巴黎"}
>>>Dcountry.keys()
dict_keys(['中国', '美国', '法国'])
>>>Dcountry.values()
dict_values(['北京', '华盛顿', '巴黎'])
>>>Dcountry.items()
dict_items([('中国', '北京'), ('美国', '华盛顿'), ('法国', '巴黎')])
```



#####           修改字典

**更新键值对信息：**  

​      字典变量[键]=值 

```python
>>>Dcountry["中国"]='大北京'
>>>print(Dcountry)
{'中国': '大北京', '法国': '巴黎', '美国': '华盛顿'}
```

**添加新的键值对：**  

​      字典变量[键]=值  

```python
>>>Dcountry={"中国":"北京", "美国":"华盛顿", "法国":"巴黎"}
>>>Dcountry["英国"]="伦敦"
>>>print(Dcountry)
{'中国': '北京', '法国': '巴黎', '美国': '华盛顿', '英国': '伦敦'}
```

#####          删除字典

删除键值对： 

​      del 字典变量[键] 

清空字典： 

​      字典变量.clear()  

删除字典：  

​      del 字典变量



#####     字典类型的操作

字典是实现键值对映射的数据结构，请理解如下基本原则：

字典是一个键值对的集合，该集合以键为索引，一个键信息只对应一个值信息；

字典中元素以键信息为索引访问；

字典长度是可变的，可以通过对键信息赋值实现增加或修改键值对。 

![字典类型的操作](https://pic.imgdb.cn/item/65b8ee45871b83018a26c1f8.png)

  与其他组合类型一样，字典可以通过for…in语句对其元素进行遍历，基本语法结构如下：

  

```python
 for <变量名> in <字典名>:

       语句块
```

此时for循环返回的变量名是字典的索引值key

```python
>>>for key in Dcountry:
   print(key)
中国
美国
法国
```

```python
 for k,v in <字典名>.items():

     语句块
```

此时for循环返回的两个变量是字典的key和value

```python
dic={"中国":1,"美国":2,"俄罗斯":3}
for k,v in sorted(dic.items(),key= lambda item:item[1],reverse=True):#
      print('{} {}'.format(k,v))
俄罗斯 3
美国 2
中国 1
```

#####         补充内容：sorted()

   sorted() 函数对所有可迭代的对象进行排序操作。    

   sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。

   语法格式：sorted(iterable, key=None, reverse=False)

•iterable-----可迭代对象

•key--------设置用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。

•返回值：返回重新排序的列表。

```python
>>>dic={"中国":1,"美国":2,"俄罗斯":3}
>>>sorted(dic.items(),key= lambda item:item[1],reverse=True):
#item[1]表示按字典的value排序，item[0]按字典的key排序
 [('俄罗斯', 3), ('美国', 2), ('中国', 1)]
   
>>>sorted(dic) #给dic的key排序
['中国', '俄罗斯', '美国']

```

### 6.4 基本统计值的计算

   以最简单的统计问题为例，求解一组不定长数据的基本统计值，即平均值、标准差、中位数。

由于平均数、标准差和中位数是三个不同的计算目标，使用函数方式编写计算程序。

 getNum()函数从用户输入获得数据

 mean()函数计算平均值

 dev()函数计算标准差

 median()函数计算中位数

列表在实现基本数据统计时发挥了重要作用，表现在：

列表是一个动态长度的数据结构，可以根据需求增加或减少元素；

列表的一系列方法或操作符为计算提供了简单的元素运算手段；

列表提供了对每个元素的简单访问方式及所有元素的遍历方式。

### 6.5 jieba库的使用

#### 6.5.1 jieba库的概述

jieba是Python中一个重要的第三方**中文分词函数库**

```python
>>>import jieba
>>>jieba.lcut("中国是一个伟大的国家")
['中国', '是', '一个', '伟大', '的', '国家']
```

jieba库是第三方库，不是安装包自带，需要通过pip指令安装

```txt
:\>pip install jieba   # 或者 pip3 install jieba
```



**jieba**函数库支持三种分词模式：

1.**精确模式：**将句子最精准地切开，适合文本分析

2.**全模式：**把句子所有可以成词的词语都扫描出来，速度非常快，但是不能消除歧义

3.**搜索引擎模式：**在精确模式的基础上，对长词再次切分，适用于搜索引擎分词

![jieba库](https://pic.imgdb.cn/item/65b8ee46871b83018a26c59e.png)

```python
>>>import jieba
>>>jieba.lcut("中华人民共和国是一个伟大的国家")
['中华人民共和国', '是', '一个', '伟大', '的', '国家']
>>>jieba.lcut("中华人民共和国是一个伟大的国家", cut_all=True)
['中华', '中华人民', '中华人民共和国', '华人', '人民', '人民共和国', '共和', '共和国', '国是', '一个', '伟大', '的', '国家']
>>>jieba.lcut_for_search("中华人民共和国是一个伟大的国家")
['中华', '华人', '人民', '共和', '共和国', '中华人民共和国', '是', '一个', '伟大', '的', '国家']
```

#### 6.5.2 文本词频统计

**《Hamlet》英文词频统计**



![英文词频统计](https://pic.imgdb.cn/item/65b8ee46871b83018a26c67a.png)

运行程序后，输出结果如下

```python
>>> 
to          754
hamlet      462
it          416
that        391
is          340
not         314
lord        309
his         296
this        295
but         269
```



**《三国演义》人物出场统计**

![三国演义人物出场统计](https://pic.imgdb.cn/item/65b8ee46871b83018a26c76f.png)

![三国演义人物出场统计1](https://pic.imgdb.cn/item/65b8ee46871b83018a26c81c.png)

输出排序前5的单词，运行程序后，输出结果如下：

```python
>>> 
曹操         1451
孔明         1383
刘备         1252
关羽          784
张飞          358
```

## 七.网络爬虫

requests库------爬取HTML页面  

Beautiful S oup库-------解析HTML页面  

Re库------正则表达式库，提取页面关键信息  

Scrapy库-------专业网络爬虫框架

### 7.1 Http协议及requests库方法

**HTTP协议** HTTP(Hypertextꢀ Transferꢀ Protoco)，超文本传输协议。是用 于从万维网（ WWW:World Wide Web ）服务器传输超文本到本地浏 览器的传送协议。  HTTP 工作原理：  • HTTP 协议工作于客户端-服务端架构上。  • 浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器 发送所有请求。  • Web 服务器根据接收到的请求后，向客户端发送响应信息。

HTTP协议 HTTP协议采用URL作为定位网络资源的标识，

URL格式如下：  http://host[:port][path] 

host:合法的Internet主机域名或IP地址  

port: 端口号，缺省端口为80

path:请求资源的路径，服务器上的内部路径

### 7.2 HTTP协议对资源的操作

![http协议对资源的操作](https://pic.imgdb.cn/item/65b8ee52871b83018a26f8c3.png)

**理解PATCH和PUT的区别** 

假设URL位置有一组数据UserInfo，包括UserID、UserName等 20个字段  需求：用户修改了UserName，其他不变  • 采用PATCH，仅向URL提交UserName的局部更新请求  • 采用PUT，必须将所有20个字段一并提交到URL，未提交字段被删除  PATCH的最主要好处：节省网络带宽

**HTTP协议与Requests库** 

![http协议与request库](https://pic.imgdb.cn/item/65b8ee52871b83018a26f9bf.png)

### 7.3**Requests库的7个主要方法**



![request库的七个主要方法](https://pic.imgdb.cn/item/65b8ee52871b83018a26fb13.png)

**requests.get(url, params=None,****kwargs)



**requests.request(method, url, **kwargs)** 

**method :请求方式，对应get/put/post等7种**  

**url :  拟获取页面的url链接**  

**kwargs:控制访问的参数，共13个**



**method :请求方式**

```python
r=requests.request('GET', url, **kwargs)
r=requests.request('HEAD', url, **kwargs)
r=requests.request('POST', url, **kwargs)
r=requests.request('PUT', url, **kwargs)
r=requests.request('PATCH', url, **kwargs)
r=requests.request('DELETE', url, **kwargs)
r=requests.request('OPTIONS', url, **kwargs)

```

**kwargs:控制访问的参数，均为可选项**

```python
params :字典或字节序列，作为参数增加到url中
data:字典、字节序列或文件对象，作为Request的内容
json: JSON格式的数据，作为Request的内容
headers:字典，HTTP定制头
cookies:字典或CookieJar，Request中的cookie
auth:元组，支持HTTP认证功能
files:字典类型，传输文件
timeout:设定超时时间，秒为单位
proxies:字典类型，设定访问代理服务器，可以增加登录认证
allow_redirects :True/False，默认为True，重定向开关
stream:True/False，默认为True，获取内容立即下载开关
verify:True/False，默认为True，认证SSL证书开关
cert:本地SSL证书路径

```

requests.get(**url**, **params=None**,**kwargs)

requests.head(**url**, **kwargs)

requests.put(**url**, **data=None**,**\**kwargs)

requests.post(**url**, **data=None**,**json=None**,**kwargs)

向URL POST一个字典 自动编码为form（表单）

向URL POST一个字符串 自动编码为data

requests.patch(**url**, **data=None**,**kwargs)

requests.delete(**url**, **kwargs)



![request.get()](https://pic.imgdb.cn/item/65b8ee52871b83018a26fbed.png)

Response对象包含爬虫返回的内容  Response对象包含服务器返回的所有信息，也包含请求的 Request信息

### 7.4 Response对象的属性

![response对象的属性](https://pic.imgdb.cn/item/65b8ee57871b83018a270f20.png)



![response对象的属性2](https://pic.imgdb.cn/item/65b8ee57871b83018a270fc6.png)

### **7.5理解Response的编码**

 r.encoding 从HTTP header中猜测的响应内容编码方式

 r.apparent_encoding 从内容中分析出的响应内容编码方式（备选编码方式） 

 r.encoding：如果header中不存在charset，则认为编码为 ISO‐8859‐1，r.text根据r.encoding显示网页内容 

 r.apparent_encoding：根据网页内容分析出的编码方式， 可以看作是r.encoding的备选



### 7.6爬取网页的通用代码框架

#### 7.6.1理解Requests库的异常

![request库的异常](https://pic.imgdb.cn/item/65b8ee57871b83018a271081.png)

![requests的异常](https://pic.imgdb.cn/item/65b8ee57871b83018a271145.png)

#### 7.6.2   爬取网页的通用代码框架



![爬取网页的通用代码框架](https://pic.imgdb.cn/item/65b8ee58871b83018a271214.png)



## 八.数据分析与处理

### 8.1 Beautiful Soup库

[Beautiful Soup](http://www.crummy.com/software/BeautifulSoup/) 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时间.

#### 8.1.1 Beautiful Soup库的基本元素

![Beautiful Soap库的理解](https://pic.imgdb.cn/item/65b8ee5e871b83018a272f6c.png)





![Beautiful Soup库的理解](https://pic.imgdb.cn/item/65b8ee5f871b83018a27303b.png)

#### 8.1.2 Beautiful Soup库的引用

Beautiful Soup库，也叫beautifulsoup4 或 bs4 约定引用方式如下，即主要是用BeautifulSoup类

from bs4 import BeautifulSoup 

import bs4

#### 8.1.3 BeautifulSoup类

![beautiful类](https://pic.imgdb.cn/item/65b8ee5f871b83018a273144.png)



#### 8.1.4 Beautiful Soup库解析器

![beautifulsoup库1](https://pic.imgdb.cn/item/65b8ee5f871b83018a273202.png)



#### 8.1.5 BeautifulSoup类的基本元素 

![beautifulsoup类的基本元素](https://pic.imgdb.cn/item/65b8ee60871b83018a2735a3.png)



![tag标签](https://pic.imgdb.cn/item/65b8ee64871b83018a274788.png)



![tag的name](https://pic.imgdb.cn/item/65b8ee64871b83018a274850.png)



![tag的attrs(属性)](https://pic.imgdb.cn/item/65b8ee64871b83018a274955.png)





![tag的navigablestring](https://pic.imgdb.cn/item/65b8ee65871b83018a274a9b.png)







![tag的comment](https://pic.imgdb.cn/item/65b8ee65871b83018a274bb2.png)



#### 8.1.6 基于bs4库的HTML内容遍历方法 

![html遍历](https://pic.imgdb.cn/item/65b8ee6a871b83018a276051.png)

![标签树的下行遍历](https://pic.imgdb.cn/item/65b8ee6a871b83018a27610c.png)





![标签树的下行遍历1](https://pic.imgdb.cn/item/65b8ee6a871b83018a2761f6.png)



![标签树的下行遍历2](https://pic.imgdb.cn/item/65b8ee6a871b83018a2762a2.png)



![标签树的上行遍历1](https://pic.imgdb.cn/item/65b8ee6a871b83018a27634d.png)





![标签树的上行遍历2](https://pic.imgdb.cn/item/65b8ee6f871b83018a277522.png)





![标签树的上行遍历3](https://pic.imgdb.cn/item/65b8ee6f871b83018a2775b6.png)





![标签树的平行遍历1](https://pic.imgdb.cn/item/65b8ee6f871b83018a277671.png)





![标签树的平行遍历2](https://pic.imgdb.cn/item/65b8ee6f871b83018a277700.png)



![标签树的平行遍历3](https://pic.imgdb.cn/item/65b8ee6f871b83018a277801.png)



![标签树的平行遍历4](https://pic.imgdb.cn/item/65b8ee77871b83018a279520.png)



![下上平遍历总结](https://pic.imgdb.cn/item/65b8ee77871b83018a2795f1.png)



#### 8.1.7 基于bs4库的HTML格式输出

能否让HTML内容更加“友好”的显示？

![bs4库的prettify()方法](https://pic.imgdb.cn/item/65b8ee77871b83018a2796bd.png)





![bs4库的prettify()方法1](https://pic.imgdb.cn/item/65b8ee77871b83018a2798f3.png)



![bs4库的prettify()方法2](https://pic.imgdb.cn/item/65b8ee78871b83018a2799d2.png)



![bs4库的prettify()方法3](https://pic.imgdb.cn/item/65b8ee7c871b83018a27ac27.png)

#### 8.1.8 bs4库的编码 

![bs4库的编码](https://pic.imgdb.cn/item/65b8ee7c871b83018a27aba3.png)



### 8.2  信息标记与提取方式

#### 8.2.1信息标记



![信息的标记](https://pic.imgdb.cn/item/65b8ee7c871b83018a27ad30.png)

标记后的信息可形成信息组织结构，增加了信息维度  

标记的结构与信息一样具有重要价值  

标记后的信息可用于通信、存储或展示  

标记后的信息更利于程序理解和运用



8.2.2信息标记的三种形式

xml json yaml



![xml](https://pic.imgdb.cn/item/65b8ee7c871b83018a27ade8.png)

![xml1](https://pic.imgdb.cn/item/65b8ee7d871b83018a27ae62.png)





![xml2](https://pic.imgdb.cn/item/65b8ee82871b83018a27c2ce.png)

![json1](https://pic.imgdb.cn/item/65b8ee82871b83018a27c3c1.png)





![json2](https://pic.imgdb.cn/item/65b8ee82871b83018a27c481.png)



![json3](https://pic.imgdb.cn/item/65b8ee82871b83018a27c551.png)



![yaml1](https://pic.imgdb.cn/item/65b8ee82871b83018a27c5ea.png)



![yaml2](https://pic.imgdb.cn/item/65b8ee89871b83018a27e34a.png)





![yaml3](https://pic.imgdb.cn/item/65b8ee89871b83018a27e3d8.png)



![yaml4](https://pic.imgdb.cn/item/65b8ee89871b83018a27e4bd.png)

#### 8.2.2三种信息标记形式的比较

![标记比较](https://pic.imgdb.cn/item/65b8ee89871b83018a27e59d.png)





![标记实例比较](https://pic.imgdb.cn/item/65b8ee8a871b83018a27e6ca.png)



XML最早的通用信息标记语言，可扩展性好，但繁琐  

JSON信息有类型，适合程序处理(js)，较XML简洁  

YAML信息无类型，文本信息比例最高，可读性好

XML  Internet上的信息交互与传递  

JSON 移动应用云端和节点的信息通信，无注释

YAML 各类系统的配置文件，有注释易读

#### 8.2.3信息提取的一般方法

方法一：完整解析信息的标记形式，再提取关键信息  XML JSON YAML 

需要标记解析器，例如：bs4库的标签树遍历  优点：信息解析准确  缺点：提取过程繁琐，速度慢

方法二：无视标记形式，直接搜索关键信息  搜索  对信息的文本查找函数即可  

优点：提取过程简洁，速度较快  缺点：提取结果准确性与信息内容相关

融合方法：结合形式解析与搜索方法，提取关键信息  XML JSON YAML 搜索  需要标记解析器及文本查找函数

#### 8.2.4基于bs4库的HTML内容查找方法

![bs查找](https://pic.imgdb.cn/item/65b8ee95871b83018a28194c.png)



![bs查找2](https://pic.imgdb.cn/item/65b8ee95871b83018a281b30.png)



**扩展方法**

![bs查找扩展方法](https://pic.imgdb.cn/item/65b8ee96871b83018a281be2.png)



### 8.3 re(正则表达式)入门

#### 8.3.1正则表达式概念

![正则表达式概念](https://pic.imgdb.cn/item/65b8ee96871b83018a281d68.png)

#### 8.3.2正则表达式语法

![正则表达式语法](https://pic.imgdb.cn/item/65b8ee97871b83018a281f70.png)

#### 8.3.3 re库的使用

![re库使用](https://pic.imgdb.cn/item/65b8eea1871b83018a284c68.png)



**re库主要功能函数**

![re主要功能函数](https://pic.imgdb.cn/item/65b8eea1871b83018a284d09.png)

![re函数](https://pic.imgdb.cn/item/65b8eea2871b83018a284eec.png)







![re函数2](https://pic.imgdb.cn/item/65b8eea2871b83018a285082.png)



**re库的另一种等价用法**

![re库的另一种等价用法](https://pic.imgdb.cn/item/65b8eea2871b83018a2851a2.png)



**re的match对象**

![re的match对象](https://pic.imgdb.cn/item/65b8eea6871b83018a286099.png)



**re 的贪婪匹配和最小匹配**

![re的贪婪和最小](https://pic.imgdb.cn/item/65b8eea6871b83018a2861f5.png)

### 8.4 文件的读写

Python3 File(文件) 方法

**open() 方法**

Python **open()** 方法用于打开一个文件，并返回文件对象。

在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 **OSError**。

**注意：**使用 **open()** 方法一定要保证关闭文件对象，即调用 **close()** 方法。

**open()** 函数常用形式是接收两个参数：文件名(file)和模式(mode)。

```
open(file, mode='r')
```

完整的语法格式为：

```
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
```

参数说明:

- file: 必需，文件路径（相对或者绝对路径）。
- mode: 可选，文件打开模式
- buffering: 设置缓冲
- encoding: 一般使用utf8
- errors: 报错级别
- newline: 区分换行符
- closefd: 传入的file参数类型
- opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。

mode 参数有：

| 模式 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| t    | 文本模式 (默认)。                                            |
| x    | 写模式，新建一个文件，如果该文件已存在则会报错。             |
| b    | 二进制模式。                                                 |
| +    | 打开一个文件进行更新(可读可写)。                             |
| U    | 通用换行模式（**Python 3 不支持**）。                        |
| r    | 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 |
| rb   | 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 |
| r+   | 打开一个文件用于读写。文件指针将会放在文件的开头。           |
| rb+  | 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 |
| w    | 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 |
| wb   | 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 |
| w+   | 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 |
| wb+  | 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 |
| a    | 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |
| ab   | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |
| a+   | 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 |
| ab+  | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 |

默认为文本模式，如果要以二进制模式打开，加上 **b** 。

**file 对象**

file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：

| 序号 | 方法及描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | [file.close()](https://www.runoob.com/python3/python3-file-close.html)关闭文件。关闭后文件不能再进行读写操作。 |
| 2    | [file.flush()](https://www.runoob.com/python3/python3-file-flush.html)刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。 |
| 3    | [file.fileno()](https://www.runoob.com/python3/python3-file-fileno.html)返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。 |
| 4    | [file.isatty()](https://www.runoob.com/python3/python3-file-isatty.html)如果文件连接到一个终端设备返回 True，否则返回 False。 |
| 5    | [file.next()](https://www.runoob.com/python3/python3-file-next.html)**Python 3 中的 File 对象不支持 next() 方法。**返回文件下一行。 |
| 6    | [file.read([size\])](https://www.runoob.com/python3/python3-file-read.html)从文件读取指定的字节数，如果未给定或为负则读取所有。 |
| 7    | [file.readline([size\])](https://www.runoob.com/python3/python3-file-readline.html)读取整行，包括 "\n" 字符。 |
| 8    | [file.readlines([sizeint\])](https://www.runoob.com/python3/python3-file-readlines.html)读取所有行并返回列表，若给定sizeint>0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。 |
| 9    | [file.seek(offset[, whence\])](https://www.runoob.com/python3/python3-file-seek.html)移动文件读取指针到指定位置 |
| 10   | [file.tell()](https://www.runoob.com/python3/python3-file-tell.html)返回文件当前位置。 |
| 11   | [file.truncate([size\])](https://www.runoob.com/python3/python3-file-truncate.html)从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。 |
| 12   | [file.write(str)](https://www.runoob.com/python3/python3-file-write.html)将字符串写入文件，返回的是写入的字符长度。 |
| 13   | [file.writelines(sequence)](https://www.runoob.com/python3/python3-file-writelines.html)向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。 |

#### Python with 关键字

Python 中的 **with** 语句用于异常处理，封装了 **try…except…finally** 编码范式，提高了易用性。

**with** 语句使代码更清晰、更具可读性， 它简化了文件流等公共资源的管理。

在处理文件对象时使用 with 关键字是一种很好的做法。

我们可以看下以下几种代码实例：

不使用 **with**，也不使用 **try…except…finally**

**实例**

file = open('./test_runoob.txt', 'w')
file.write('hello world !')
file.close()

以上代码如果在调用 write 的过程中，出现了异常，则 close 方法将无法被执行，因此资源就会一直被该程序占用而无法被释放。 接下来我们呢可以使用 **try…except…finally** 来改进代码：

**实例**

file = open('./test_runoob.txt', 'w')
**try**:
  file.write('hello world')
**finally**:
  file.close()

以上代码我们对可能发生异常的代码处进行 try 捕获，发生异常时执行 except 代码块，finally 代码块是无论什么情况都会执行，所以文件会被关闭，不会因为执行异常而占用资源。

使用 **with** 关键字：

**实例**

**with** open('./test_runoob.txt', 'w') **as** file:
  file.write('hello world !')

使用 **with** 关键字系统会自动调用 f.close() 方法， with 的作用等效于 try/finally 语句是一样的。

我们可以在执行 with 关键字后检验文件是否关闭：

**实例**

\>>> **with** open('./test_runoob.txt') **as** f:
...   read_data = f.read()

\>>> # 查看文件是否关闭
\>>> f.closed
True

with 语句实现原理建立在上下文管理器之上。

上下文管理器是一个实现 **__enter__** 和 **__exit__** 方法的类。

使用 with 语句确保在嵌套块的末尾调用 __exit__ 方法。

这个概念类似于 try...finally 块的使用。

**实例**

**with** open('./test_runoob.txt', 'w') **as** my_file:
  my_file.write('hello world!')

以上实例将 **hello world!** 写到 ./test_runoob.txt 文件上。

在文件对象中定义了 __enter__ 和 __exit__ 方法，即文件对象也实现了上下文管理器，首先调用 __enter__ 方法，然后执行 with 语句中的代码，最后调用 __exit__ 方法。 即使出现错误，也会调用 __exit__ 方法，也就是会关闭文件流。

### 8.5  Python3 OS 文件/目录方法

**os** 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示：

| 序号 | 方法及描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | [os.access(path, mode)](https://www.runoob.com/python3/python3-os-access.html) 检验权限模式 |
| 2    | [os.chdir(path)](https://www.runoob.com/python3/python3-os-chdir.html) 改变当前工作目录 |
| 3    | [os.chflags(path, flags)](https://www.runoob.com/python3/python3-os-chflags.html) 设置路径的标记为数字标记。 |
| 4    | [os.chmod(path, mode)](https://www.runoob.com/python3/python3-os-chmod.html) 更改权限 |
| 5    | [os.chown(path, uid, gid)](https://www.runoob.com/python3/python3-os-chown.html) 更改文件所有者 |
| 6    | [os.chroot(path)](https://www.runoob.com/python3/python3-os-chroot.html) 改变当前进程的根目录 |
| 7    | [os.close(fd)](https://www.runoob.com/python3/python3-os-close.html) 关闭文件描述符 fd |
| 8    | [os.closerange(fd_low, fd_high)](https://www.runoob.com/python3/python3-os-closerange.html) 关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略 |
| 9    | [os.dup(fd)](https://www.runoob.com/python3/python3-os-dup.html) 复制文件描述符 fd |
| 10   | [os.dup2(fd, fd2)](https://www.runoob.com/python3/python3-os-dup2.html) 将一个文件描述符 fd 复制到另一个 fd2 |
| 11   | [os.fchdir(fd)](https://www.runoob.com/python3/python3-os-fchdir.html) 通过文件描述符改变当前工作目录 |
| 12   | [os.fchmod(fd, mode)](https://www.runoob.com/python3/python3-os-fchmod.html) 改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。 |
| 13   | [os.fchown(fd, uid, gid)](https://www.runoob.com/python3/python3-os-fchown.html) 修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。 |
| 14   | [os.fdatasync(fd)](https://www.runoob.com/python3/python3-os-fdatasync.html) 强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。 |
| 15   | [os.fdopen(fd[, mode[, bufsize\]])](https://www.runoob.com/python3/python3-os-fdopen.html) 通过文件描述符 fd 创建一个文件对象，并返回这个文件对象 |
| 16   | [os.fpathconf(fd, name)](https://www.runoob.com/python3/python3-os-fpathconf.html) 返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。 |
| 17   | [os.fstat(fd)](https://www.runoob.com/python3/python3-os-fstat.html) 返回文件描述符fd的状态，像stat()。 |
| 18   | [os.fstatvfs(fd)](https://www.runoob.com/python3/python3-os-fstatvfs.html) 返回包含文件描述符fd的文件的文件系统的信息，Python 3.3 相等于 statvfs()。 |
| 19   | [os.fsync(fd)](https://www.runoob.com/python3/python3-os-fsync.html) 强制将文件描述符为fd的文件写入硬盘。 |
| 20   | [os.ftruncate(fd, length)](https://www.runoob.com/python3/python3-os-ftruncate.html) 裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。 |
| 21   | [os.getcwd()](https://www.runoob.com/python3/python3-os-getcwd.html) 返回当前工作目录 |
| 22   | [os.getcwdb()](https://www.runoob.com/python3/python3-os-getcwdb.html) 返回一个当前工作目录的Unicode对象 |
| 23   | [os.isatty(fd)](https://www.runoob.com/python3/python3-os-isatty.html) 如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。 |
| 24   | [os.lchflags(path, flags)](https://www.runoob.com/python3/python3-os-lchflags.html) 设置路径的标记为数字标记，类似 chflags()，但是没有软链接 |
| 25   | [os.lchmod(path, mode)](https://www.runoob.com/python3/python3-os-lchmod.html) 修改连接文件权限 |
| 26   | [os.lchown(path, uid, gid)](https://www.runoob.com/python3/python3-os-lchown.html) 更改文件所有者，类似 chown，但是不追踪链接。 |
| 27   | [os.link(src, dst)](https://www.runoob.com/python3/python3-os-link.html) 创建硬链接，名为参数 dst，指向参数 src |
| 28   | [os.listdir(path)](https://www.runoob.com/python3/python3-os-listdir.html) 返回path指定的文件夹包含的文件或文件夹的名字的列表。 |
| 29   | [os.lseek(fd, pos, how)](https://www.runoob.com/python3/python3-os-lseek.html) 设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效 |
| 30   | [os.lstat(path)](https://www.runoob.com/python3/python3-os-lstat.html) 像stat(),但是没有软链接 |
| 31   | [os.major(device)](https://www.runoob.com/python3/python3-os-major.html) 从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。 |
| 32   | [os.makedev(major, minor)](https://www.runoob.com/python3/python3-os-makedev.html) 以major和minor设备号组成一个原始设备号 |
| 33   | [os.makedirs(path[, mode\])](https://www.runoob.com/python3/python3-os-makedirs.html) 递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。 |
| 34   | [os.minor(device)](https://www.runoob.com/python3/python3-os-minor.html) 从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。 |
| 35   | [os.mkdir(path[, mode\])](https://www.runoob.com/python3/python3-os-mkdir.html) 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。 |
| 36   | [os.mkfifo(path[, mode\])](https://www.runoob.com/python3/python3-os-mkfifo.html) 创建命名管道，mode 为数字，默认为 0666 (八进制) |
| 37   | [os.mknod(filename[, mode=0600, device\])](https://www.runoob.com/python3/python3-os-mknod.html) 创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。 |
| 38   | [os.open(file, flags[, mode\])](https://www.runoob.com/python3/python3-os-open.html) 打开一个文件，并且设置需要的打开选项，mode参数是可选的 |
| 39   | [os.openpty()](https://www.runoob.com/python3/python3-os-openpty.html) 打开一个新的伪终端对。返回 pty 和 tty的文件描述符。 |
| 40   | [os.pathconf(path, name)](https://www.runoob.com/python3/python3-os-pathconf.html) 返回相关文件的系统配置信息。 |
| 41   | [os.pipe()](https://www.runoob.com/python3/python3-os-pipe.html) 创建一个管道. 返回一对文件描述符(r, w) 分别为读和写 |
| 42   | [os.popen(command[, mode[, bufsize\]])](https://www.runoob.com/python3/python3-os-popen.html) 从一个 command 打开一个管道 |
| 43   | [os.read(fd, n)](https://www.runoob.com/python3/python3-os-read.html) 从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。 |
| 44   | [os.readlink(path)](https://www.runoob.com/python3/python3-os-readlink.html) 返回软链接所指向的文件 |
| 45   | [os.remove(path)](https://www.runoob.com/python3/python3-os-remove.html) 删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。 |
| 46   | [os.removedirs(path)](https://www.runoob.com/python3/python3-os-removedirs.html) 递归删除目录。 |
| 47   | [os.rename(src, dst)](https://www.runoob.com/python3/python3-os-rename.html) 重命名文件或目录，从 src 到 dst |
| 48   | [os.renames(old, new)](https://www.runoob.com/python3/python3-os-renames.html) 递归地对目录进行更名，也可以对文件进行更名。 |
| 49   | [os.rmdir(path)](https://www.runoob.com/python3/python3-os-rmdir.html) 删除path指定的空目录，如果目录非空，则抛出一个OSError异常。 |
| 50   | [os.stat(path)](https://www.runoob.com/python3/python3-os-stat.html) 获取path指定的路径的信息，功能等同于C API中的stat()系统调用。 |
| 51   | [os.stat_float_times([newvalue\])](https://www.runoob.com/python3/python3-os-stat_float_times.html) 决定stat_result是否以float对象显示时间戳 |
| 52   | [os.statvfs(path)](https://www.runoob.com/python3/python3-os-statvfs.html) 获取指定路径的文件系统统计信息 |
| 53   | [os.symlink(src, dst)](https://www.runoob.com/python3/python3-os-symlink.html) 创建一个软链接 |
| 54   | [os.tcgetpgrp(fd)](https://www.runoob.com/python3/python3-os-tcgetpgrp.html) 返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组 |
| 55   | [os.tcsetpgrp(fd, pg)](https://www.runoob.com/python3/python3-os-tcsetpgrp.html) 设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。 |
| 56   | os.tempnam([dir[, prefix]]) **Python3 中已删除。**返回唯一的路径名用于创建临时文件。 |
| 57   | os.tmpfile() **Python3 中已删除。**返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。 |
| 58   | os.tmpnam() **Python3 中已删除。**为创建一个临时文件返回一个唯一的路径 |
| 59   | [os.ttyname(fd)](https://www.runoob.com/python3/python3-os-ttyname.html) 返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。 |
| 60   | [os.unlink(path)](https://www.runoob.com/python3/python3-os-unlink.html) 删除文件路径 |
| 61   | [os.utime(path, times)](https://www.runoob.com/python3/python3-os-utime.html) 返回指定的path文件的访问和修改的时间。 |
| 62   | [os.walk(top[, topdown=True[, onerror=None[, followlinks=False\]]])](https://www.runoob.com/python3/python3-os-walk.html) 输出在文件夹中的文件名通过在树中游走，向上或者向下。 |
| 63   | [os.write(fd, str)](https://www.runoob.com/python3/python3-os-write.html) 写入字符串到文件描述符 fd中. 返回实际写入的字符串长度 |
| 64   | [os.path 模块](https://www.runoob.com/python3/python3-os-path.html) 获取文件的属性信息。 |
| 65   | [os.pardir()](https://www.runoob.com/python3/python3-os-pardir.html) 获取当前目录的父目录，以字符串形式显示目录名。 |
| 66   | [os.replace()](https://www.runoob.com/python3/python3-os-replace.html) 重命名文件或目录。 |

# python知识点总结

### 1.and和or的用法

https://blog.csdn.net/Echo_Zhang12/article/details/111330901

**在python中：None、任何数值类型中的0、空字符串“”、空元组()、空列表[]、空字典{}都被当作False，还有自定义类型，如果实现了 　__ nonzero __ ()　或　__ len __ () 方法且方法返回 0 或False，则其实例也被当作False，其他对象均为True。**

### 2.list('[1,2,3]')

在Python中，字符串按照字典顺序进行比较。在字典顺序中，比较的是字符串的第一个字符，如果第一个字符相同，则比较下一个字符，以此类推，直到找到不相等的字符为止。如果一个字符串已经结束而另一个字符串还有剩余字符，则较短的字符串被视为更小。
在比较 '11'，'2' 和 '3' 时，首先会比较第一个字符。在这里，'1' 是比 '2' 和 '3' 更小的，因此 '11' 被认为比 '2' 和 '3' 更小，即使后面的字符不同，因为在第一个位置上就有明确的大小关系。

### 3.min(['11'，'2','3'])

在Python中，字符串按照字典顺序进行比较。在字典顺序中，比较的是字符串的第一个字符，如果第一个字符相同，则比较下一个字符，以此类推，直到找到不相等的字符为止。如果一个字符串已经结束而另一个字符串还有剩余字符，则较短的字符串被视为更小。
在比较 '11'，'2' 和 '3' 时，首先会比较第一个字符。在这里，'1' 是比 '2' 和 '3' 更小的，因此 '11' 被认为比 '2' 和 '3' 更小，即使后面的字符不同，因为在第一个位置上就有明确的大小关系。

4.
