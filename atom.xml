<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博客</title>
  
  <subtitle>博客</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-02-02T02:58:28.632Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Tingfeng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据采集集训</title>
    <link href="http://example.com/2024/02/01/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%AE%9E%E8%AE%AD/"/>
    <id>http://example.com/2024/02/01/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%AE%9E%E8%AE%AD/</id>
    <published>2024-02-01T07:30:22.000Z</published>
    <updated>2024-02-02T02:58:28.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python实训"><a href="#python实训" class="headerlink" title="python实训"></a>python实训</h1><p><strong>一、项目目的与意义</strong></p><p><strong>二、项目的内容与操作环境</strong></p><p><strong>三、项目实施过程</strong></p><p><strong>四、项目分工与完成情况</strong></p><p><strong>五、项目总结及收获</strong></p><p><strong>一、项目目的与意义</strong></p><p>数据采集课程设计是计算机科学与技术专业的一门专业课程，涉及python编程、数据库技术等课程。课程设计的目的是使学生掌握数据采集以及预处理的技术，理解数据采集的原理以及实现，培养学生综合运用所学知识的能力。通过数据采集项目解决实际问题，培养学生严谨的学习态度和良好的学习习惯。</p><p>数据采集课程是一门旨在教授如何使用 Python 编写程序来获取、处理和分析数据的课程。该课程将介绍如何使用 Python 编写网络爬虫、解析 HTML 页面、使用数据库存储数据并对数据进行预处理。旨在通过本次课程设计，锻炼学生发现问题、解决问题、综合编程、团队合作等方面的能力，通过案例开发掌握python爬虫基础技术和数据采集以及预处理思路，了侧重实践能力引导和培养。由浅入深的带领学生熟悉数据采集的技术和原理，并辅导学生一步一步的完成项目的开发，学习和提高数据采集和处理能力，提高项目开发能力，注重学生团队意识培养。</p><p><strong>二、项目的内容与操作环境</strong></p><p><strong>（一）项目内容</strong></p><p>本项目的目的是通过使用Python爬虫技术从目标网站上爬取数据，并将数据存储到MySQL数据库中，然后使用Kettle软件对爬取的数据进行处理。通过这个项目，学生可以学习并掌握Python爬虫的基本原理和实现方法，了解MySQL数据库的基本操作和Kettle软件的使用，同时也可以提高学生对数据处理和数据清洗的认识和实践能力。</p><p><strong>（二）项目环境</strong></p><p>   一台PC机，Windows10&#x2F;11操作系统，Pycharm，JDK8，MySQL数据库,Navicat premium15,kettle</p><p><strong>三、项目实施过程</strong></p><p><strong>一.基础环境搭建安装</strong></p><p><strong>1.python相关库安装</strong></p><p>安装爬虫所需的urllib和bs4包</p><p>pip install urllib3</p><p>pip install beautifulsoup4</p><p>安装数据入库所需的包</p><p>pip install pymysql</p><p>安装数据可视化所需要的包</p><p>pip install pyecharts</p><p><strong>2. mysql数据库安装</strong></p><p>下载安装包</p><p>解压压缩包，将my.ini文件放到解压后的目录</p><p>命令行窗口下，切换到指定的文件夹下面</p><p>安装并启动mysql服务</p><p>启动mysql服务，配置远程可连接</p><p>用Navicat连接mysql数据库</p><p><strong>3. kettle软件安装并连接mysql数据库</strong></p><p><a href="http://解压缩文件pdi-ce-8.2.0.0-342.zip/">解压缩文件pdi-ce-8.2.0.0-342.zip</a>解压完成之后，配置环境变量，环境变量指向Java的安装目录</p><p>kettle 连接数据库</p><p>mysql-connector-java-8.0.30.jar放在kettle 的lib文件夹下面</p><p>修改kettel中的sample-jndi文件夹下的配置文件</p><p>修改完成后，采用jndi的方式连接mysql数据库</p><p><strong>二.数据采集以及预处理</strong></p><p><strong>1.编写代码</strong></p><p>python爬虫数据采集，构造请求,使用urllib库</p><p>urllib库的主要作用是发送HTTP请求和处理响应。它支持同步和异步两种方式，可以发送GET、POST、PUT、DELETE等HTTP请求，并支持HTTPS协议。urllib库还提供了许多有用的功能，例如URL编码、处理Cookie、处理重定向等。</p><p>python爬虫数据采集，解析数据</p><p>Beautiful Soup是一个Python库，用于解析HTML和XML文档，包括从网页或其他来源获取内容，并以树形结构组织这些内容，使其可以轻松地通过标签名、属性、ID或搜索等来访问。</p><p>Beautiful Soup的主要作用是：</p><p>1.解析HTML或XML文档：Beautiful Soup可以将复杂的HTML或XML文档转换成一个复杂的树形结构，每个节点都是Python对象，这样你就可以很方便地查询、修改文档。</p><p>2.搜索文档：Beautiful Soup支持在树形文档中进行搜索，可以搜索标签名、属性、文本内容等</p><p><strong>2.登录网站获取获取cookie信息</strong></p><p>使用chrome浏览器打开惠农网的页面，注册登录之后，按F12</p><p>一次选择Application -&gt; Storage -&gt; Cookies -&gt; .c &gt; show Requests With Cookie，获取cookie信息后，将代码中的cookie信息替换掉</p><p><strong>三、项目实施过程</strong></p><p><img src="https://pic.imgdb.cn/item/65bc582b871b83018a13e532.png" alt="img"></p><p><strong>二.数据采集以及预处理</strong></p><p><strong>3.获取IP代理</strong></p><p>有些网站有反爬虫机制,通过代理ip可以绕开限制</p><p>1.首先解压proxy_<a href="http://pool-master.zip/">pool-master.zip</a>，解压之后用pycharm打开</p><p><a href="http://2.修改setting.py/">2.修改setting.py</a> DB_CONN &#x3D; ‘redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;0’</p><p>3.安装redis 运行 redis-cli.exe</p><p>4.python <a href="http://proxypool.py/">proxyPool.py</a> schedule </p><p>运行时如果报某个库不存在，用pip install 语句安装对应的库就可以</p><p>5.python <a href="http://proxypool.py/">proxyPool.py</a> server</p><p><img src="https://pic.imgdb.cn/item/65bc582b871b83018a13e644.png" alt="img"></p><p><strong>4.使用kettle做数据预处理</strong></p><p>Kettle是一款开源的ETL工具，纯java编写，可以在Window、Linux、Unix上运行，绿色无需安装。它允许你管理来自不同数据库的数据，通过提供一个图形化的用户环境来描述你想做什么，功能强大可以对多种数据源进行抽取（Extraction）、加载（Loading）、数据落湖（Data lake Injection）、对数据进行各种清洗（Cleaning）、转换（Transformation）、混合（Blending），并支持多维联机分析处理（OLAP）和数据挖掘（Data mining）</p><p>1.安装并打开kettle</p><p>2.kettle 连接数据库</p><p>3.kettle数据etl处理</p><p>  3.1数据抽取</p><p>  3.2数据转换</p><p>4.数据转换</p><p>  4.1数据剔重</p><p>  4.2缺失值替换</p><p>5.数据load（将数据加载到数据库中的新表）</p><p>6.查看新表product_info_new中的数据</p><p><img src="/upload/image-sbca.png" alt="img"></p><p><strong>三.数据可视化</strong></p><p><strong>1.编写代码</strong></p><p>导入相关库</p><p>import pandas as pd # 导入 pandas 库用于数据处理<br>import pymysql # 导入 pymysql 用于连接 MySQL 数据库<br>from pyecharts import options as opts # 导入 pyecharts 中的选项模块<br>from pyecharts.charts import Bar # 导入柱状图模块<br>from pyecharts.globals import ThemeType # 导入主题类型</p><p>连接到 MySQL 数据库<br>创建游标对象<br>编写 SQL 查询语句，获取数据<br>执行 SQL 查询，获取数据并存入 Pandas DataFrame<br>显示 DataFrame 的前 500 行数据<br>将 ‘price’ 列转换为浮点型，并筛选出小于 100 的值<br>按 ‘addr’ 列分组计算 ‘price’ 列的均值，排序并重置索引<br>提取前 20 个 ‘addr’ 和相应的 ‘price’ 值<br>定义一个函数，创建带有次级 y 轴的柱状图<br>渲染柱状图，并将其保存为一个 HTML 文件*<br>*<strong>2.运行</strong></p><p><strong>3.生成结果</strong></p><p><img src="https://pic.imgdb.cn/item/65bc582c871b83018a13e7af.png" alt="img"></p><p><strong>五、项目总结及收获</strong></p><p><strong>（一）难点问题&#x2F;关键技术&#x2F;优势与特色</strong></p><p><strong>1.难点问题</strong></p><p>Mysql安装后无法连接数据库，通过更改端口成功连接数据库</p><p>无法导入UserAgent库，通过手动在pycharm中导入</p><p>代理服务器运行时没有定位到相关目录，更改目录后成功运行</p><p>数据采集后通过kellte处行预处理时数据库结果一直不变，实际是每次预处理后都会在原来的记录下边生成，通过更改查看记录的范围，找到了原因</p><p>数据可视化时无法产生结果，通过渲染柱状图，并将其保存为一个 HTML 文件，成功打开结果</p><p><strong>2.关键技术</strong></p><p>Python语言编程和应用</p><p>Pycharm的安装与使用</p><p>JDK8的安装与配置环境变量</p><p>MySQL数据库的安装与连接</p><p>Navicat premium15的安装，连接与使用</p><p>Kettle的安装，配置和使用</p><p>数据采集技术，数据预处理技术和数据可视化技术的应用</p><p><strong>3.优势与特色</strong></p><p><strong>3.1除了使用本地数据库以外，我们还实现了云服务器数据库的配置和连接</strong></p><p><strong>配置云服务器</strong></p><p><strong>安装centos 系统</strong></p><p><strong>配置docker环境</strong></p><p><strong>通过docker拉取1panel可视化面板的镜像</strong></p><p><strong>通过1panel镜像创建容器</strong></p><p><strong>在1panel可视化面板里安装和配置mysql并成功连接</strong></p><p><strong>最后成功了实现采集数据到云数据库，预处理云数据库，可视化云服务器数据库数据</strong></p><p><img src="https://pic.imgdb.cn/item/65bc582b871b83018a13e3f8.png" alt="img"></p><p><strong>五</strong></p><p><strong>3.2通过青龙面板，实现了定期爬取数据和分析数据</strong></p><p><strong>通过docker拉取青龙面板镜像</strong></p><p><strong>通过青龙面板镜像创建容器并启动</strong></p><p><strong>导入数据爬取与可视化代码</strong></p><p><strong>添加相关依赖</strong></p><p><strong>添加定时任务</strong></p><p><strong>查看爬取和可视化结果总结及收获</strong></p><p><img src="https://pic.imgdb.cn/item/65bc582f871b83018a13edc9.png" alt="img"></p><p><strong>（二）团队体会与收获</strong></p><p>​     <strong>通过团队合作进行基于Python爬虫的数据采集与预处理的设计与实现，我们获得了技术实践的机会，提高了团队协作能力和问题解决能力，加深了对数据质量的认识，并获得了宝贵的学习与成长的机会。这些经验和收获将对我们未来的职业发展产生积极的影响，并为我们在数据领域的探索和进一步学习奠定了坚实基础。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># coding: utf-8</span><br><br><span class="hljs-comment"># 导入所需库</span><br><span class="hljs-keyword">import</span> csv  <span class="hljs-comment"># 用于 CSV 文件的读写操作</span><br><span class="hljs-keyword">import</span> urllib  <span class="hljs-comment"># 用于 URL 解析</span><br><span class="hljs-keyword">import</span> urllib.request  <span class="hljs-comment"># 用于 HTTP 请求</span><br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep  <span class="hljs-comment"># 用于添加延迟</span><br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup <span class="hljs-keyword">as</span> bs  <span class="hljs-comment"># 用于解析 HTML</span><br><span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> urljoin  <span class="hljs-comment"># 用于处理 URL</span><br><span class="hljs-keyword">import</span> pymysql  <span class="hljs-comment"># 用于连接 MySQL 数据库</span><br><span class="hljs-keyword">import</span> random  <span class="hljs-comment"># 用于生成随机数</span><br><span class="hljs-keyword">import</span> time  <span class="hljs-comment"># 用于处理时间</span><br><span class="hljs-keyword">import</span> requests  <span class="hljs-comment"># 用于发送 HTTP 请求</span><br><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen, build_opener  <span class="hljs-comment"># 用于构建 HTTP 请求</span><br><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> Request, HTTPHandler  <span class="hljs-comment"># 用于处理 HTTP 请求</span><br><span class="hljs-keyword">from</span> fake_useragent <span class="hljs-keyword">import</span> UserAgent  <span class="hljs-comment"># 用于生成浏览器 User-Agent</span><br><span class="hljs-keyword">import</span> urllib3  <span class="hljs-comment"># 用于禁用警告</span><br><br><span class="hljs-comment"># 关闭警告</span><br>urllib3.disable_warnings()<br><br><span class="hljs-comment"># 获取代理 IP</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getProxy</span>():<br>    res = requests.get(<span class="hljs-string">&#x27;http://127.0.0.1:5010/get/&#x27;</span>).json()  <span class="hljs-comment"># 从代理池获取代理 IP</span><br>    proxies = &#123;&#125;<br>    <span class="hljs-keyword">if</span> res[<span class="hljs-string">&#x27;https&#x27;</span>]:<br>        proxies[<span class="hljs-string">&#x27;https&#x27;</span>] = res[<span class="hljs-string">&#x27;proxy&#x27;</span>]  <span class="hljs-comment"># 设置 https 代理</span><br>    <span class="hljs-keyword">else</span>:<br>        proxies[<span class="hljs-string">&#x27;http&#x27;</span>] = res[<span class="hljs-string">&#x27;proxy&#x27;</span>]  <span class="hljs-comment"># 设置 http 代理</span><br>    <span class="hljs-keyword">return</span> proxies  <span class="hljs-comment"># 返回代理 IP 字典</span><br><br><span class="hljs-comment"># 获取页面信息</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_info</span>(<span class="hljs-params">page</span>):<br>    sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 添加延迟，防止访问过快被封禁</span><br>    url = <span class="hljs-string">&#x27;https://www.cnhnb.com/p/mianfen-0-0-0-0-&#123;&#125;/&#x27;</span>.<span class="hljs-built_in">format</span>(page)  <span class="hljs-comment"># 目标网站 URL</span><br>    proxy_ip = getProxy()[<span class="hljs-string">&#x27;http&#x27;</span>]  <span class="hljs-comment"># 使用随机获取的代理 IP</span><br>    <span class="hljs-built_in">print</span>(proxy_ip)<br>    proxy_handler = urllib.request.ProxyHandler(&#123;<span class="hljs-string">&quot;http&quot;</span>: proxy_ip&#125;)  <span class="hljs-comment"># 构造代理处理器对象</span><br>    opener = urllib.request.build_opener(proxy_handler, urllib.request.HTTPHandler)  <span class="hljs-comment"># 构造一个自定义的 opener 对象</span><br>    urllib.request.install_opener(opener)<br>    headers = &#123;&#125;  <span class="hljs-comment"># 构造请求头信息</span><br>    headers[<span class="hljs-string">&#x27;User-Agent&#x27;</span>] = UserAgent().chrome  <span class="hljs-comment"># 设置浏览器 User-Agent</span><br>    headers[<span class="hljs-string">&#x27;Accept&#x27;</span>] = <span class="hljs-string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span><br>    <span class="hljs-comment">############ 需修改为自己的 Cookie</span><br>    headers[<span class="hljs-string">&#x27;Cookie&#x27;</span>] = <span class="hljs-string">&#x27;hnUserTicket=a419fbb3-5682-4ce2-9e0d-979edd9273e3; hnUserId=112929418; deviceId=046a996-6383-4296-92f2-ffd4261ee; Hm_lvt_a6458082fb548e5ca7ff77d177d2d88d=1703735922; Hm_lvt_0e023fed85d2150e7d419b5b1f2e7c0f=1703730406,1703896759; Hm_lpvt_0e023fed85d2150e7d419b5b1f2e7c0f=1703896759; Hm_lvt_91cf34f62b9bedb16460ca36cf192f4c=1703730406,1703896759; Hm_lpvt_91cf34f62b9bedb16460ca36cf192f4c=1703896759&#x27;</span>  <span class="hljs-comment"># 添加自己的 Cookie</span><br>    req = Request(url, headers=headers)  <span class="hljs-comment"># 封装请求</span><br>    response = opener.<span class="hljs-built_in">open</span>(req)  <span class="hljs-comment"># 使用自定义的 opener 对象发起访问请求</span><br>    html = urllib.request.urlopen(req)<br>    soup = bs(html.read(), <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>    lu = soup.find_all(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;show-ctn&#x27;</span>)<br>    product_all = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> lu:<br>        product_name = i.find(<span class="hljs-string">&#x27;h2&#x27;</span>).get_text()  <span class="hljs-comment"># 获取产品名称</span><br>        supplier = i.find(<span class="hljs-string">&quot;a&quot;</span>).get_text()  <span class="hljs-comment"># 获取供应商</span><br>        supplier_web = i.find(<span class="hljs-string">&quot;a&quot;</span>).attrs[<span class="hljs-string">&#x27;href&#x27;</span>]  <span class="hljs-comment"># 获取供应商网址</span><br>        product_desc = i.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;shop-image&#x27;</span>).img.attrs[<span class="hljs-string">&#x27;alt&#x27;</span>]  <span class="hljs-comment"># 获取产品介绍</span><br>        product_img = i.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;shop-image&#x27;</span>).img.attrs[<span class="hljs-string">&#x27;src&#x27;</span>]  <span class="hljs-comment"># 获取产品图片</span><br>        product_price = <span class="hljs-built_in">str</span>(i.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;shops-price&#x27;</span>).get_text()).strip().replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment"># 获取产品价格</span><br>        addr = <span class="hljs-built_in">str</span>(i.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;r-shop-btm&#x27;</span>).get_text())  <span class="hljs-comment"># 获取发货地</span><br>        mailing_ins = <span class="hljs-built_in">str</span>(i.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;cw-tags&#x27;</span>).get_text()).strip().replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment"># 获取邮寄说明</span><br>        product = [product_name, supplier, supplier_web, product_desc, product_img, product_price, addr, mailing_ins]<br>        product_all.append(product)  <span class="hljs-comment"># 将提取的信息添加到列表中</span><br>    <span class="hljs-keyword">return</span> product_all  <span class="hljs-comment"># 返回产品信息列表</span><br><br><span class="hljs-comment"># 保存到 MySQL</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">save_mysql</span>(<span class="hljs-params">all_data</span>):<br>    conn = pymysql.connect(host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, user=<span class="hljs-string">&#x27;root&#x27;</span>, port=<span class="hljs-number">3306</span>, password=<span class="hljs-string">&#x27;123456&#x27;</span>, db=<span class="hljs-string">&#x27;mydb&#x27;</span>, charset=<span class="hljs-string">&#x27;utf8&#x27;</span>)  <span class="hljs-comment"># 连接 MySQL 数据库</span><br>    cursor = conn.cursor()<br>    insertsql = <span class="hljs-string">&#x27;insert into product_info(product_name,supplier,supplier_web,product_desc,product_img,product_price,addr,mailing_ins) value (%s,%s,%s,%s,%s,%s,%s,%s)&#x27;</span>  <span class="hljs-comment"># 插入数据 SQL 语句</span><br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> all_data:<br>        data = <span class="hljs-built_in">tuple</span>(data)<br>        cursor.execute(insertsql, data)  <span class="hljs-comment"># 执行插入数据操作</span><br>    conn.commit()  <span class="hljs-comment"># 提交事务</span><br><br><span class="hljs-comment"># 主程序入口</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    lst = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">88</span>)]  <span class="hljs-comment"># 生成页面列表</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(lst) &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> lst:<br>            <span class="hljs-keyword">try</span>:<br>                all_data = get_info(i)  <span class="hljs-comment"># 获取页面信息</span><br>                <span class="hljs-built_in">print</span>(i)<br>                lst.remove(i)  <span class="hljs-comment"># 移除已爬取的页面</span><br>                save_mysql(all_data)  <span class="hljs-comment"># 保存至 MySQL</span><br><br>            <span class="hljs-keyword">except</span>:<br>                <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># 忽略异常</span><br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入所需库</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd  <span class="hljs-comment"># 导入 pandas 库用于数据处理</span><br><span class="hljs-keyword">import</span> pymysql  <span class="hljs-comment"># 导入 pymysql 用于连接 MySQL 数据库</span><br><span class="hljs-keyword">from</span> pyecharts <span class="hljs-keyword">import</span> options <span class="hljs-keyword">as</span> opts  <span class="hljs-comment"># 导入 pyecharts 中的选项模块</span><br><span class="hljs-keyword">from</span> pyecharts.charts <span class="hljs-keyword">import</span> Bar  <span class="hljs-comment"># 导入柱状图模块</span><br><span class="hljs-keyword">from</span> pyecharts.commons.utils <span class="hljs-keyword">import</span> JsCode<br><span class="hljs-keyword">from</span> pyecharts.<span class="hljs-built_in">globals</span> <span class="hljs-keyword">import</span> ThemeType  <span class="hljs-comment"># 导入主题类型</span><br><span class="hljs-keyword">import</span> random<br><span class="hljs-comment"># 连接到 MySQL 数据库</span><br>db = pymysql.connect(host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, user=<span class="hljs-string">&#x27;root&#x27;</span>, port=<span class="hljs-number">3306</span>, password=<span class="hljs-string">&#x27;123456&#x27;</span>, db=<span class="hljs-string">&#x27;mydb&#x27;</span>, charset=<span class="hljs-string">&#x27;utf8&#x27;</span>)<br><br><span class="hljs-comment"># 创建游标对象</span><br>cursor = db.cursor()<br><br><span class="hljs-comment"># 编写 SQL 查询语句，获取数据</span><br>sql = <span class="hljs-string">&#x27;&#x27;&#x27;select addr,replace(product_price,&quot;元/斤&quot;,&quot;&quot;) price </span><br><span class="hljs-string">         from product_info_new1 </span><br><span class="hljs-string">         where product_price like &quot;%元/斤%&quot;&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># 执行 SQL 查询，获取数据并存入 Pandas DataFrame</span><br>cursor.execute(sql)<br>data = cursor.fetchall()  <span class="hljs-comment"># 获取所有查询结果</span><br>pd.set_option(<span class="hljs-string">&#x27;display.precision&#x27;</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 设置 pandas 显示精度</span><br>df = pd.DataFrame(<span class="hljs-built_in">list</span>(data), columns=[<span class="hljs-string">&#x27;addr&#x27;</span>, <span class="hljs-string">&#x27;price&#x27;</span>])  <span class="hljs-comment"># 创建 DataFrame 存储查询结果</span><br><br><span class="hljs-comment"># 显示 DataFrame 的前 500 行数据</span><br>df.head(<span class="hljs-number">500</span>)<br><br><span class="hljs-comment"># 将 &#x27;price&#x27; 列转换为浮点型，并筛选出小于 100 的值</span><br>df[<span class="hljs-string">&quot;price&quot;</span>] = pd.to_numeric(df[<span class="hljs-string">&quot;price&quot;</span>], downcast=<span class="hljs-string">&quot;float&quot;</span>)  <span class="hljs-comment"># 将价格列转换为浮点型</span><br>df = df[df.iloc[:, <span class="hljs-number">1</span>] &lt; <span class="hljs-number">100</span>]  <span class="hljs-comment"># 筛选出价格小于 100 的数据</span><br><br><span class="hljs-comment"># 按 &#x27;addr&#x27; 列分组计算 &#x27;price&#x27; 列的均值，排序并重置索引</span><br>price_mean = df.groupby(<span class="hljs-string">&quot;addr&quot;</span>)[<span class="hljs-string">&#x27;price&#x27;</span>].mean().sort_values(ascending=<span class="hljs-literal">False</span>).to_frame()  <span class="hljs-comment"># 按地址分组计算价格均值</span><br>price_mean.reset_index(inplace=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 重置索引</span><br><br><span class="hljs-comment"># 提取前 10 个 &#x27;addr&#x27; 和相应的 &#x27;price&#x27; 值</span><br>x = <span class="hljs-built_in">list</span>(price_mean[<span class="hljs-string">&#x27;addr&#x27;</span>])[<span class="hljs-number">0</span>:<span class="hljs-number">10</span>]  <span class="hljs-comment"># 获取前 10 个地址数据</span><br>y_tmp = <span class="hljs-built_in">list</span>(price_mean[<span class="hljs-string">&#x27;price&#x27;</span>])[<span class="hljs-number">0</span>:<span class="hljs-number">10</span>]  <span class="hljs-comment"># 获取前 10 个价格数据</span><br>y = [<span class="hljs-built_in">round</span>(num, <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> y_tmp]  <span class="hljs-comment"># 对价格数据保留一位小数并保存</span><br><br><span class="hljs-comment"># 定义一个函数，创建带有次级 y 轴的柱状图</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">overlap_bar_line</span>(<span class="hljs-params">x, y, title</span>) -&gt; Bar:<br>    <span class="hljs-comment"># 初始化柱状图，并设置主题为亮色</span><br>    bar = (<br>        Bar(init_opts=opts.InitOpts(theme=ThemeType.LIGHT))<br>        <span class="hljs-comment"># 设置 x 轴数据</span><br>        .add_xaxis(x)<br>        <span class="hljs-comment"># 添加 y 轴数据，并设置柱状图的宽度和样式</span><br>        .add_yaxis(<br>            <span class="hljs-string">&quot;惠农网面粉价格Top10发货地&quot;</span>,<br>            y,<br>            bar_width=<span class="hljs-number">46</span>,<br>            itemstyle_opts=opts.ItemStyleOpts(<br>                <span class="hljs-comment"># 设置渐变颜色</span><br>                color=JsCode(<br>                    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">                    new echarts.graphic.LinearGradient(0, 0, 0, 1, [</span><br><span class="hljs-string">                        &#123; offset: 0, color: &#x27;#6197EE&#x27; &#125;,</span><br><span class="hljs-string">                        &#123; offset: 1, color: &#x27;#B7BFE8&#x27; &#125;</span><br><span class="hljs-string">                    ])</span><br><span class="hljs-string">                    &quot;&quot;&quot;</span><br>                ),<br>                <span class="hljs-comment"># 设置柱状图边框圆角</span><br>                border_radius=[<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>            ),<br>        )<br>        <span class="hljs-comment"># 添加次级 y 轴的设置</span><br>        .extend_axis(<br>            yaxis=opts.AxisOpts(<br>                axislabel_opts=opts.LabelOpts(formatter=<span class="hljs-string">&quot;&#123;value&#125;&quot;</span>), interval=<span class="hljs-number">15</span><br>            )<br>        )<br>        <span class="hljs-comment"># 设置柱状图上数据标签样式</span><br>        .set_series_opts(label_opts=opts.LabelOpts(is_show=<span class="hljs-literal">True</span>, font_size=<span class="hljs-number">18</span>, color=<span class="hljs-string">&#x27;black&#x27;</span>))<br>        <span class="hljs-comment"># 设置全局选项</span><br>        .set_global_opts(<br>            <span class="hljs-comment"># 设置标题</span><br>            title_opts=opts.TitleOpts(title=title),<br>            <span class="hljs-comment"># 设置左侧 y 轴选项</span><br>            yaxis_opts=opts.AxisOpts(<br>                axislabel_opts=opts.LabelOpts(formatter=<span class="hljs-string">&quot;&#123;value&#125;&quot;</span>, font_size=<span class="hljs-number">15</span>)<br>            ),<br>            <span class="hljs-comment"># 设置 x 轴选项</span><br>            xaxis_opts=opts.AxisOpts(<br>                axislabel_opts=opts.LabelOpts(<br>                    is_show=<span class="hljs-literal">True</span>, position=<span class="hljs-string">&quot;top&quot;</span>, color=<span class="hljs-string">&quot;black&quot;</span>, rotate=<span class="hljs-number">0</span>, interval=<span class="hljs-number">0</span>, font_size=<span class="hljs-number">15</span><br>                )<br>            ),<br>        )<br>    )<br>    <span class="hljs-keyword">return</span> bar<br><span class="hljs-comment"># 渲染柱状图，并将其保存为一个 HTML 文件</span><br>overlap_bar_line(x, y, <span class="hljs-string">&quot;&quot;</span>).render(<span class="hljs-string">&quot;C:/Users/LENOVO/Desktop/数据采集课程设计/bar_chart5.html&quot;</span>)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python实训&quot;&gt;&lt;a href=&quot;#python实训&quot; class=&quot;headerlink&quot; title=&quot;python实训&quot;&gt;&lt;/a&gt;python实训&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;一、项目目的与意义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、项目</summary>
      
    
    
    
    <category term="数据采集集训" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E9%9B%86%E8%AE%AD/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>java总结</title>
    <link href="http://example.com/2024/01/30/java%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2024/01/30/java%E6%80%BB%E7%BB%93/</id>
    <published>2024-01-30T07:30:22.000Z</published>
    <updated>2024-02-01T13:52:21.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-考试总结"><a href="#1-考试总结" class="headerlink" title="1.考试总结"></a>1.考试总结</h1><h2 id="1-1-变量的命名"><a href="#1-1-变量的命名" class="headerlink" title="1.1 变量的命名"></a>1.1 变量的命名</h2><p>必须以字母,下划线或$字符开头,不能以数字开头</p><p>英文字母大小写敏感,长度不限</p><p>不能含有java的关键字</p><p>不能含有空格</p><p>类名字母第一个大写</p><p>用做变量的标识符第二个单词的首个字母大写</p><p>常量的标识符全大写</p><h2 id="1-2-面向对象"><a href="#1-2-面向对象" class="headerlink" title="1.2 面向对象"></a>1.2 面向对象</h2><p>面向对象是一种符合人类思维习惯的编程思想。现实生活中存在各种形态不同的事物，这些事物之间存在着各种各样的联系。<br>在程序中使用对象来映射现实中的事物，使用对象的关系来描述事物之间的联系，这种思想就是面向对象。<br>面向过程就是分析解决问题所需要的步骤，面向对象则是把解决的问题按照一定规则划分为多个独立的对象，然后通过调用对象的方法来解决问题。</p><p>面向对象的特点主要可以概括为封装性、继承性和多态性。</p><h2 id="1-3-类的定义"><a href="#1-3-类的定义" class="headerlink" title="1.3 类的定义"></a>1.3 类的定义</h2><p>类是对某一类事物的抽象描述，而对象用于表示现实中该类事物的个体</p><h2 id="1-4-类与对象的关系"><a href="#1-4-类与对象的关系" class="headerlink" title="1.4 类与对象的关系"></a>1.4 类与对象的关系</h2><p>类是对象的类型,对象是类的事例</p><h2 id="1-5-封装"><a href="#1-5-封装" class="headerlink" title="1.5 封装"></a>1.5 封装</h2><p><strong>所谓类的封装是指在定义一个类时，将类中的属性私有化，即使用private关键字来修饰，私有属性只能在它所在类中被访问</strong>，为了能让外界访问私有属性，需要提供一些使用public修饰的公有方法，其中包括用于获取属性值的getXxx方法和设置属性值的setXxx方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-6-一般方法"><a href="#1-6-一般方法" class="headerlink" title="1.6 一般方法"></a>1.6 一般方法</h2><p>一般方法是用于执行各种任务的普通方法</p><h2 id="1-7-构造方法"><a href="#1-7-构造方法" class="headerlink" title="1.7 构造方法"></a>1.7 构造方法</h2><p>在Java中，构造方法是一种特殊类型的方法，它用作进行对象实例化,一般用于给成员变量赋初值</p><p>在一个类中定义的方法如果同时满足以下三个条件，该方法称为构造方法，具体如下：<br>方法名和类名相同<br>方法名的前面没有返回值类型的声明<br>方法中不能使用return语句返回一个值</p><p>与普通方法一样，构造方法也可以重载，在一个类中可以定义多个构造方法，只要每个构造方法的参数类型或参数个数不同即可</p><p>在Java中的每个类都至少有一个构造方法，如果在一个类中没有定义构造方法，系统会自动为这个类创建一个默认的构造方法，这个默认的构造方法没有参数，在其方法体中没有任何代码，即什么也不做。如果为该类定义了构造方法，系统就不再提供默认的构造方法了</p><p>通过this关键字可以明确地去访问一个类的成员变量，解决与局部变量名称冲突问题</p><p>构造方法是在实例化对象时被Java虚拟机自动调用的，在程序中不能像调用其它方法一样去调用构造方法，但可以在一个构造方法中使用“this([参数1,参数2…])”的形式来调用其它的构造方法通过this关键字调用成员方法<br>1、只能在构造方法中使用this调用其它的构造方法<br>2、在构造方法中，使用this调用构造方法的语句必须位于第一行，且只能出现一次，下面的写法是非法的。<br>3、不能在一个类的两个构造方法中使用this互相调用</p><p>类的构造方法使用private修饰，声明为私有，这样就不能在类的外部使用new关键字来创建实例对象了。<br>在类的内部创建一个该类的实例对象，并使用静态变量INSTANCE引用该对象，由于变量应该禁止外界直接访问，因此使用private修饰，声明为私有成员<br>为了让类的外部能够获得类的实例对象，需要定义一个静态方法getInstance()，用于返回该类实例INSTANCE。由于方法是静态的，外界可以通过“类名.方法名”的方式来访问</p><h2 id="1-8-重载与重写（覆盖）"><a href="#1-8-重载与重写（覆盖）" class="headerlink" title="1.8 重载与重写（覆盖）"></a>1.8 重载与重写（覆盖）</h2><p>重载是方法名完全一样,采用不同的形参个数,或者不同的形参类型实现同一个方法具备不同的功能</p><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变</p><p><strong>重载规则:</strong> </p><p>被重载的方法必须改变参数列表(参数个数或类型不一样)；</p><p>被重载的方法可以改变返回类型；</p><p>被重载的方法可以改变访问修饰符；</p><p>被重载的方法可以声明新的或更广的检查异常；</p><p>方法能够在同一个类中或者在一个子类中被重载。</p><p>无法以返回值类型作为重载函数的区分标准。</p><p><strong>方法的重写规则</strong>:</p><p>参数列表与被重写方法的参数列表必须完全相同。</p><p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p><p>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</p><p>父类的成员方法只能被它的子类重写。</p><p>声明为 final 的方法不能被重写。</p><p>声明为 static 的方法不能被重写，但是能够被再次声明。</p><p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</p><p>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</p><p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</p><p>构造方法不能被重写。</p><p>如果不能继承一个类，则不能重写该类的方法。</p><h2 id="1-9-垃圾回收"><a href="#1-9-垃圾回收" class="headerlink" title="1.9 垃圾回收"></a>1.9 垃圾回收</h2><p>java的垃圾回收机制是一种自动管理内存的机制，它可以自动检测和回收不再使用的对象，以释放内存空间</p><h2 id="1-10-静态变量"><a href="#1-10-静态变量" class="headerlink" title="1.10 静态变量"></a>1.10 静态变量</h2><p>在一个Java类中，可以使用static关键字来修饰成员变量，该变量被称作静态变量<br>静态变量被所有实例共享，可以使用“类名.变量名”的形式来访问<br>static关键字只能用于修饰成员变量，不能用于修饰局部变量，否则编译会报错，下面的代码是非法的。</p><h2 id="1-11静态代码块"><a href="#1-11静态代码块" class="headerlink" title="1.11静态代码块"></a>1.11静态代码块</h2><p>在Java类中，使用一对大括号包围起来的若干行代码被称为一个代码块，用static关键字修饰的代码块称为静态代码块<br>当类被加载时，静态代码块会执行，由于类只加载一次，因此静态代码块只执行一次<br>在程序中，通常使用静态代码块来对类的成员变量进行初始化</p><h2 id="1-12-设计模式"><a href="#1-12-设计模式" class="headerlink" title="1.12 设计模式"></a>1.12 设计模式</h2><p>设计模式就是针对这些问题和需求，在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式<br>单例模式是Java中的一种设计模式，它是指在设计一个类时，需要保证在整个程序运行期间针对该类只存在一个实例对象<br>看一个实现了单例模式的类</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类（包括成员内部类、局部内部类和匿名内部类）具有对外部类实例的隐式引用，因此可以访问外部类的成员，就好像这些成员是内部类自己的成员一样。</p><h2 id="1-13-成员内部类"><a href="#1-13-成员内部类" class="headerlink" title="1.13 成员内部类"></a>1.13 成员内部类</h2><p>在一个类中除了可以定义成员变量、成员方法，还可以定义类，这样的类被称作成员内部类。<br>内部类可以在外部类中被使用，并能访问外部类的成员<br>如果想通过外部类去访问内部类，则需要通过外部类对象去创建内部类对象，创建内部类对象的具体语法格式如下：<br>外部类名.内部类名 变量名 &#x3D;new 外部类名().new 内部类名();</p><h2 id="1-14-静态内部类"><a href="#1-14-静态内部类" class="headerlink" title="1.14 静态内部类"></a>1.14 静态内部类</h2><p>可以使用static关键字来修饰一个成员内部类，该内部类被称作静态内部类，它可以在不创建外部类对象的情况下被实例化。创建静态内部类对象的具体语法格式如下：<br>外部类名.内部类名 变量名 &#x3D; new 外部类名.内部类名();</p><h2 id="1-15-方法内部类"><a href="#1-15-方法内部类" class="headerlink" title="1.15 方法内部类"></a>1.15 方法内部类</h2><p>方法内部类是指在成员方法中定义的类，它只能在当前方法中被使用。方法内部类，因此程序只能在方法中创建该类的实例对象并调用show()方法,方法内部类也可以访问外部类的成员变量</p><h2 id="1-16-匿名内部类"><a href="#1-16-匿名内部类" class="headerlink" title="1.16 匿名内部类"></a>1.16 匿名内部类</h2><p>匿名内部类是存在于某个类中且没有名称的类,可以匿名内部类于接口(或者抽象类)配合使用,在实例化时,直接采用匿名内部类</p><h2 id="1-17-继承"><a href="#1-17-继承" class="headerlink" title="1.17 继承"></a>1.17 继承</h2><p>程序中，继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系。<br>在Java中，<strong>类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承的属性和方法</strong>。在程序中，如果想声明一个类继承另一个类，需要使用extends关键字，接下来通过一个案例来学习子类是如何继承父类的。</p><p>在类的继承中，需要注意一些问题，具体如下：<br>1、在Java中，类只支持单继承，不允许多重继承，也就是说一个类只能有一个直接父类，例如下面这种情况是不合法的。<br>2、多个类可以继承一个父类，例如下面这种情况是允许的。<br>3、在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类，例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类。下面这种情况是允许的。</p><p>4、继承后的方法其访问权限范围不能缩小（可以扩大或者保持）</p><p>在继承关系中，子类会自动继承父类中定义的方法，但有时在子类中需要对继承的方法进行一些修改，即对父类的方法进行重写。需要注意的是，在子类中重写的方法需要和父类被重写的方法具有相同的方法名、参数列表以及返回值类型。</p><h3 id="1-17-1-super关键字"><a href="#1-17-1-super关键字" class="headerlink" title="1.17.1  super关键字"></a>1.17.1  super关键字</h3><p>当子类重写父类的方法后，子类对象将无法访问父类被重写的方法，为了解决这个问题，在Java中专门提供了一个super关键字用于访问父类的成员。例如访问父类的成员变量、成员方法和构造方法。接下来分两种情况来学习一下super关键字的具体用法。<br>1、使用super关键字调用父类的成员变量和成员方法。<br>2、使用super关键字调用父类的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getSalary</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> salary;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSalary</span><span class="hljs-params">(<span class="hljs-type">double</span> salary)</span> &#123;<br>        <span class="hljs-built_in">this</span>.salary = salary;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-18-final关键字"><a href="#1-18-final关键字" class="headerlink" title="1.18 final关键字"></a>1.18 final关键字</h2><p>final关键字可用于修饰类、变量和方法，它有“这是无法改变的”或者“最终”的含义，因此被final修饰的类、变量和方法将具有以下特性：<br>1、final修饰的类不能被继承。<br>2、final修饰的方法不能被子类重写。<br>3、final修饰的变量（成员变量和局部变量）是常量，只能赋值一次。</p><p>Java中的类被final关键字修饰后，该类将不可以被继承，也就是不能够派生子类,当一个类的方法被final关键字修饰后，这个类的子类将不能重写该方法</p><h2 id="1-19-抽象方法"><a href="#1-19-抽象方法" class="headerlink" title="1.19 抽象方法"></a>1.19 抽象方法</h2><p>Java允许在定义方法时不写方法体，不包含方法体的方法为抽象方法，抽象方法必须使用abstract关键字来修饰</p><h2 id="1-20-抽象类"><a href="#1-20-抽象类" class="headerlink" title="1.20 抽象类"></a>1.20 抽象类</h2><p>含有抽象方法的类,叫做抽象类，该类必须使用abstract关键字来修饰，在定义抽象类时需要注意，包含抽象方法的类必须声明为抽象类，但抽象类可以不包含任何抽象方法，只需使用abstract关键字来修饰即可。另外，抽象类是不可以被实例化的，因为抽象类中有可能包含抽象方法，抽象方法是没有方法体的，不可以被调用。如果想调用抽象类中定义的方法，则需要创建一个子类，在子类中将抽象类中的抽象方法进行实现。</p><p>抽象类不能直接实例化对象,一般有子类实现父类中的所有抽象方法,然后才能实例化对象</p><p>抽象类的子类如果没有完全实现抽象父类的所有抽象方法,则也要声明为abstract也不能实例化对象</p><p>抽象类的非抽象子类必须重写父类中的abstract方法</p><h2 id="1-21-包装类"><a href="#1-21-包装类" class="headerlink" title="1.21 包装类"></a>1.21 包装类</h2><p>包装类(Packaging class)：Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的。基本型的数据不具备”对象”的特性（没有成员变量和成员方法可以调用），因此，java为每种数据类型分别设计了对应的类，即包装类。</p><h2 id="1-22-接口"><a href="#1-22-接口" class="headerlink" title="1.22 接口"></a>1.22 接口</h2><p>如果一个抽象类中的所有方法都是抽象的，则可以将这个类用另外一种方式来定义，即接口。在定义接口时，需要使用interface关键字来声明,接口中定义的方法和变量都包含一些默认修饰符。接口中定义的方法默认使用“public abstract”来修饰，即抽象方法。接口中的变量默认使用“public static final”来修饰，即全局常量。</p><p>由于接口中的方法都是抽象方法，因此不能通过实例化对象的方式来调用接口中的方法。此时需要定义一个类，并使用implements关键字实现接口中所有的方法。在程序中，还可以定义一个接口使用extends关键字去继承另一个接口</p><p>为了加深初学者对接口的认识，接下来对接口的特点进行归纳，具体如下：<br>1、接口中的方法都是抽象的，不能实例化对象。<br>2、当一个类实现接口时，如果这个类是抽象类，则实现接口中的部分方法即可，否则需要实现接口中的所有方法。<br>3、一个类通过implements关键字实现接口时，可以实现多个接口，被实现的多个接口之间要用逗号隔开。<br>4、一个接口可以通过extends关键字继承多个接口，接口之间用逗号隔开。<br>5、一个类在继承另一个类的同时还可以实现接口，此时，extends关键字必须位于implements关键字前</p><h2 id="1-23-一般类-抽象类-接口区别"><a href="#1-23-一般类-抽象类-接口区别" class="headerlink" title="1.23 一般类,抽象类,接口区别"></a>1.23 一般类,抽象类,接口区别</h2><p>java中有三种不同类型的类：一般类、抽象类和接口。它们之间有以下区别：</p><ol><li>一般类是普通的类，它们可以有字段、方法和构造函数等。一般类的实例可以直接创建，并且可以被其他类继承。</li><li>抽象类是不能被实例化的类，它们只能被继承。抽象类可以有字段、方法和构造函数等，但方法可以是抽象的，这意味着它们没有实现，需要由子类实现。抽象类通常用于作为其他类的基类，它们定义了一些通用的属性和方法，并强制要求子类实现它们。</li><li>接口是一种特殊的抽象类，它们没有字段，并且所有的方法都是抽象的。接口只定义了方法的名称、返回类型和参数，而没有提供实现。接口通常用于定义类之间的协议，它们强制要求实现它们的类提供指定的方法。</li></ol><h2 id="1-24-多态"><a href="#1-24-多态" class="headerlink" title="1.24 多态"></a>1.24 多态</h2><p>在设计一个方法时，通常希望该方法具备一定的通用性。<strong>多态性是指调用同一方法实现不同的行为特征的技术</strong><br>在Java中为了实现多态，允许使用一个父类类型的变量来引用一个子类类型的对象，根据被引用子类对象特征的不同，得到不同的运行结果，将子类对象当做父类使用时不需要任何显式地声明，需要注意的是，此时不能通过父类变量去调用子类中某些方法,需要类型转换,需要注意的是，在进行类型转换时也可能出现错误。</p><h3 id="1-24-1-instanceof"><a href="#1-24-1-instanceof" class="headerlink" title="1.24.1 instanceof"></a>1.24.1 instanceof</h3><p>针对这种情况，Java提供了一个关键字instanceof，它可以判断一个对象是否为某个类(或接口)的实例或者子类实例,具体代码如下:<br>对象(或者对象引用变量) instanceof  类(或接口)</p><p>在java中多态性可以通过方法的重载和重写来实现 ,代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal is making a sound&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Woof!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Meow!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><br>        animal1.makeSound();<br>        animal2.makeSound();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-25-object类"><a href="#1-25-object类" class="headerlink" title="1.25 object类"></a>1.25 object类</h2><p>在JDK中提供了一个Object类，它是所有类的父类，即每个类都直接或间接继承自该类,Animal默认继承自Object类，在Object类中定义了toString()方法</p><h2 id="1-26-匿名内部类"><a href="#1-26-匿名内部类" class="headerlink" title="1.26 匿名内部类"></a>1.26 匿名内部类</h2><p>前面多态的讲解中，如果方法的参数被定义为一个接口类型，那么就需要定义一个类来实现接口，并根据该类进行对象实例化。除此之外，还可以使用匿名内部类来实现接口。<br>匿名内部类格式:<br>new 父类(参数列表) 或父接口(){<br>    &#x2F;&#x2F;匿名内部类实现部分<br>}</p><p>调用者和被调用者必须共同遵守某一限定，调用者按照这个限定进行方法调用，被调用者按照这个限定进行方法实现”的应用情况，在面向对象的编程语言中，这种限定就是通过接口类来表示的</p><p>在写匿名内部类的大括号后,一定要跟着一个语句;</p><h2 id="1-27-异常"><a href="#1-27-异常" class="headerlink" title="1.27 异常"></a>1.27 异常</h2><p>简要讲一下如何理解Java中的异常处理机制</p><p>在Java中，异常处理机制是一种处理程序运行时出现异常情况的机制。当程序执行过程中发生异常时，异常处理机制可以捕捉和处理异常，以避免程序崩溃或出现未预期的结果</p><p>在程序运行的过程中，也会发生这种非正常状况，比如程序运行时磁盘空间不足，网络连接中断，被装载的类不存在。针对这种情况，在Java语言中，引入了异常，以异常类的形式对这些非正常情况进行封装，通过异常处理机制对程序运行时发生的各种问题进行处理。</p><p>Throwable有两个直接子类Error和Exception，其中Error代表程序中产生的错误，Exception代表程序中产生的异常。接下来就对这两个直接子类进行详细讲解。<br>Error类称为错误类，它表示Java运行时产生的系统内部错误或资源耗尽的错误，是比较严重的，仅靠修改程序本身是不能恢复执行的。举一个生活中的例子，在盖楼的过程中因偷工减料，导致大楼坍塌，这就相当于一个Error。使用java命令去运行一个不存在的类就会出现Error错误</p><p>Exception类称为异常类，它表示程序本身可以处理的错误，在开发Java程序中进行的异常处理，都是针对Excption类及其子类。在Exception类的众多子类中有一个特殊的RuntimeException类，该类及其子类用于表示运行时异常，除了此类，Exception类下所有其它的子类都用于表示编译时异常<br>由于发生了异常，程序立即终止，无法继续向下执行。为了解决这样的问题，Java中提供了一种对异常进行处理的方式——异常捕获 try …catch finally<br>在程序中，有时候我们希望有些语句无论程序是否发生异常都要执行，这时就可以在try…catch语句后，加一个finally代码块。需要注意的是，finally中的代码块有一种情况下是不会执行的，那就是在try…catch中执行了System.exit(0)语句。System.exit(0)表示退出当前的Java虚拟机，Java虚拟机停止了，任何代码都不能再执行了。</p><h2 id="1-28-throws关键字"><a href="#1-28-throws关键字" class="headerlink" title="1.28 throws关键字"></a>1.28 throws关键字</h2><p>在前面学习的例程4-23中，由于调用的是自己写的divide()方法，因此很清楚该方法可能会发生异常。试想一下，如果去调用一个别人写的方法时，是否能知道别人写的方法是否会有异常呢？这是很难做出判断的。针对这种情况，<strong>Java中允许在方法的后面使用throws关键字对外声明该方法有可能发生的异常，这样调用者在调用方法时，就明确地知道该方法有异常，并且必须在程序中对异常进行处理，否则编译无法通过。</strong><br>throws关键字声明抛出异常的语法格式如下：<br>修饰符 返回值类型 方法名 [参数1,参数2….]throws ExceptionType1[,ExceptionType2….]{</p><h2 id="1-29-运行时异常与编译时异常"><a href="#1-29-运行时异常与编译时异常" class="headerlink" title="1.29 运行时异常与编译时异常"></a>1.29 运行时异常与编译时异常</h2><p>在实际开发中，经常会在程序编译时期产生一些异常，而这些异常必须要进行处理，这种异常被称为编译时期异常，也称为checked异常。另外还有一种异常是在程序运行时期产生的，这种异常即使不编写异常处理代码，依然可以通过编译，因此我们称之为运行时异常，也称为unchecked异常。</p><p>运行时异常与编译时异常<br>1、编译时异常<br>在Java中，Exception类中除了RuntimeException类及其的子类都是编译时异常。编译时异常的特点是Java编译器会对其进行检查，如果出现异常就必须对异常进行处理，否则程序无法通过编译。<br>处理编译时期的异常有两种方式，具体如下：<br>使用try…catch语句对异常进行捕获<br>使用throws关键字声明抛出异常，调用者对其处理。</p><p>2、运行时异常<br>RuntimeException类及其子类都是运行时异常。运行时异常的特点是Java编译器不会对其进行检查，也就是说，当程序中出现这类异常时，即使没有使用try..catch语句捕获或使用throws关键字声明抛出，程序也能编译通过。运行时异常一般是由于程序中的逻辑错误引起的，在程序运行时无法恢复。比如通过数组的角标访问数组的元素时，如果超过了数组的最大角标，就会发生运行时异常，</p><h2 id="1-30-自定义异常"><a href="#1-30-自定义异常" class="headerlink" title="1.30 自定义异常"></a>1.30 自定义异常</h2><p>JDK中定义了大量的异常类，虽然这些异常类可以描述编程时出现的大部分异常情况，但是在程序开发中有时可能需要描述程序中特有的异常情况，例如在设计divide()方法时不允许被除数为负数。为了解决这个问题，在Java中允许用户自定义异常，但自定义的异常类必须继承自Exception或其子类<br>在实际开发中，如果没有特殊的要求，自定义的异常类只需继承Exception类，在构造方法中使用super()语句调用Exception的构造方法即可。<br>既然自定义了异常，那么该如何使用呢？这时就需要用到throw关键字，throw关键字用于在方法中声明抛出异常的实例对象，其语法格式如下：<br>throw Exception 异常对象<br>在一个方法内使用throw关键字抛出异常对象时，需要使用try…catch语句对抛出的异常进行处理，或者在divide()方法上使用throws关键字声明抛出异常，由该方法的调用者负责处理。</p><h2 id="1-31-包"><a href="#1-31-包" class="headerlink" title="1.31 包"></a>1.31 包</h2><p>为了便于对硬盘上的文件进行管理，通常都会将文件分目录进行存放。同理，在程序开发中，也需要将编写的类分目录存放便于管理，为此，Java引入了包(package)机制，程序可以通过声明包的方式对Java类定义目录。Java中的包是专门用来存放类的，通常功能相同的类存放在相同的包中。在声明包时，使用package语句，需要注意的是，包的声明只能位于Java源文件的第一行。</p><h2 id="1-32-断言"><a href="#1-32-断言" class="headerlink" title="1.32 断言"></a>1.32 断言</h2><p>断言语句主要用于程序调试阶段,通过设置断言语句,我们可以快速找到错误的语句,语句块,或者错误的方法体,在 Java 中，断言使用 assert 关键字来定义，其语法格式如下：assert expression1;assert expression2 : expression3;其中，expression1 是一个布尔表达式，如果它为 true，则程序继续执行；如果为 false，则程序抛出 AssertionError 异常。expression2 是一个布尔表达式，如果它为 false，则抛出 AssertionError 异常，并将 expression3 的值作为异常信息输出。</p><h2 id="1-33-import语句"><a href="#1-33-import语句" class="headerlink" title="1.33 import语句"></a>1.33 import语句</h2><p><strong>在程序开发中，位于不同包中的类经常需要互相调用,Java中提供了import关键字，使用import可以在程序中一次导入某个指定包下的类</strong></p><p>import语句<br>在JDK中，不同功能的类都放在不同的包中，其中Java的核心类主要放在java这个包以及其子包下，Java扩展的大部分类都放在javax包以及其子包下。为了便于后面的学习，接下来简单介绍Java语言中的常用包。<br>java.lang:包含Java语言的核心类，如String、Math、System和Thread类等，使用这个包中的类无须使用import语句导入，系统会自动导入这个包下的所有类。<br>java.util:包含Java中大量工具类、集合类等，例如Arrays、List、Set等。<br>java.net:包含Java网络编程相关的类和接口。<br>java.io:包含了Java输入、输出有关的类和接口。<br>java.awt:包含用于构建图形界面(GUI)的相关类和接口。</p><p>给Java应用打包<br>给Java应用打包有很多好处，接下来简单介绍一下打包jar文件的好处，如下所示：<br>安全：可以对jar文件进行数字签名，让能够识别数字签名的用户使用。<br>节省空间：当把.class文件打成jar压缩文件，会节省空间，如果将jar文件在网络上传输，也会加快传输速率。<br>可移植性：只要有Java虚拟机，jar包就可以在任何平台上运行。</p><h2 id="1-34-访问权限符"><a href="#1-34-访问权限符" class="headerlink" title="1.34 访问权限符"></a>1.34 访问权限符</h2><p>private(类访问级别) ：如果类的成员被private访问控制符来修饰，则这个成员只能被该类的其它成员访问，其它类无法直接访问。实现类的良好封装。<br>default(包访问级别) ：如果一个类或者类的成员不使用任何访问控制符修饰，则称它为默认访问控制级别，这个类或者类的成员只能被本包中的其它类访问。<br>protected(子类访问级别) ：如果一个类的成员被protected访问控制符修饰，那么这个成员既能被同一包下的其它类访问，也能被不同包下该类的子类访问。<br>public(公共访问级别) ：这是一个最宽松的访问控制级别，如果一个类或者类的成员被public访问控制符修饰，那么这个类或者类的成员能被所有的类访问，不管访问类与被访问类是否在同一个包中。</p><h2 id="1-35-进程与线程"><a href="#1-35-进程与线程" class="headerlink" title="1.35 进程与线程"></a>1.35 进程与线程</h2><p>•<strong>进程</strong></p><p>​    在一个操作系统中，每个独立执行的程序都可称之为一个进程，也就是“正在运行的程序”</p><p>•<strong>线程</strong></p><p>​     每个运行的程序都是一个进程，在一个进程中还可以有多个执行单元同时运行，这些执行单元可以看做程序执行的一条条线索，被称为线程。</p><h2 id="1-36-如何实现多线程"><a href="#1-36-如何实现多线程" class="headerlink" title="1.36 如何实现多线程"></a>1.36 如何实现多线程</h2><p>继承Thread类创建多线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程执行的任务</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>thread.start(); <span class="hljs-comment">// 启动线程</span><br></code></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/65b8fb9a871b83018a66354c.png"></p><p>通过继承Thread类实现了多线程，但是这种方式有一定的局限性。因为Java中只支持单继承，一个类一旦继承了某个父类就无法再继承Thread类</p><p>实现Runnable接口创建多线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程执行的任务</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>thread.start(); <span class="hljs-comment">// 启动线程</span><br></code></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/65b8fb9a871b83018a663654.png"></p><p>实现Runnable接口相对于继承Thread类来说，有如下显著好处：<br>1、适合多个相同程序代码的线程去处理同一个资源的情况，把线程同程序代码、数据有效的分离，很好的体现了面向对象的设计思想。<br>2、可以避免由于Java的单继承带来的局限性。在开发中经常碰到这样一种情况，就是使用一个已经继承了某一个类的子类创建线程，由于一个类不能同时有两个父类，所以不能用继承Thread类的方式，那么就只能采用实现Runnable接口的方式。</p><p>后台线程<br>对Java程序来说，只要还有一个前台线程在运行，这个进程就不会结束，如果一个进程中只有后台线程运行，这个进程就会结束。这里提到的前台线程和后台线程是一种相对的概念，新创建的线程默认都是前台线程，如果某个线程对象在启动之前调用了setDaemon(true)语句，这个线程就变成一个后台线程。</p><h2 id="1-37-线程生命周期"><a href="#1-37-线程生命周期" class="headerlink" title="1.37 线程生命周期"></a>1.37 线程生命周期</h2><p>线程整个生命周期可以分为五个阶段，分别是新建状态(New)、就绪状态(Runnable)、运行状态(Running)、阻塞状态(Blocked)和死亡状态(Terminated)，线程的不同状态表明了线程当前正在进行的活动。</p><p>1、新建状态(New) 创建一个线程对象后，该线程对象就处于新建状态，此时它不能运行，和其它Java对象一样，仅仅由Java虚拟机为其分配了内存，没有表现出任何线程的动态特征。<br>2、就绪状态(Runnable) 当线程对象调用了start()方法后，该线程就进入就绪状态（也称可运行状态）。处于就绪状态的线程位于可运行池中，此时它只是具备了运行的条件，能否获得CPU的使用权开始运行，还需要等待系统的调度。<br>3、运行状态(Running) 如果处于就绪状态的线程获得了CPU的使用权，开始执行run()方法中的线程执行体，则该线程处于运行状态。当一个线程启动后，它不可能一直处于运行状态(除非它的线程执行体足够短，瞬间就结束了)，当使用完系统分配的时间后，系统就会剥夺该线程占用的CPU资源，让其它线程获得执行的机会。需要注意的是，只有处于就绪状态的线程才可能转换到运行状态。<br>4、阻塞状态(Blocked) 一个正在执行的线程在某些特殊情况下，如执行耗时的输入&#x2F;输出操作时，会放弃CPU的使用权，进入阻塞状态。线程进入阻塞状态后，就不能进入排队队列。只有当引起阻塞的原因被消除后，线程才可以转入就绪状态。<br>当线程试图获取某个对象的同步锁时，如果该锁被其它线程所持有，则当前线程会进入阻塞状态，如果想从阻塞状态进入就绪状态必须得获取到其它线程所持有的锁。<br>当线程调用了一个阻塞式的IO方法时，该线程就会进入阻塞状态，如果想进入就绪状态就必须要等到这个阻塞的IO方法返回。<br>当线程调用了某个对象的wait()方法时，也会使线程进入阻塞状态，如果想进入就绪状态就需要使用notify()方法唤醒该线程。<br>当线程调用了Thread的sleep(long millis)方法时，也会使线程进入阻塞状态，在这种情况下，只需等到线程睡眠的时间到了以后，线程就会自动进入就绪状态。<br>当在一个线程中调用了另一个线程的join()方法时，会使当前线程进入阻塞状态，在这种情况下，需要等到新加入的线程运行结束后才会结束阻塞状态，进入就绪状态。<br>5、死亡状态(Terminated) 线程的run()方法正常执行完毕或者线程抛出一个未捕获的异常(Exception)、错误(Error)，线程就进入死亡状态。一旦进入死亡状态，线程将不再拥有运行的资格，也不能再转换到其它状态。</p><h2 id="1-38-线程的优先级"><a href="#1-38-线程的优先级" class="headerlink" title="1.38 线程的优先级"></a>1.38 线程的优先级</h2><p>优先级越高的线程获得CPU执行的机会越大，而优先级越低的线程获得CPU执行的机会越小。<br>线程的优先级用1<del>10之间的整数来表示，数字越大优先级越高。<br>除了可以直接使用数字表示线程的优先级，还可以使用Thread类中提供的三个静态常量表示线程的优先级<br>程序在运行期间，处于就绪状态的每个线程都有自己的优先级，例如main线程具有普通优先级。然而线程优先级不是固定不变的，可以通过Thread类的setPriority(int newPriority)方法对其进行设置，该方法中的参数newPriority接收的是1</del>10之间的整数或者Thread类的三个静态常量。</p><h2 id="1-39-线程休眠"><a href="#1-39-线程休眠" class="headerlink" title="1.39 线程休眠"></a>1.39 线程休眠</h2><p>如果希望人为地控制线程，使正在执行的线程暂停，将CPU让给别的线程，这时可以使用静态方法sleep(long millis)，该方法可以让当前正在执行的线程暂停一段时间，进入休眠等待状态。<br>当前线程调用sleep(long millis)方法后，在指定时间(参数millis)内该线程是不会执行的，这样其它的线程就可以得到执行的机会。</p><h2 id="1-40-线程让步"><a href="#1-40-线程让步" class="headerlink" title="1.40 线程让步"></a>1.40 线程让步</h2><p>在校园中，我们经常会看到同学互相抢篮球，当某个同学抢到篮球后就可以拍一会，之后他会把篮球让出来，大家重新开始抢篮球，这个过程就相当于Java程序中的线程让步。<br>线程让步可以通过yield()方法来实现，该方法和sleep()方法有点相似，都可以让当前正在运行的线程暂停，区别在于yield()方法不会阻塞该线程，它只是将线程转换成就绪状态，让系统的调度器重新调度一次。当某个线程调用yield()方法之后，只有与当前线程优先级相同或者更高的线程才能获得执行的机会。</p><h2 id="1-41-线程插队"><a href="#1-41-线程插队" class="headerlink" title="1.41 线程插队"></a>1.41 线程插队</h2><p>现实生活中经常能碰到“插队”的情况，同样，在Thread类中也提供了一个join()方法来实现这个“功能”。<br>当在某个线程中调用其它线程的join()方法时，调用的线程将被阻塞，直到被join()方法加入的线程执行完成后它才会继续运行。</p><h2 id="1-42-同步代码块"><a href="#1-42-同步代码块" class="headerlink" title="1.42 同步代码块"></a>1.42 同步代码块</h2><p>要解决线程安全问题，必须得保证下面用于处理共享资源的代码在任何时刻只能有一个线程访问。<br>为了实现这种限制，Java中提供了同步机制。当多个线程使用同一个共享资源时，可以将处理共享资源的代码放置在一个代码块中，使用synchronized关键字来修饰，被称作同步代码块，其语法格式如下<br>synchronized(lock){<br>    操作共享资源代码快<br>}<br>lock是一个锁对象，它是同步代码块的关键。当线程执行同步代码块时，首先会检查锁对象的标志位，默认情况下标志位为1，此时线程会执行同步代码块，同时将锁对象的标志位置为0。当一个新的线程执行到这段同步代码块时，由于锁对象的标志位为0，新线程会发生阻塞，等待当前线程执行完同步代码块后，锁对象的标志位被置为1，新线程才能进入同步代码块执行其中的代码。循环往复，直到共享资源被处理完为止。</p><h2 id="1-43-同步方法"><a href="#1-43-同步方法" class="headerlink" title="1.43 同步方法"></a>1.43 同步方法</h2><p>同步代码块可以有效解决线程的安全问题，当把共享资源的操作放在synchronized定义的区域内时，便为这些操作加了同步锁。<br>在方法前面同样可以使用synchronized关键字来修饰，被修饰的方法为同步方法，它能实现和同步代码块同样的功能，具体语法格式如下：<br>synchronized 返回值类型 方法名[参数1,….]{}<br>被synchronized修饰的方法在某一时刻只允许一个线程访问，访问该方法的其它线程都会发生阻塞，直到当前线程访问完毕后，其它线程才有机会执行方法。</p><h2 id="1-44-死锁"><a href="#1-44-死锁" class="headerlink" title="1.44 死锁"></a>1.44 死锁</h2><p>两个线程在运行时都在等待对方的锁，这样便造成了程序的停滞，这种现象称为死锁</p><p>问题引出<br>假设有两个线程同时去操作同一个存储空间，其中一个线程负责向存储空间中存入数据，另一个线程负责则取出数据。<br>问题如何解决<br>如果想解决上述问题，需要控制多个线程按照一定的顺序轮流执行，此时需要让线程间进行通信。在Object类中提供了wait()、notify()、notifyAll()方法用于解决线程间的通信问题，由于Java中所有类都是Object类的子类或间接子类，因此任何类的实例对象都可以直接使用这些方法。</p><h2 id="1-45-设计模式"><a href="#1-45-设计模式" class="headerlink" title="1.45 设计模式"></a>1.45 设计模式</h2><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计<br>经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p><p>总体来说设计模式分为三大类：<br>创建型模式 共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br>结构型模式 共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br>行为型模式 共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h2 id="1-46-设计模式需要遵循的原则"><a href="#1-46-设计模式需要遵循的原则" class="headerlink" title="1.46 设计模式需要遵循的原则"></a>1.46 设计模式需要遵循的原则</h2><p>1.开闭原则 说对扩展开放，对修改关闭。在程序需要拓展时，不能去修改原有的代码，实现热插拔的效果<br>2.里式替换原则  任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石<br>3.依赖倒转原则  真对接口编程，依赖于抽象而不依赖于具体<br>4.接口隔离原则  使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思<br>5.迪米特法则  一个实体应尽量少的与其他实体发生相互作用，使系统功能相对独立<br>6.合成复用原则 尽量使用合成&#x2F;聚合的方式，而不是使用继承</p><h2 id="1-47-几种典型设计模式"><a href="#1-47-几种典型设计模式" class="headerlink" title="1.47 几种典型设计模式"></a>1.47 几种典型设计模式</h2><p>单例模式:单例对象能保证在一个JVM中，该对象只有一个实例存在。<br>饿汉式:类加载该实例就被创建</p><p>懒汉式:对象在使用时实例才被创建</p><p>双检锁式: 多线程监督</p><p>策略模式:策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。</p><p>策略模式可以选择不同的策略进行业务处理 ,抽象策略类通常有接口或者抽象类定义方法，具体策略类则对方法进行实现。</p><p>工厂模式:建立一个工厂类，对实现了同一接口的一些类进行实例的创建。</p><p>简单工厂 静态工厂 抽象工厂</p><p>适配器模式:适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题</p><p>适配器模式是转换不同业务类型的通用“插口”，可以将一个或多个类的接口转换为标准接口，使得原本不兼容的接口可以同时使用。</p><p>设计模式于人于系统都是多赢的，它使代码编写工程化，是软件工程的基石。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式描述了一个在我们周围不断重复发生的问题并能够解决，这是它被广泛应用的原因</p><h2 id="1-48-集合"><a href="#1-48-集合" class="headerlink" title="1.48 集合"></a>1.48 集合</h2><p>集合是指具有某种特定性质的具体的或抽象的对象汇总而成的集体，有时集合也称之为容器</p><p>程序中可以通过数组来保存多个对象，但在某些情况下无法确定到底需要保存多少个对象，此时数组将不再适用，因为数组的长度不可变。</p><p>JDK中提供了一系列特殊的类，这些类可以存储任意类型的对象，并且长度可变，统称为集合。</p><p>集合按照其存储结构可以分为两大类，即单列集合Collection和双列集合Map</p><p>Collection：单列集合类的根接口，存储一系列符合某种规则的元素，它有两个重要的子接口，分别是List和Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素无序并且不可重复。List接口的主要实现类有ArrayList和LinkedList，Set接口的主要实现类有HashSet和TreeSet。</p><p>Map：双列集合类的根接口，用于存储具有键(Key)、值(Value)映射关系的元素，每个元素都包含一对键值，在使用Map集合时可以通过指定的Key找到对应的Value，例如根据一个学生的学号就可以找到对应的学生。Map接口的主要实现类有HashMap和TreeMap。</p><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。</p><p><img src="https://files.superbed.cn/images/65b8fb94871b83018a6617dd.png"></p><h2 id="1-49-List接口简介"><a href="#1-49-List接口简介" class="headerlink" title="1.49 List接口简介"></a>1.49 List接口简介</h2><p> List接口继承自Collection接口，是单列集合的一个重要分支，习惯性地会将实现了List接口的对象称为List集合。</p><p> 在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。</p><p> 另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p><p> List不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法。</p><h2 id="1-50-ArrayList集合"><a href="#1-50-ArrayList集合" class="headerlink" title="1.50 ArrayList集合"></a>1.50 ArrayList集合</h2><p> ArrayList是List接口的一个实现类，它是程序中最常见的一种集合</p><p> 在ArrayList内部封装了一个长度可变的数组对象，当存入的元素超过数组长度时，ArrayList会在内存中分配一个更大的数组来存储这些元素，因此可以将ArrayList集合看作一个长度可变的数组</p><p> ArrayList集合中大部分方法都是从父类Collection和List继承过来的，其中add()方法和get()方法用于实现元素的存取。</p><h2 id="1-51-LinkedList集合"><a href="#1-51-LinkedList集合" class="headerlink" title="1.51 LinkedList集合"></a>1.51 LinkedList集合</h2><p> List接口的另一个实现类LinkedList，克服了ArrayList集合在查询元素时速度很快，但在增删元素时效率较低的局限性。</p><p> 该集合内部维护了一个双向循环链表，链表中的每一个元素都使用引用的方式来记住它的前一个元素和后一个元素，从而可以将所有的元素彼此连接起来。</p><p> 当插入一个新元素时，只需要修改元素之间的这种引用关系即可，删除一个节点也是如此。</p><p> LinkedList集合除了具备增删元素效率高的特点，还专门针对元素的增删操作定义了一些特有的方法。</p><p><img src="https://pic.imgdb.cn/item/65b8fb94871b83018a661910.png"></p><h2 id="1-52-Iterator集合"><a href="#1-52-Iterator集合" class="headerlink" title="1.52 Iterator集合"></a>1.52 Iterator集合</h2><p> Iterator接口也是Java集合框架中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用于存储元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被称为迭代器。Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素</p><p>在使用Iterator迭代器对集合中的元素进行迭代时，如果调用了集合对象的remove()方法去删除元素，会出现异常。</p><p>这个异常是迭代器对象抛出的，出现异常的原因是集合中删除了元素会导致迭代器预期的迭代次数发生改变，导致迭代器的结果不准确</p><p>为了解决上述问题，可以采用两种方式：</p><p>1.在使用break语句跳出循环以后，由于没有继续使用迭代器对集合中的元素进行迭代，因此，集合中删除元素对程序没有任何影响，不会出现异常</p><p>2.如果需要在集合的迭代期间对集合中的元素进行删除，可以使用迭代器本身的删除方法</p><h2 id="1-52-1-Java-Iterator（迭代器）"><a href="#1-52-1-Java-Iterator（迭代器）" class="headerlink" title="1.52.1 Java Iterator（迭代器）"></a>1.52.1 Java Iterator（迭代器）</h2><p><a href="https://www.runoob.com/java/java-collections.html"><img src="https://www.runoob.com/images/up.gif" alt="Java 集合框架"> Java 集合框架</a></p><p>Java迭代器（Iterator）是 Java 集合框架中的一种机制，是一种用于遍历集合（如列表、集合和映射等）的接口。</p><p>它提供了一种统一的方式来访问集合中的元素，而不需要了解底层集合的具体实现细节。</p><p>Java Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代 <a href="https://www.runoob.com/java/java-arraylist.html">ArrayList</a> 和 <a href="https://www.runoob.com/java/java-hashset.html">HashSet</a> 等集合。</p><p>Iterator 是 Java 迭代器最简单的实现，ListIterator 是 Collection API 中的接口， 它扩展了 Iterator 接口。</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/07/ListIterator-Class-Diagram.jpg" alt="img"></p><p>迭代器接口定义了几个方法，最常用的是以下三个：</p><ul><li><strong>next()</strong> - 返回迭代器的下一个元素，并将迭代器的指针移到下一个位置。</li><li><strong>hasNext()</strong> - 用于判断集合中是否还有下一个元素可以访问。</li><li><strong>remove()</strong> - 从集合中删除迭代器最后访问的元素（可选操作）。</li></ul><p>Iterator 类位于 java.util 包中，使用前需要引入它，语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator; <span class="hljs-comment">// 引入 Iterator 类</span><br></code></pre></td></tr></table></figure><p>通过使用迭代器，我们可以逐个访问集合中的元素，而不需要使用传统的 for 循环或索引。这种方式更加简洁和灵活，并且适用于各种类型的集合。</p><h3 id="获取一个迭代器"><a href="#获取一个迭代器" class="headerlink" title="获取一个迭代器"></a>获取一个迭代器</h3><p>集合想获取一个迭代器可以使用 iterator() 方法:</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><em>&#x2F;&#x2F; 引入 ArrayList 和 Iterator 类</em><br><strong>import</strong> java.util.ArrayList;<br><strong>import</strong> java.util.Iterator;</p><p><strong>public</strong> <strong>class</strong> RunoobTest {<br>  <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {</p><p>​    <em>&#x2F;&#x2F; 创建集合</em><br>​    ArrayList<String> sites &#x3D; <strong>new</strong> ArrayList<String>();<br>​    sites.add(“Google”);<br>​    sites.add(“Runoob”);<br>​    sites.add(“Taobao”);<br>​    sites.add(“Zhihu”);</p><p>​    <em>&#x2F;&#x2F; 获取迭代器</em><br>​    Iterator<String> it &#x3D; sites.iterator();</p><p>​    <em>&#x2F;&#x2F; 输出集合中的第一个元素</em><br>​    System.out.println(it.next());<br>  }<br>}</p><p>执行以上代码，输出结果如下：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Google</span><br></code></pre></td></tr></table></figure><p>使用迭代器遍历集合时，如果在遍历过程中对集合进行了修改（例如添加或删除元素），可能会导致 ConcurrentModificationException 异常，为了避免这个问题，可以使用迭代器自身的 <strong>remove()</strong> 方法进行删除操作。</p><h3 id="循环集合元素"><a href="#循环集合元素" class="headerlink" title="循环集合元素"></a>循环集合元素</h3><p>让迭代器 it 逐个返回集合中所有元素最简单的方法是使用 while 循环：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">while</span>(<span class="hljs-keyword">it</span>.hasNext()) &#123;<br>    System.out.println(<span class="hljs-keyword">it</span>.next());<br>&#125;<br></code></pre></td></tr></table></figure><p>以下输出集合 sites 中的所有元素：</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p><em>&#x2F;&#x2F; 引入 ArrayList 和 Iterator 类</em><br><strong>import</strong> java.util.ArrayList;<br><strong>import</strong> java.util.Iterator;</p><p><strong>public</strong> <strong>class</strong> RunoobTest {<br>  <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {</p><p>​    <em>&#x2F;&#x2F; 创建集合</em><br>​    ArrayList<String> sites &#x3D; <strong>new</strong> ArrayList<String>();<br>​    sites.add(“Google”);<br>​    sites.add(“Runoob”);<br>​    sites.add(“Taobao”);<br>​    sites.add(“Zhihu”);</p><p>​    <em>&#x2F;&#x2F; 获取迭代器</em><br>​    Iterator<String> it &#x3D; sites.iterator();</p><p>​    <em>&#x2F;&#x2F; 输出集合中的所有元素</em><br>​    <strong>while</strong>(it.hasNext()) {<br>​      System.out.println(it.next());<br>​    }<br>  }<br>}</p><p>执行以上代码，输出结果如下：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Google</span><br><span class="hljs-attribute">Runoob</span><br><span class="hljs-attribute">Taobao</span><br><span class="hljs-attribute">Zhihu</span><br></code></pre></td></tr></table></figure><p>删除元素</p><p>要删除集合中的元素可以使用 remove() 方法。</p><p>以下实例我们删除集合中小于 10 的元素：</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p><em>&#x2F;&#x2F; 引入 ArrayList 和 Iterator 类</em><br><strong>import</strong> java.util.ArrayList;<br><strong>import</strong> java.util.Iterator;</p><p><strong>public</strong> <strong>class</strong> RunoobTest {<br>  <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {<br>    ArrayList<Integer> numbers &#x3D; <strong>new</strong> ArrayList<Integer>();<br>    numbers.add(12);<br>    numbers.add(8);<br>    numbers.add(2);<br>    numbers.add(23);<br>    Iterator<Integer> it &#x3D; numbers.iterator();<br>    <strong>while</strong>(it.hasNext()) {<br>      Integer i &#x3D; it.next();<br>      <strong>if</strong>(i &lt; 10) {<br>        it.remove(); <em>&#x2F;&#x2F; 删除小于 10 的元素</em><br>      }<br>    }<br>    System.out.println(numbers);<br>  }<br>}</p><p>执行以上代码，输出结果如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[12, 23]</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong>Java 迭代器是一种单向遍历机制，即只能从前往后遍历集合中的元素，不能往回遍历。同时，在使用迭代器遍历集合时，不能直接修改集合中的元素，而是需要使用迭代器的 remove() 方法来删除当前元素。</p><h2 id="1-53-foreach循环"><a href="#1-53-foreach循环" class="headerlink" title="1.53 foreach循环"></a>1.53 foreach循环</h2><p> 虽然Iterator可以用来遍历集合中的元素，但写法上比较繁琐，为了简化书写，从JDK5.0开始，提供了foreach循环。foreach循环是一种更加简洁的for循环，也称增强for循环。foreach循环用于遍历数组或集合中的元素，其具体语法格式如下：</p><p>for(容器中元素类型 临时变量 : 容器变量){</p><p>​执行语句</p><p>}</p><p>与for循环相比，foreach循环不需要获得容器的长度，也不需要根据索引访问容器中的元素，但它会自动遍历容器中的每个元素</p><p>foreach循环虽然书写起来很简洁，但在使用时也存在一定的局限性。当使用foreach循环遍历集合和数组时，只能访问集合中的元素，不能对其中的元素进行修改</p><h2 id="1-54-ListIterator接口"><a href="#1-54-ListIterator接口" class="headerlink" title="1.54 ListIterator接口"></a>1.54 ListIterator接口</h2><p> Iterator迭代器提供了hasNext()方法和next()方法，通过这两个方法可以实现集合中元素的迭代，迭代的方向是从集合中的第一个元素向最后一个元素迭代，也就是所谓的正向迭代。</p><p> 为了使迭代方式更加多元化，JDK中还定义了一个ListIterator迭代器，它是Iterator的子类，该类在父类的基础上增加了一些特有方法。</p><p><img src="https://pic.imgdb.cn/item/65b8fb95871b83018a6619b4.png"></p><h2 id="1-55-Enumeration接口"><a href="#1-55-Enumeration接口" class="headerlink" title="1.55 Enumeration接口"></a>1.55 Enumeration接口</h2><p> 在JDK1.2以前还没有Iterator接口的时候，遍历集合需要使用Enumeration接口，它的用法和Iterator类似。</p><p> JDK中提供了一个Vevtor集合，该集合是List接口的一个实现类，用法与ArrayList完全相同，区别在于Vector集合是线程安全的，而ArrayList集合是线程不安全的。在Vector类中提供了一个elements()方法用于返回Enumeration对象，通过Enumeration对象就可以遍历该集合中的元素。</p><h2 id="1-56-Set接口简介"><a href="#1-56-Set接口简介" class="headerlink" title="1.56 Set接口简介"></a>1.56 Set接口简介</h2><p> Set接口和List接口一样，同样继承自Collection接口，它与Collection接口中的方法基本一致，并没有对Collection接口进行功能上的扩充，只是比Collection接口更加严格了。与List接口不同的是，Set接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p><p> Set接口主要有两个实现类，分别是HashSet和TreeSet。其中，HashSet是根据对象的哈希值来确定元素在集合中的存储的位置，因此具有良好的存取和查找性能。TreeSet则是以二叉树的方式来存储元素，它可以实现对集合中的元素进行排序。</p><h2 id="1-57-HashSet集合"><a href="#1-57-HashSet集合" class="headerlink" title="1.57 HashSet集合"></a>1.57 HashSet集合</h2><p> HashSet是Set接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的。当向HashSet集合中添加一个对象时，首先会调用该对象的hashCode()方法来确定元素的存储位置，然后再调用对象的equals()方法来确保该位置没有重复元素。</p><h2 id="1-58-TreeSet集合"><a href="#1-58-TreeSet集合" class="headerlink" title="1.58 TreeSet集合"></a>1.58 TreeSet集合</h2><p> TreeSet是Set接口的另一个实现类，它内部采用平衡二叉树来存储元素，这样的结构可以保证TreeSet集合中没有重复的元素，并且可以对元素进行排序。</p><p> 所谓二叉树就是说每个节点最多有两个子节点的有序树，每个节点及其子节点组成的树称为子树，通常左侧的子节点称为“左子树”，右侧的节点称为“右子树”，其中左子树上的元素应小于它的根结点，而右子树上的元素应大于它的根结点。</p><p> 二叉树中元素的存储过程：</p><p> 当二叉树中存入新元素时，新元素首先会与第1个元素(最顶层元素)进行比较，如果小于第1个元素就执行左边的分支，继续和该分支的子元素进行比较。如果大于第1个元素就执行右边的分支，继续和该分支的子元素进行比较。如此往复，直到与最后一个元素进行比较时，如果新元素小于最后一个元素就将其放在最后一个元素的左子树上，如果大于最后一个元素就将其放在最后一个元素的右子树上。</p><p> 在TreeSet集合中存放Student类型对象时，如果Student类没有实现Comparable接口，则Student类型的对象将不能进行比较，这时，TreeSet集合就不知道按照什么排序规则对Student对象进行排序，最终导致程序报错。因此，为了在TreeSet集合中存放Student对象，必须使Student类实现Comparable接口。</p><p> 定义的类没有实现Comparable接口或者对于实现了Comparable接口的类而不想按照定义的compareTo()方法进行排序，，例如，希望字符串可以按照长度来进行排序，这时，可以通过自定义比较器的方式对TreeSet集合中的元素排序，即实现Comparator接口，在创建TreeSet集合时指定比较器。</p><h2 id="1-59-Map接口简介"><a href="#1-59-Map接口简介" class="headerlink" title="1.59 Map接口简介"></a>1.59 Map接口简介</h2><p> 在现实生活中，每个人都有唯一的身份证号，通过身份证号可以查询到这个人的信息，这两者是一对一的关系。</p><p> 在应用程序中，如果想存储这种具有对应关系的数据，则需要使用JDK中提供的Map接口。</p><p> Map接口是一种双列集合，它的每个元素都包含一个键对象Key和值对象Value，键和值对象之间存在一种对应关系，称为映射。</p><p> 从Map集合中访问元素时，只要指定了Key，就能找到对应的Value。</p><p><img src="https://pic.imgdb.cn/item/65b8fb95871b83018a661a96.png"></p><h2 id="1-60-HashMap集合"><a href="#1-60-HashMap集合" class="headerlink" title="1.60 HashMap集合"></a>1.60 HashMap集合</h2><p> HashMap集合是Map接口的一个实现类，它用于存储键值映射关系，但必须保证不出现重复的键。</p><p> 在程序开发中，经常需要取出Map中所有的键和值，那么如何遍历Map中所有的键值对呢？</p><p> 有两种方式可以实现，<strong>第一种方式</strong>就是先遍历Map集合中所有的键，再根据键获取相应的值。</p><p><strong>另外一种遍历方式</strong>是先获取集合中的所有的映射关系，然后从映射关系中取出键和值</p><p>在Map中，还提供了一个values()方法，通过这个方法可以直接获取Map中存储所有值的Collection集合。</p><p> HashMap集合迭代出来元素的顺序和存入的顺序是不一致的。</p><p> 如果想让这两个顺序一致，可以使用Java中提供的LinkedHashMap类，它是HashMap的子类，和LinkedList一样也使用双向链表来维护内部元素的关系，使Map元素迭代的顺序与存入的顺序一致。</p><h2 id="1-61-TreeMap集合"><a href="#1-61-TreeMap集合" class="headerlink" title="1.61 TreeMap集合"></a>1.61 TreeMap集合</h2><p> TreeMap集合是用来存储键值映射关系的，其中不允许出现重复的键。在TreeMap中是通过二叉树的原理来保证键的唯一性，这个TreeSet集合存储的原理一样，因此TreeMap中所有的键是按照某种顺序排列的。</p><p> 在使用TreeMap集合时，也可以通过自定义比较器的方式对所有的键进行排序。</p><h2 id="1-62-Properties集合"><a href="#1-62-Properties集合" class="headerlink" title="1.62 Properties集合"></a>1.62 Properties集合</h2><p> Map接口中还有一个实现类Hashtable，它在存取元素时速度很慢，目前基本上被HashMap类所取代。</p><p> 但Hashtable类有一个子类Properties在实际应用中非常重要，Properties主要用来存储字符串类型的键和值，在实际开发中，经常使用Properties集合来存取应用的配置项。</p><p> 假设有一个文本编辑工具，要求默认背景色是红色，字体大小为14px，语言为中文，其配置项应该是下面的样子：</p><p>Backgroup-color&#x3D;red</p><p>Font-size&#x3D;14px</p><p>language&#x3D;chinese</p><h2 id="1-63-泛型"><a href="#1-63-泛型" class="headerlink" title="1.63 泛型"></a>1.63 泛型</h2><p>为什么使用泛型</p><p> 当把一个对象存入集合后，集合会“忘记”这个对象的类型，将该对象从集合中取出时，这个对象的编译类型就变成了Object类型。</p><p> 换句话说，我们在程序中无法确定一个集合中的元素到底是什么类型的。那么在取出元素时，如果进行强制类型转换就很容易出错。</p><p> 为了解决这个问题，在Java中引入了“参数化类型(parameterized type)”这个概念，即泛型。</p><p> 它可以限定方法操作的数据类型，在定义集合类时，可以使用“&lt;参数化类型&gt;”的方式指定该类中方法操作的数据类型。</p><p>限定了ArrayList集合只能存储String类型元素，将改写后的程序再次编译，程序在编译时期就会出现错误提示</p><p><img src="https://pic.imgdb.cn/item/65b8fb95871b83018a661bf4.png"></p><p> 程序编译报错的原因是修改后的代码限定了集合元素的数据类型，ArrayList<String>这样的集合只能存储String类型的元素，程序在编译时，编译器检查出Integer类型的元素与List集合的规定的类型不匹配，编译不通过，这样就可以在编译时期解决错误，避免程序在运行时期发生错误。</p><h2 id="1-64-自定义泛型"><a href="#1-64-自定义泛型" class="headerlink" title="1.64 自定义泛型"></a>1.64 自定义泛型</h2><p>那么泛型的作用是什么，在程序中是否能自定义泛型呢</p><p> 从运行结果可以看出，程序在编译时期就报错，这是因为在代码第13行处存入了一个Integer类型的数据，在代码第14行处取出这个数据时，将该数据转换成了String类型，出现了类型不匹配的错误。</p><p> 为了避免这个问题，就可以使用泛型，如果在定义一个类CachePool时使用<T>声明参数类型，(T其实就是Type的缩写，这里也可以使用其它字符，为了方便理解都定义为T)，将save()方法的参数类型和get()方法的返回值类型都声明为T，那么在存入元素时元素的类型就被限定了，容器中就只能存入这种T类型的元素，在取出元素时就无需进行类型转换</p><h2 id="1-65-collections"><a href="#1-65-collections" class="headerlink" title="1.65 collections"></a>1.65 collections</h2><p>•JDK提供了一个工具类专门用来操作集合，这个类就是Collections，它位于java.util包中。Collections类中提供了大量的方法用于对集合中元素进行排序、查找和修改等操作，接下来对这些常用的方法进行介绍。</p><p>1 排序操作</p><p><img src="https://pic.imgdb.cn/item/65b8fb9a871b83018a66338f.png"></p><p>2、查找、替换操作</p><p><img src="https://pic.imgdb.cn/item/65b8fb9a871b83018a663437.png"></p><h2 id="1-66-Arrays"><a href="#1-66-Arrays" class="headerlink" title="1.66 Arrays"></a>1.66 Arrays</h2><p>java.util包中还提供了一个专门用于操作数组的工具类——Arrays。Arrays工具类提供了大量的静态方法</p><p>使用Arrays的sort()方法排序</p><p>使用Arrays的binarySearch(Object[] a, Object key)方法查找元素</p><p>使用Arrays的copyOfRange(int[] original, int from, int to)方法拷贝元素</p><p>在程序开发中，经常需要在不破坏原数组的情况下使用数组中的部分元素，这时可以使用Arrays工具类的copyOfRange(int[] original,int from,int to)方法将数组中指定范围的元素复制到一个新的数组中，该方法中参数original表示被复制的数组，from表示被复制元素的初始索引（包括），to表示被复制元素的最后索引（不包括）</p><p>使用Arrays的fill(Object[] a, Object val)方法填充元素</p><p>程序开发中，经常需要用一个值替换数组中的所有元素，这时可以使用Array的fill(Object[] a, Object val)方法，该方法可以将指定的值赋给数组中的每一个元素</p><p>使用Arrays的toString(int[] arr)方法把数组转换为字符串</p><p>在程序开发中，经常需要把数组以字符串的形式输出，这时就可以使用Arrays工具类的另一个方法toString(int[] arr)。需要注意的是，该方法并不是对Object类toString()方法的重写，只是用于返回指定数组的字符串形式</p><h2 id="1-67处理模型"><a href="#1-67处理模型" class="headerlink" title="1.67处理模型"></a>1.67处理模型</h2><p>Java中常用的处理模型有两种：Servlet和JSP。</p><p>Servlet是一种Java类，它可以接收来自客户端的HTTP请求，并生成HTTP响应。它们通常用于处理Web应用程序的后端逻辑。Servlet可以通过扩展<code>javax.servlet.http.HttpServlet</code>类来创建，并实现<code>doGet()</code>、<code>doPost()</code>等方法来处理请求。Servlet通常用于处理业务逻辑、数据存储和数据处理等任务。</p><p>JSP（JavaServer Pages）是一种动态网页技术，它使用Java代码和HTML标记创建动态网页。JSP文件通常包含HTML标记和Java代码块，可以通过JSP引擎来动态生成HTML页面。JSP通常用于呈现页面内容和与客户端进行交互。</p><p>这两个类型在Java Web开发中都扮演着重要的角色。Servlet提供了一种处理请求的方式，而JSP提供了一种动态生成HTML页面的方式。通常情况下，在Web应用程序中，Servlet和JSP是相互配合使用的，Servlet负责业务逻辑和数据处理，而JSP负责呈现页面内容。</p><h2 id="1-68-JDBC"><a href="#1-68-JDBC" class="headerlink" title="1.68 JDBC"></a>1.68 JDBC</h2><p>JDBC（Java Database Connectivity）是一种用于与关系型数据库进行交互的Java API。要连接到数据库并执行SQL语句，需要执行以下基本连接语法和步骤：</p><p>1.加载数据库驱动程序：在连接到数据库之前，需要加载数据库驱动程序。可以使用Class.forName()方法动态加载驱动程序，也可以使用Java 6及以上版本的自动驱动程序加载功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br></code></pre></td></tr></table></figure><p> 2.创建数据库连接：要连接到数据库，需要指定数据库的URL、用户名和密码。可以使用DriverManager.getConnection()方法创建数据库连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;username&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;password&quot;</span>;<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, user, password);<br></code></pre></td></tr></table></figure><p>3.创建Statement对象：要执行SQL语句，需要创建一个Statement对象。可以使用Connection.createStatement()方法创建Statement对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.createStatement();<br></code></pre></td></tr></table></figure><p>4.执行SQL语句：可以使用Statement对象的execute()、executeUpdate()或executeQuery()方法执行SQL语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SELECT * FROM mytable&quot;</span>;<br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> statement.executeQuery(sql);<br></code></pre></td></tr></table></figure><p>5.处理结果集：如果SQL语句返回结果集，可以使用ResultSet对象处理结果集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>    <span class="hljs-comment">// 处理结果集</span><br>&#125;<br></code></pre></td></tr></table></figure><p>6.关闭资源：在使用完数据库连接、Statement对象和ResultSet对象后，需要及时关闭它们以释放资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">resultSet.close();<br>statement.close();<br>connection.close();<br></code></pre></td></tr></table></figure><p>关于 JDBC， 哪一项叙述是不正确的（D）。<br>A.JDBC 屏蔽了底层数据库系统的差异性， 为程序员访问不同数据库提供统一的<br>面向对象的编程接口。<br>B.JDBC 编程接口 中的很多方法声明可能抛出 SQLException 异常， 必须用<br>try-catch 进行捕捉处理或继续声明抛出。<br>C.Connection 类型的实例代表具体的数据库连接， 为向目 标数据库发送和执行<br>SQL 语句提供支持。<br>D.Statement 类型的实例用于执行不带参数的 SQL 语句， PreparedStatement 可用<br>于执行带参数的 SQL 语句， 相比之下， Statement 的执行效率较高。<br>个人解析： PreparedStatement 有预编译机制， 与 Statement 相比较， 执行效率较<br>高。</p><h2 id="1-69-java-API"><a href="#1-69-java-API" class="headerlink" title="1.69 java API"></a>1.69 java API</h2><p><strong>StringBuffer</strong></p><p> 为了便于对字符串的修改，在JDK中提供了一个StringBuffer类（也称字符串缓冲区）。StringBuffer类和String类最大的区别在于它的内容和长度都是可以改变的。StringBuffer类似一个字符容器，当在其中添加或删除字符时，并不会产生新的StringBuffer对象。</p><p> StringBuffer类和String类有很多相似之处，初学者使用时容易混淆。</p><p>•1、String类表示的字符串是常量，一旦创建后，内容和长度都是无法改变的。StringBuffer表示字符容器，其内容和长度都可以随时修改。在操作字符串时，如果该字符串仅用于表示数据类型，则使用String类即可，但是如果需要对字符串中的字符进行增删操作，则使用StringBuffer类。</p><p>•2、String类覆盖了Object类的equals()方法，而StringBuffer类没有覆盖Object类的equals()方法</p><p>•3、String类对象可以用操作符“+”进行连接，而StringBuffer类对象之间不能</p><h2 id="1-70-按值传递与按引用传递"><a href="#1-70-按值传递与按引用传递" class="headerlink" title="1.70 按值传递与按引用传递"></a>1.70 按值传递与按引用传递</h2><p>按值传递是指在函数调用时，将参数的值复制一份，传递给函数内部使用。函数内部对该参数的任何修改都不会影响原始参数的值。</p><p>按引用传递是指在函数调用时，将参数的地址传递给函数。这意味着，在函数内部对参数进行的任何修改都将影响原始参数的值</p><h1 id="2-知识点总结"><a href="#2-知识点总结" class="headerlink" title="2.知识点总结"></a>2.知识点总结</h1><h3 id="2-1-关系"><a href="#2-1-关系" class="headerlink" title="2.1 关系"></a>2.1 关系</h3><p>实现关系是实现类和接口之间的关系； 泛化关系是类（或接口） 和子<br>类（或子接口） 之间的关系， 因此 A 和 B 很容易被排除掉； 类和该类数据成员<br>类之间的关系是组合关系的一种形式； 类与该类方法成员的形参类所对应的关系<br>就是依赖关系的一种形式。</p><h3 id="2-2-equals-compareTo区别"><a href="#2-2-equals-compareTo区别" class="headerlink" title="2.2 equals  &#x3D;&#x3D;  compareTo区别"></a>2.2 equals  &#x3D;&#x3D;  compareTo区别</h3><p>主要考查 equals、 &#x3D;&#x3D;和 compareTo 知识点。 equals 比较两个字符串对<br>象的值是否相同， &#x3D;&#x3D;比较两个字符串对象的地址是否相同， compareTo 按照字典<br>顺序比较两个字符串的值是否相等（如果参数字符串等于此字符串， 则返回值 0，<br>否则返回值就是两个字符串首次出现不同字符的 ASCII 的差值， 为正数或者负<br>数）。</p><h3 id="2-3-java关键字"><a href="#2-3-java关键字" class="headerlink" title="2.3 java关键字"></a>2.3 java关键字</h3><p>48个关键字：abstract、assert、boolean、break、byte、case、catch、char、class、continue、default、do、double、else、enum、extends、final、finally、float、for、if、implements、import、int、interface、instanceof、long、native、new、package、private、protected、public、return、short、static、strictfp、super、switch、synchronized、this、throw、throws、transient、try、void、volatile、while。</p><p> 2个保留字（现在没用以后可能用到作为关键字）：goto、const。</p><p> 3个特殊直接量：true、false、null。 </p><h3 id="2-4-计算数组的最值"><a href="#2-4-计算数组的最值" class="headerlink" title="2.4 计算数组的最值"></a>2.4 计算数组的最值</h3><p>Arrays.steam(arr).max().getAsInt();</p><p>Arrays.steam(arr).min().getAsInt();</p><h3 id="2-5-Java-Arrays方法-方法详解"><a href="#2-5-Java-Arrays方法-方法详解" class="headerlink" title="2.5 Java Arrays方法 方法详解"></a>2.5 Java Arrays方法 方法详解</h3><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Arrays.html#toString">https://www.runoob.com/manual/jdk11api/java.base/java/util/Arrays.html#toString</a>(boolean</p><p>Arrays.sort(arr);&#x2F;&#x2F;正序排列</p><p>Arrays.sort(arr, Collections.reverseOrder())&#x2F;&#x2F;倒序排列 arr必须是Integer数组 ，因为基本数据类型是不支持泛型化的，需要包装类</p><p>该方法是Arrays类的<strong>静态方法</strong>，用于对数组进行排序，时间复杂度O(n*logn)，方法返回值为void。排序后，数组中存放的是排序后的结果。由于该方法是在原来数组的空间基础上进行升序排序，因此不需要定义一个数组接收它，即不需要返回值。</p><h3 id="2-6-字符串长度与数组长度"><a href="#2-6-字符串长度与数组长度" class="headerlink" title="2.6 字符串长度与数组长度"></a>2.6 字符串长度与数组长度</h3><p>字符串 :length()</p><p>数组:length</p><h3 id="2-7-字符串方法"><a href="#2-7-字符串方法" class="headerlink" title="2.7 字符串方法"></a>2.7 字符串方法</h3><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/lang/String.html">https://www.runoob.com/manual/jdk11api/java.base/java/lang/String.html</a></p><p>contains(“s”)方法</p><p>当且仅当此字符串包含指定的char值序列时，才返回true。如果此字符串包含s  ，则返回true，否则 返回 false</p><p>split()方法对转译字符要加\\    split(“\\+“);</p><p>字符串与其他数据类型的转换</p><table><thead><tr><th>数据类型</th><th>字符串转换为其他数据类型的方法</th><th>其它数据类型转换为字符串的方法1</th><th>其他数据类型转换为字符串的方法2</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean.getBoolean(str)</td><td>String.valueOf([boolean] b)</td><td>Boolean.toString([boolean] b)</td></tr><tr><td>int</td><td>Integer.parseInt(str)</td><td>String.valueOf([int] i)</td><td>Int.toString([int] i)</td></tr><tr><td>long</td><td>Long.parseLong(str)</td><td>String.valueOf([long] l)</td><td>Long.toString([long] l)</td></tr><tr><td>float</td><td>Float.parseFloat(str)</td><td>String.valueOf([float] f)</td><td>Float.toString([float] f)</td></tr><tr><td>double</td><td>double.parseFloat(str)</td><td>String.valueOf([double] d)</td><td>Double.toString([double] d)</td></tr><tr><td>byte</td><td>Byte.parseByte(str)</td><td>String.valueOf([byte] bt)</td><td>Byte.toString([byte] bt)</td></tr><tr><td>char</td><td>str.charAt(i)</td><td>String.valueOf([char] c)</td><td>Character.toString([char] c)</td></tr></tbody></table><h3 id="2-8-Integer方法"><a href="#2-8-Integer方法" class="headerlink" title="2.8 Integer方法"></a>2.8 Integer方法</h3><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/lang/Integer.html#parseInt(java.lang.CharSequence,int,int,int)">https://www.runoob.com/manual/jdk11api/java.base/java/lang/Integer.html#parseInt(java.lang.CharSequence,int,int,int)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer.compare() 是 Java 中 Integer 类的一个静态方法，用于比较两个整数的大小。该方法返回一个整数值，表示两个整数的比较结果。如果第一个整数小于第二个整数，则返回负值；如果第一个整数大于第二个整数，则返回正值；如果两个整数相等，则返回 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer.parseInt(String.join(<span class="hljs-string">&quot;&quot;</span>, strings))是一个Java表达式，用于将一个字符串列表（strings）中的所有字符串连接起来，并将结果解析为整数。<br><br>具体地，它执行以下步骤：<br><br>使用String.join(<span class="hljs-string">&quot;&quot;</span>, strings)将字符串列表中的所有字符串连接成一个单独的字符串。String.join(delimiter, strings)方法使用指定的分隔符（这里为空字符串 <span class="hljs-string">&quot;&quot;</span>）将字符串列表中的所有字符串连接起来。<br>使用Integer.parseInt()将连接后的字符串解析为整数。Integer.parseInt(String)方法将字符串参数解析为对应的整数值。<br>例如，如果strings列表包含[<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>]，则String.join(<span class="hljs-string">&quot;&quot;</span>, strings)将返回一个字符串<span class="hljs-string">&quot;123&quot;</span>。然后，Integer.parseInt(<span class="hljs-string">&quot;123&quot;</span>)将返回整数值<span class="hljs-number">123</span>。<br></code></pre></td></tr></table></figure><h3 id="2-9-Math方法"><a href="#2-9-Math方法" class="headerlink" title="2.9 Math方法"></a>2.9 Math方法</h3><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/lang/Math.html">https://www.runoob.com/manual/jdk11api/java.base/java/lang/Math.html</a></p><h3 id="2-10-for与while循环"><a href="#2-10-for与while循环" class="headerlink" title="2.10 for与while循环"></a>2.10 for与while循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">一直循环<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i;;i++)&#123;&#125;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;&#125;<br>循环三次<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;&#125;<br><br><span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;<br><span class="hljs-keyword">while</span>(i--&gt;<span class="hljs-number">0</span>)&#123;&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-11判断是否为整数"><a href="#2-11判断是否为整数" class="headerlink" title="2.11判断是否为整数"></a>2.11判断是否为整数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(<span class="hljs-type">double</span>)res-<span class="hljs-type">int</span>(res)==<span class="hljs-number">0.0</span>;<br></code></pre></td></tr></table></figure><h3 id="2-12因子-因数-约数-素数-质数-合数-自然数的概念"><a href="#2-12因子-因数-约数-素数-质数-合数-自然数的概念" class="headerlink" title="2.12因子,因数(约数),素数(质数),合数,自然数的概念"></a>2.12因子,因数(约数),素数(质数),合数,自然数的概念</h3><p>因子就是可以整除这个数的数,不不包括这个数本身</p><p>因数(约数)包括这个数本身</p><p>完数是指此数的因子之和等于此数</p><p>素数(质数)是在大与1的自然数中,除1和它本身外,不能被其他自然数整除(除0以外)的数称之素数</p><p>合数是比1大但不是素数的数</p><p>自然数是0,1,2,3,4….</p><h3 id="2-13-初始化最小值与最大值"><a href="#2-13-初始化最小值与最大值" class="headerlink" title="2.13 初始化最小值与最大值"></a>2.13 初始化最小值与最大值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.Min_Vaule<br><span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.Max_vaule<br></code></pre></td></tr></table></figure><p>初始化,确保任何出现的次数都会比这些初始化值更大或更小,这样就可以找到最大和最小值,而不会受到初始化值干扰</p><h3 id="2-14-处理换行符"><a href="#2-14-处理换行符" class="headerlink" title="2.14 处理换行符"></a>2.14 处理换行符</h3><p>经过从网上查询资料，了解到Scanner是一个扫描器，它扫描数据都是去内存中一块缓冲区中进行扫描并读入数据的，而我们在控制台中输入的数据也都是被先存入缓冲区中等待扫描器的扫描读取。这个扫描器在扫描过程中判断停止的依据就是“空白符”，空格、回车等都算作是空白符。</p><p>next（）与nextLine（）的区别<br>next()方法在读取内容时，会过滤掉有效字符前面的无效字符，对输入有效字符之前遇到的空格键、Tab键或Enter键等结束符，next()方法会自动将其过滤掉；只有在读取到有效字符之后，next()方法才将其后的空格键、Tab键或Enter键等视为结束符；所以next()方法不能得到带空格的字符串。<br>nextLine()方法字面上有扫描一整行的意思，它的结束符只能是Enter键，即nextLine()方法返回的是Enter键之前没有被读取的所有字符，它是可以得到带空格的字符串的。<br>next()方法在扫描到空白符的时候会将前面的数据读取走，但会丢下空白符“\r”在缓冲区中<br>nextLine()方法在扫描的时候会将扫描到的空白符一同清理掉</p><p>问题解决</p><p>1.可以在后面加一个 nextLine();专门读取无效字符<br>2.或者就别用nextLine()输入， 直接用next();</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextInt();<br>sc.nextline();<span class="hljs-comment">//处理换行符,将换行符读掉</span><br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs txt">在 Java 中，`next()` 和 `nextLine()` 是 `Scanner` 类用于读取输入的两种不同方法。<br><br>- **`next()` 方法：** 它读取输入中的下一个单词（由空格分隔），并将其作为字符串返回。它在读取到下一个空格、换行符或其他分隔符时停止，并返回此之前的内容。如果在执行 `next()` 之前有空白字符存在（例如换行符、空格），则 `next()` 会跳过这些空白字符。<br><br>Scanner scanner = new Scanner(System.in);<br>System.out.print(&quot;Enter your name: &quot;);<br>String name = scanner.next();<br><br><br>如果输入是 `&quot;John Doe&quot;`，`name` 将会被赋值为 `&quot;John&quot;`。<br><br>- **`nextLine()` 方法：** 它读取输入中的整行内容，包括换行符 `\n` 在内，并将整行内容作为字符串返回。`nextLine()` 会读取直到遇到换行符为止，即使是空行也会被读取并返回空字符串。<br><br><br>Scanner scanner = new Scanner(System.in);<br>System.out.print(&quot;Enter a sentence: &quot;);<br>String sentence = scanner.nextLine();<br><br><br>如果输入是 `&quot;Hello World&quot;`，`sentence` 将会被赋值为 `&quot;Hello World&quot;`。<br><br>**区别总结：**<br>- `next()` 读取下一个单词，以空格分隔。<br>- `nextLine()` 读取整行文本，包括换行符。<br><br>如果在读取混合使用 `next()` 和 `nextLine()` 时，可能需要额外处理换行符 `\n` 的情况，以免造成不符合预期的输入。<br></code></pre></td></tr></table></figure><p>[<a href="https://blog.csdn.net/qq_51399192/article/details/120195940">java] next()和nextLine()的区别和使用，干活满满哦_next和nextline-CSDN博客</a></p><h3 id="2-15-除法问题"><a href="#2-15-除法问题" class="headerlink" title="2.15 除法问题"></a>2.15 除法问题</h3><p>不可以两个<code>int</code>变量直接做除法，会丢失精度。<br>推荐：将其中一个<code>int</code>变量强制转换类型为小数即可。</p><p><strong>两个 int 变量的除法运算 结果的精度问题</strong></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// / 的两个操作数都为int变量，则运算结果也为int</span><br>        System.out.println(<span class="hljs-number">5</span> / <span class="hljs-number">2</span>);      <span class="hljs-comment">// 2</span><br><br>        <span class="hljs-comment">// 将其中任意一个操作数转换为浮点数，则运算为：int和double的运算，结果也为double。</span><br>        System.out.println(<span class="hljs-number">5</span> / <span class="hljs-number">2.0</span>);    <span class="hljs-comment">// 2.5</span><br>        System.out.println(<span class="hljs-number">5.0</span> / <span class="hljs-number">2</span>);    <span class="hljs-comment">// 2.5</span><br><br>        <span class="hljs-comment">// 模拟 int / int</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> a / b;<br>        System.out.println(result);     <span class="hljs-comment">// 2</span><br>        <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>两个<code>int</code>类型加减、乘法都没有问题。但是除法：<br>两个<code>int</code>进行除法运算，结果依旧是<code>int</code>类型。<br>所以像<code>5 / 2</code>这样，结果明明为<code>2.5</code>，但是小数部分会直接省略(int只用于存整数，没有存储浮点数的机制)。</p><h3 id="2-16-正则表达式"><a href="#2-16-正则表达式" class="headerlink" title="2.16 正则表达式"></a>2.16 正则表达式</h3><p><a href="https://www.runoob.com/java/java-regular-expressions.html">https://www.runoob.com/java/java-regular-expressions.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java">一、校验数字的表达式<br><span class="hljs-number">1</span> 数字：^[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]*$<br><span class="hljs-number">2</span> n位的数字：^\d&#123;n&#125;$<br><span class="hljs-number">3</span> 至少n位的数字：^\d&#123;n,&#125;$<br><span class="hljs-number">4</span> m-n位的数字：^\d&#123;m,n&#125;$<br><span class="hljs-number">5</span> 零和非零开头的数字：^(<span class="hljs-number">0</span>|[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]*)$<br><span class="hljs-number">6</span> 非零开头的最多带两位小数的数字：^([<span class="hljs-number">1</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]*)+(.[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;)?$<br><span class="hljs-number">7</span> 带<span class="hljs-number">1</span>-<span class="hljs-number">2</span>位小数的正数或负数：^(\-)?\d+(\.\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;)?$<br><span class="hljs-number">8</span> 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$<br><span class="hljs-number">9</span> 有两位小数的正实数：^[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+(.[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">2</span>&#125;)?$<br><span class="hljs-number">10</span> 有<span class="hljs-number">1</span>~<span class="hljs-number">3</span>位小数的正实数：^[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+(.[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;)?$<br><span class="hljs-number">11</span> 非零的正整数：^[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>]\d*$ 或 ^([<span class="hljs-number">1</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]*)&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;$ 或 ^\+?[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]*$<br><span class="hljs-number">12</span> 非零的负整数：^\-[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>][]<span class="hljs-number">0</span>-<span class="hljs-number">9</span><span class="hljs-string">&quot;*$ 或 ^-[1-9]\d*$</span><br><span class="hljs-string">13 非负整数：^\d+$ 或 ^[1-9]\d*|0$</span><br><span class="hljs-string">14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</span><br><span class="hljs-string">15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</span><br><span class="hljs-string">16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</span><br><span class="hljs-string">17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</span><br><span class="hljs-string">18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</span><br><span class="hljs-string">19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</span><br><span class="hljs-string"></span><br><span class="hljs-string">二、校验字符的表达式</span><br><span class="hljs-string">1 汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$</span><br><span class="hljs-string">2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$</span><br><span class="hljs-string">3 长度为3-20的所有字符：^.&#123;3,20&#125;$</span><br><span class="hljs-string">4 由26个英文字母组成的字符串：^[A-Za-z]+$</span><br><span class="hljs-string">5 由26个大写英文字母组成的字符串：^[A-Z]+$</span><br><span class="hljs-string">6 由26个小写英文字母组成的字符串：^[a-z]+$</span><br><span class="hljs-string">7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$</span><br><span class="hljs-string">8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$</span><br><span class="hljs-string">9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$</span><br><span class="hljs-string">10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$</span><br><span class="hljs-string">11 可以输入含有^%&amp;&#x27;,;=?$\&quot;等字符：[^%&amp;&#x27;,;=?$\x22]+</span><br><span class="hljs-string">12 禁止输入含有~的字符：[^~\x22]+</span><br><span class="hljs-string"></span><br><span class="hljs-string">三、特殊需求表达式</span><br><span class="hljs-string">1 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br><span class="hljs-string">2 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?</span><br><span class="hljs-string">3 InternetURL：[a-zA-z]+://[^\s]* 或 ^https://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</span><br><span class="hljs-string">4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$</span><br><span class="hljs-string">5 电话号码(&quot;</span>XXX-XXXXXXX<span class="hljs-string">&quot;、&quot;</span>XXXX-XXXXXXXX<span class="hljs-string">&quot;、&quot;</span>XXX-XXXXXXX<span class="hljs-string">&quot;、&quot;</span>XXX-XXXXXXXX<span class="hljs-string">&quot;、&quot;</span>XXXXXXX<span class="hljs-string">&quot;和&quot;</span>XXXXXXXX)：^(\(\d&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;-)|\d&#123;<span class="hljs-number">3.4</span>&#125;-)?\d&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;$ <br><span class="hljs-number">6</span> 国内电话号码(<span class="hljs-number">0511</span>-<span class="hljs-number">4405222</span>、<span class="hljs-number">021</span>-<span class="hljs-number">87888822</span>)：\d&#123;<span class="hljs-number">3</span>&#125;-\d&#123;<span class="hljs-number">8</span>&#125;|\d&#123;<span class="hljs-number">4</span>&#125;-\d&#123;<span class="hljs-number">7</span>&#125;<br><span class="hljs-number">7</span> 身份证号：<br><span class="hljs-number">15</span>或<span class="hljs-number">18</span>位身份证：^\d&#123;<span class="hljs-number">15</span>&#125;|\d&#123;<span class="hljs-number">18</span>&#125;$<br><span class="hljs-number">15</span>位身份证：^[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>]\d&#123;<span class="hljs-number">7</span>&#125;((<span class="hljs-number">0</span>\d)|(<span class="hljs-number">1</span>[<span class="hljs-number">0</span>-<span class="hljs-number">2</span>]))(([<span class="hljs-number">0</span>|<span class="hljs-number">1</span>|<span class="hljs-number">2</span>]\d)|<span class="hljs-number">3</span>[<span class="hljs-number">0</span>-<span class="hljs-number">1</span>])\d&#123;<span class="hljs-number">3</span>&#125;$<br><span class="hljs-number">18</span>位身份证：^[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>]\d&#123;<span class="hljs-number">5</span>&#125;[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>]\d&#123;<span class="hljs-number">3</span>&#125;((<span class="hljs-number">0</span>\d)|(<span class="hljs-number">1</span>[<span class="hljs-number">0</span>-<span class="hljs-number">2</span>]))(([<span class="hljs-number">0</span>|<span class="hljs-number">1</span>|<span class="hljs-number">2</span>]\d)|<span class="hljs-number">3</span>[<span class="hljs-number">0</span>-<span class="hljs-number">1</span>])\d&#123;<span class="hljs-number">4</span>&#125;$<br><span class="hljs-number">8</span> 短身份证号码(数字、字母x结尾)：^([<span class="hljs-number">0</span>-<span class="hljs-number">9</span>])&#123;<span class="hljs-number">7</span>,<span class="hljs-number">18</span>&#125;(x|X)?$ 或 ^\d&#123;<span class="hljs-number">8</span>,<span class="hljs-number">18</span>&#125;|[<span class="hljs-number">0</span>-9x]&#123;<span class="hljs-number">8</span>,<span class="hljs-number">18</span>&#125;|[<span class="hljs-number">0</span>-9X]&#123;<span class="hljs-number">8</span>,<span class="hljs-number">18</span>&#125;?$<br><span class="hljs-number">9</span> 帐号是否合法(字母开头，允许<span class="hljs-number">5</span>-<span class="hljs-number">16</span>字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">15</span>&#125;$<br><span class="hljs-number">10</span> 密码(以字母开头，长度在<span class="hljs-number">6</span>~<span class="hljs-number">18</span>之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;<span class="hljs-number">5</span>,<span class="hljs-number">17</span>&#125;$<br><span class="hljs-number">11</span> 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在<span class="hljs-number">8</span>-<span class="hljs-number">10</span>之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;<span class="hljs-number">8</span>,<span class="hljs-number">10</span>&#125;$ <br><span class="hljs-number">12</span> 日期格式：^\d&#123;<span class="hljs-number">4</span>&#125;-\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;-\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;<br><span class="hljs-number">13</span> 一年的<span class="hljs-number">12</span>个月(<span class="hljs-number">01</span>～09和<span class="hljs-number">1</span>～<span class="hljs-number">12</span>)：^(<span class="hljs-number">0</span>?[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>]|<span class="hljs-number">1</span>[<span class="hljs-number">0</span>-<span class="hljs-number">2</span>])$<br><span class="hljs-number">14</span> 一个月的<span class="hljs-number">31</span>天(<span class="hljs-number">01</span>～09和<span class="hljs-number">1</span>～<span class="hljs-number">31</span>)：^((<span class="hljs-number">0</span>?[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>])|((<span class="hljs-number">1</span>|<span class="hljs-number">2</span>)[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>])|<span class="hljs-number">30</span>|<span class="hljs-number">31</span>)$ <br><span class="hljs-number">15</span> 钱的输入格式：<br><span class="hljs-number">16</span> <span class="hljs-number">1.</span>有四种钱的表示形式我们可以接受:<span class="hljs-string">&quot;10000.00&quot;</span> 和 <span class="hljs-string">&quot;10,000.00&quot;</span>, 和没有 <span class="hljs-string">&quot;分&quot;</span> 的 <span class="hljs-string">&quot;10000&quot;</span> 和 <span class="hljs-string">&quot;10,000&quot;</span>：^[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]*$ <br><span class="hljs-number">17</span> <span class="hljs-number">2.</span>这表示任意一个不以<span class="hljs-number">0</span>开头的数字,但是,这也意味着一个字符<span class="hljs-string">&quot;0&quot;</span>不通过,所以我们采用下面的形式：^(<span class="hljs-number">0</span>|[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]*)$ <br><span class="hljs-number">18</span> <span class="hljs-number">3.</span>一个<span class="hljs-number">0</span>或者一个不以<span class="hljs-number">0</span>开头的数字.我们还可以允许开头有一个负号：^(<span class="hljs-number">0</span>|-?[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]*)$ <br><span class="hljs-number">19</span> <span class="hljs-number">4.</span>这表示一个<span class="hljs-number">0</span>或者一个可能为负的开头不为<span class="hljs-number">0</span>的数字.让用户以<span class="hljs-number">0</span>开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+(.[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+)?$ <br><span class="hljs-number">20</span> <span class="hljs-number">5.</span>必须说明的是,小数点后面至少应该有<span class="hljs-number">1</span>位数,所以<span class="hljs-string">&quot;10.&quot;</span>是不通过的,但是 <span class="hljs-string">&quot;10&quot;</span> 和 <span class="hljs-string">&quot;10.2&quot;</span> 是通过的：^[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+(.[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">2</span>&#125;)?$ <br><span class="hljs-number">21</span> <span class="hljs-number">6.</span>这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+(.[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;)?$ <br><span class="hljs-number">22</span> <span class="hljs-number">7.</span>这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;(,[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">3</span>&#125;)*(.[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;)?$ <br><span class="hljs-number">23</span> <span class="hljs-number">8.1</span>到<span class="hljs-number">3</span>个数字,后面跟着任意个 逗号+<span class="hljs-number">3</span>个数字,逗号成为可选,而不是必须：^([<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+|[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;(,[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">3</span>&#125;)*)(.[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;)?$ <br><span class="hljs-number">24</span> 备注：这就是最终结果了,别忘了<span class="hljs-string">&quot;+&quot;</span>可以用<span class="hljs-string">&quot;*&quot;</span>替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里<br><span class="hljs-number">25</span> xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-<span class="hljs-number">9</span>]+\\.[x|X][m|M][l|L]$<br><span class="hljs-number">26</span> 中文字符的正则表达式：[\u4e00-\u9fa5]<br><span class="hljs-number">27</span> 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计<span class="hljs-number">2</span>，ASCII字符计<span class="hljs-number">1</span>))<br><span class="hljs-number">28</span> 空白行的正则表达式：\n\s*\r (可以用来删除空白行)<br><span class="hljs-number">29</span> HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)<br><span class="hljs-number">30</span> 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)<br><span class="hljs-number">31</span> 腾讯QQ号：[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">4</span>,&#125; (腾讯QQ号从<span class="hljs-number">10000</span>开始)<br><span class="hljs-number">32</span> 中国邮政编码：[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>]\d&#123;<span class="hljs-number">5</span>&#125;(?!\d) (中国邮政编码为<span class="hljs-number">6</span>位数字)<br><span class="hljs-number">33</span> IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)<br></code></pre></td></tr></table></figure><h3 id="2-17-BigDecimal"><a href="#2-17-BigDecimal" class="headerlink" title="2.17 BigDecimal"></a>2.17 BigDecimal</h3><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/math/BigDecimal.html">https://www.runoob.com/manual/jdk11api/java.base/java/math/BigDecimal.html</a></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">BigDecimal类和BigInteger类都能实现大数字的运算，不同的是BigDecimal类加入了小数的概念。一般的float型和double型数据只可以用来做科学计算或工程计算，但由于在商业计算中要求数字精度比较高，因此要使用BigDecimal类。BigDecimal类支持任何精度的定点数<br></code></pre></td></tr></table></figure><p>常用构造方法</p><p><img src="https://pic.imgdb.cn/item/65b8fb8f871b83018a65fd6c.jpg" alt="3"></p><p>常用方法</p><p><img src="https://pic.imgdb.cn/item/65b8fb8f871b83018a65fe32.jpg" alt="4"></p><p>divide()方法的多种模式</p><p><img src="https://pic.imgdb.cn/item/65b8fb8f871b83018a65ff35.jpg" alt="5"></p><p><img src="https://pic.imgdb.cn/item/65b8fb8f871b83018a65fc61.jpg" alt="1"></p><h3 id="2-18-BigInteger"><a href="#2-18-BigInteger" class="headerlink" title="2.18 BigInteger"></a>2.18 BigInteger</h3><p><a href="https://www.runoob.com/manual/jdk1.6/java.base/java/math/BigInteger.html">https://www.runoob.com/manual/jdk1.6/java.base/java/math/BigInteger.html</a></p><p><a href="https://blog.csdn.net/weixin_44259720/article/details/87002816">https://blog.csdn.net/weixin_44259720/article/details/87002816</a></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">BigInteger类的数字范围较Integer类的数字范围要大得多。前文介绍过Integer类是int的包装类，int的最大值为231-1，如果要计算更大的数字，使用Integer类就无法实现了，因此Java提供了BigInteger类来处理更大的数字。BigInteger类支持任意精度的整数，也就是说，在运算中BigInteger类可以准确地表示任何大小的整数值而不会丢失信息。在BigInteger类中封装了多种操作，除了基本的加、减、乘、除操作，还提供了绝对值、相反数、最大公约数以及判断是否为质数等操作。使用BigInteger类，可以实例化一个BigInteger对象，并自动调用相应的构造函数。BigInteger类具有很多构造函数，但最直接的一种方式是参数以字符串形式代表要处理的数字。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//常用的几种运算方法。</span><br><span class="hljs-keyword">public</span> BigInteger <span class="hljs-title function_">add</span><span class="hljs-params">(BigInteger val)</span>：做加法运算。<br><span class="hljs-keyword">public</span> BigInteger <span class="hljs-title function_">subtract</span><span class="hljs-params">(BigInteger val)</span>：做减法运算。<br><span class="hljs-keyword">public</span> BigInteger <span class="hljs-title function_">multiply</span><span class="hljs-params">(BigInteger val)</span>：做乘法运算。<br><span class="hljs-keyword">public</span> BigInteger <span class="hljs-title function_">divide</span><span class="hljs-params">(BigInteger val)</span>：做除法运算。<br><span class="hljs-keyword">public</span> BigInteger <span class="hljs-title function_">remainder</span><span class="hljs-params">(BigInteger val)</span>：做取余操作。<br><span class="hljs-keyword">public</span> BigInteger[] divideAndRemainder(BigInteger val)：用数组返回余数和商，结果数组中第一个值为商，第二个值为余数。<br><span class="hljs-keyword">public</span> BigInteger <span class="hljs-title function_">pow</span><span class="hljs-params">(<span class="hljs-type">int</span> exponent)</span>：进行取参数的exponent次方操作。<br><span class="hljs-keyword">public</span> BigInteger <span class="hljs-title function_">negate</span><span class="hljs-params">()</span>：取相反数。<br><span class="hljs-keyword">public</span> BigInteger <span class="hljs-title function_">shiftLeft</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>：将数字左移n位，如果n为负数，做右移操作。<br><span class="hljs-keyword">public</span> BigInteger <span class="hljs-title function_">shiftRight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>：将数字右移n位，如果n为负数，做左移操作。<br><span class="hljs-keyword">public</span> BigInteger <span class="hljs-title function_">and</span><span class="hljs-params">(BigInteger val)</span>：做与操作。<br><span class="hljs-keyword">public</span> BigInteger <span class="hljs-title function_">or</span><span class="hljs-params">(BigInteger val)</span>：做或操作<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(BigInteger val)</span>：做数字比较操作。<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object x)</span>：当参数x是BigInteger类型的数字并且数值与对象实例的数值相等时，返回<span class="hljs-literal">true</span>。<br><span class="hljs-keyword">public</span> BigInteger <span class="hljs-title function_">min</span><span class="hljs-params">(BigInteger val)</span>：返回较小的数值<br><span class="hljs-keyword">public</span> BigInteger <span class="hljs-title function_">max</span><span class="hljs-params">(BigInteger val)</span>：返回较大的数值。<br></code></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/65b8fb8f871b83018a65fcff.jpg" alt="2"></p><h3 id="2-19-String数组的初始化"><a href="#2-19-String数组的初始化" class="headerlink" title="2.19 String数组的初始化"></a>2.19 String数组的初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">一维数组<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayInit</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br><br>        <span class="hljs-comment">//静态初始化数组：方法一  </span><br>        String cats[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;  <br>                <span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-string">&quot;Sam&quot;</span>,<span class="hljs-string">&quot;Mimi&quot;</span>  <br>        &#125;;  <br><br>        <span class="hljs-comment">//静态初始化数组：方法二  </span><br>        String dogs[] = &#123;<span class="hljs-string">&quot;Jimmy&quot;</span>,<span class="hljs-string">&quot;Gougou&quot;</span>,<span class="hljs-string">&quot;Doggy&quot;</span>&#125;;  <br><br>        <span class="hljs-comment">//动态初始化数据  </span><br>        String books[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">2</span>];  <br>        books[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Thinking in Java&quot;</span>;  <br>        books[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Effective Java&quot;</span>;  <br><br>        System.out.println(cats.length);  <br>        System.out.println(dogs.length);  <br>        System.out.println(books.length);  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java">二维数组<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//方法1；定义并初始化arr </span><br>        <span class="hljs-type">int</span>[][] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<br>        arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        arr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;<br>        arr[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">3</span>;<br>        arr[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">4</span>;<br>        arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">8</span>;<br>       <span class="hljs-comment">//遍历arr</span><br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;arr[i].length;j++)&#123;<br>             System.out.println(<span class="hljs-string">&quot;arr[&quot;</span> + i + <span class="hljs-string">&quot;][&quot;</span> + j + <span class="hljs-string">&quot;]=&quot;</span> + arr[i][j]);<br>             &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;====================================&quot;</span>);<br>        <span class="hljs-comment">//方法二: 定义并初始化str ；</span><br>        String[][] str1= <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[][]&#123;&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,&#125;,&#123;<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>,&#125;,&#123;<span class="hljs-string">&quot;g&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;i&quot;</span>&#125;&#125;;<br>        <span class="hljs-comment">//方法三: 定义并初始化str ；</span><br>        String[][] str=&#123;&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,&#125;,&#123;<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>,&#125;,&#123;<span class="hljs-string">&quot;g&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;i&quot;</span>&#125;&#125;;<br><br>            <span class="hljs-comment">//遍历str方法1:利用两层for循环。</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.length;i++)&#123;<span class="hljs-comment">//i控制一维数组。</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;str[i].length;j++)&#123;<span class="hljs-comment">//j遍历每个一维数组的元素</span><br>            System.out.println(<span class="hljs-string">&quot; str[&quot;</span> + i + <span class="hljs-string">&quot;][&quot;</span> + j + <span class="hljs-string">&quot;]=&quot;</span> + str[i][j]);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">//遍历str方法2:利用foreach循环。</span><br>            <span class="hljs-comment">//for each不能自动处理二维数组的每一个元素，它是按照行处理。就是按照一维数组处理的。所以要访问二维数组</span><br>            <span class="hljs-comment">//必须使用两个嵌套的循环。</span><br>            <span class="hljs-keyword">for</span>(String []  row : str )&#123;<br>                <span class="hljs-keyword">for</span>(String s : row)&#123;<br>                    System.out.println(s);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//遍历str方法3:想要快速地打印一个二维数组的数据元素列表，可以直接调用</span><br>            System.out.println(Arrays.deepToString(str));<br>     &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-20-toCharArray-方法"><a href="#2-20-toCharArray-方法" class="headerlink" title="2.20  toCharArray() 方法"></a>2.20  toCharArray() 方法</h3><p>public char[] toCharArray()</p><p>toCharArray() 方法将字符串转换为字符数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">Str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;www.runoob.com&quot;</span>);<br><br>        System.out.print(<span class="hljs-string">&quot;返回值 :&quot;</span> );<br>        System.out.println( Str.toCharArray() );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-21-将数字转为字符串"><a href="#2-21-将数字转为字符串" class="headerlink" title="2.21 将数字转为字符串"></a>2.21 将数字转为字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><br><span class="hljs-type">int</span> n= <span class="hljs-number">12</span>;<br><br>方法一:通过包装类来实现<span class="hljs-type">String</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> String.valueOf(n);<br><br>方法二:直接通过空字符串+数字的形式转换为字符串String ss= <span class="hljs-string">&quot;&quot;</span>+n;<br><br>方法三:强制类型转换String ss= （String）n;<br><br></code></pre></td></tr></table></figure><h3 id="2-22-集合的扩容机制"><a href="#2-22-集合的扩容机制" class="headerlink" title="2.22 集合的扩容机制"></a>2.22 集合的扩容机制</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs txt">以下就是List下的三个实现类集合ArrayList 和Vector，LinkedList扩容总结：<br><br>ArrayList 和Vector扩容机制总结：<br>ArrayList 和Vector,底层都是Object数组，默认加载因子都是1（元素满了才扩展容量）.默认容量都是10；但是ArrayList 在jdk1.8时默认为空，当添加元素时，才初始化为10个容量。ArrayList：新容量为原容量的1.5倍，Vector:新容量为原容量的2倍.<br><br>ArrayList 默认初始容量为10，（jdk8的时候底层Object[] elementData数组初始化为&#123;&#125;，并没有创建长度为10的数组。在add元素时才创建了10个容量。）<br>线程不安全，查询速度快<br>　　　　底层数据结构是数组结构<br>　　　　扩容增量：原容量的 0.5倍，新容量为原容量的1.5倍。<br>　　　　如 ArrayList的容量为10，一次扩容后是容量为15<br><br>同样可以通过分析源码知道：<br>Vector：<br>默认初始容量为10，（jdk7和jdk8一样都初始容量为10）。<br>线程安全，但速度慢<br>　　　　底层数据结构是数组结构<br>　　　　加载因子为1：即当 元素个数 超过 容量长度 时，进行扩容<br>　　　　扩容增量：原容量的 1倍，新容量为原容量的2倍。<br>　　　　如 Vector的容量为10，一次扩容后是容量为20<br><br>LinkedList没有扩容机制：<br>LinkedList：没有扩容机制，因为其底层是双向链表结构。不存在数组的扩容一说，没有初始化大小，也没有扩容的机制，就是一直在前面或者后面新增就好。。<br><br>总结二：Set下的三个实现类集合HashSet和LinkedHashSet，TreeSet，扩容总结:LinkedHashSet，TreeSet没有数组的扩容机制。<br><br>HashSet和HashMap扩容机制总结：<br>HashSet和HashMap都是默认初始容量是16（jdk1.7的），但是jdk1.8做了优化，初始容量为0，第一次存元素的时候才扩容为16，加载因子是0.75，扩容为原来的2倍。而带LinkedHashSet和LinkedHashMap是链表不存在扩容的，HashSet:底层是数组+链表的结构。<br><br>Set(集) 元素无序的、不可重复。<br>HashSet：线程不安全，存取速度快<br>　　　　　底层实现是一个HashMap（保存数据）,HashSet:底层是数组+链表的结构，实现Set接口<br>　　　　　默认初始容量为16（jdk1.8及以后）（为何是16，见下方对HashMap的描述）<br>　　　　　加载因子为0.75：即当 元素个数 超过 容量长度的0.75倍 时，进行扩容<br>　　　　　扩容增量：原容量的 1 倍，新容量为原容量的2倍。<br>　　　　　　如 HashSet的容量为16，一次扩容后是容量为32。<br>　　　　　　因为构造一个HashSet，其实相当于新建一个HashMap，然后取HashMap的Key。<br>扩容机制和HashMap一样。<br><br>Map是一个双列集合:<br>HashMap：jdk1.8默认初始容量0,当第一次put元素的时候才扩容为16，jdk1.7是初始化容量为16<br>　　　　　（为何是16：16是2^4，可以提高查询效率，另外，32=16&lt;&lt;1 –&gt;至于详细的原因可另行分析，或分析源代码）<br>　　　　　加载因子为0.75：即当 元素个数 超过 容量长度的0.75倍 时，进行扩容<br>　　　　　扩容增量：原容量的 1 倍，新容量为原容量的2倍。<br>　　　　　　如 HashSet的容量为16，一次扩容后是容量为32<br><br>Hashtable扩容机制：<br>public Hashtable() &#123;<br>        this(11, 0.75f);<br>    &#125;<br>1<br>2<br>3<br>Hashtable默认初始容量11。<br>二、扩容加载因子(0.75)，当超出默认长度（int）（11*0.75）=8时，扩容为oldx2+1。新容量为原容量的2倍+1.<br>int newCapacity = (oldCapacity &lt;&lt; 1) + 1;<br>　　　　　　<br>总结：<br>1.HashMap如果用默认构造方法的话，HashMap开始容量为0，第一次put元素的时候才扩容为16；<br>2.HashMap使用有参构造方法的话，HashMap容量并不是我们参数给定的大小，而是大于等于给定容量参数的 最接近 2的次幂。如我们给定容量为7，则是2的3次幂，即8容量，因为2的次幂可以通过右移快速得到。<br>3.扩容为原来的2n<br><br>1HashTable如果使用默认的构造方法的话，初始容量为11；<br>2.HashTable如果使用有参构造方法的话，初始容量即为给定的参数容量值，如3,7等就直接用了；<br>3.扩容为原来的2n+1<br><br>小结：HashTable和HashMap区别<br>第一，继承不同。<br>public class Hashtable extends Dictionary implements Map<br>public class HashMap extends AbstractMap implements Map<br>第二：<br>Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用<br>Hashtable，但是要使用HashMap的话就要自己增加同步处理了。<br>第三，Hashtable中，key和value都不允许出现null值。<br>在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，<br>即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中<br>是否存在某个键， 而应该用containsKey()方法来判断。<br>第四，两个遍历方式的内部实现上不同。<br>Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。<br>第五，哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。<br>第六，Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old2+1。HashMap中hash数组的默认大小是16， 增加的方式是 old2。<br><br>小结:StringBuffer和StringBuilder：<br>StringBuilder和StringBuffer的初始容量都是16,程序猿尽量手动设置初始值。以避免多次扩容所带来的性能问题，默认数组容量扩充为原数组容量的2倍+2。<br><br>1.StringBuilder是jdk1.5引进的，而StringBuffer在1.0就有了；<br>2.StringBuilder和StringBuffer都是可变的字符串。能够通过append或者insert等方法改动串的内容；<br>3.StringBuffer是线程安全的而StringBuilder不是，因而在多线程的环境下优先使用StringBuffer，而其它情况下推荐使用<br>StringBuilder，由于它更快。<br>4.StringBuilder和StringBuffer都继承自AbstractStringBuilder类，AbStractStringBuilder主要实现了扩容、append、<br>insert方法。StrngBuilder和StringBuffer的相关方法都直接调用的父类。<br>5.StringBuilder和StringBuffer的初始容量都是16,程序猿尽量手动设置初始值。以避免多次扩容所带来的性能问题；<br>6.StringBuilder和StringBuffer的扩容机制是这种：首先试着将当前数组容量扩充为原数组容量的2倍加上2，假设这个新容<br>量仍然小于预定的最小值（minimumCapacity），那么就将新容量定为（minimumCapacity），最后推断是否溢出，若溢出，<br>则将容量定为整型的最大值0x7fffffff。<br></code></pre></td></tr></table></figure><h3 id="2-23-Collections方法"><a href="#2-23-Collections方法" class="headerlink" title="2.23 Collections方法"></a>2.23 Collections方法</h3><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Collections.html#reverseOrder()">https://www.runoob.com/manual/jdk11api/java.base/java/util/Collections.html#reverseOrder()</a></p><p><a href="https://vimsky.com/examples/usage/java-collections-reverseorder-method-01.html">Java Collections reverseOrder()用法及代码示例</a></p><h3 id="2-24-String方法"><a href="#2-24-String方法" class="headerlink" title="2.24 String方法"></a>2.24 String方法</h3><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/lang/String.html">https://www.runoob.com/manual/jdk11api/java.base/java/lang/String.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//contains方法</span><br><span class="hljs-comment">//contains() 方法用于判断字符串中是否包含指定的字符或字符串。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">myStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Runoob&quot;</span>;<br>        System.out.println(myStr.contains(<span class="hljs-string">&quot;Run&quot;</span>));<br>        System.out.println(myStr.contains(<span class="hljs-string">&quot;o&quot;</span>));<br>        System.out.println(myStr.contains(<span class="hljs-string">&quot;s&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-25-Java-printf-用法"><a href="#2-25-Java-printf-用法" class="headerlink" title="2.25 Java printf 用法"></a>2.25 Java printf 用法</h3><p><a href="https://www.runoob.com/w3cnote/java-printf-formate-demo.html">https://www.runoob.com/w3cnote/java-printf-formate-demo.html</a></p><h3 id="2-26-java四舍五入"><a href="#2-26-java四舍五入" class="headerlink" title="2.26  java四舍五入"></a>2.26  java四舍五入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 四舍五入到指定位数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">roundToDecimals</span><span class="hljs-params">(<span class="hljs-type">double</span> value, <span class="hljs-type">int</span> decimals)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">powerOfTen</span> <span class="hljs-operator">=</span> Math.pow(<span class="hljs-number">10</span>, decimals);<br>        <span class="hljs-keyword">return</span> Math.round(value * powerOfTen) / powerOfTen;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigDecimal;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoundDecimal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 假设输入是以字符串形式传递的</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1.2&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1.23&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 保留小数点后k位</span><br><br>        <span class="hljs-comment">// 将字符串转换为 BigDecimal 类型以进行精确计算</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">decimalNum1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(num1);<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">decimalNum2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(num2);<br><br>        <span class="hljs-comment">// 计算两个小数的和</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> decimalNum1.add(decimalNum2);<br><br>        <span class="hljs-comment">// 对结果进行四舍五入，保留小数点后k位</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">roundedResult</span> <span class="hljs-operator">=</span> sum.setScale(k, BigDecimal.ROUND_HALF_UP);<br><br>        <span class="hljs-comment">// 将结果以浮点数形式输出</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> roundedResult.doubleValue();<br>        System.out.println(result);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//BigDecimal 中的 ROUND_HALF_UP 是一种四舍五入的模式，它会将小数四舍五入到最接近的值，并且在五后有数字时将舍入值加1</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoundDecimalWithoutBigDecimal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 假设输入是以字符串形式传递的</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1.2&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1.23&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 保留小数点后k位</span><br><br>        <span class="hljs-comment">// 将字符串转换为浮点数</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">doubleNum1</span> <span class="hljs-operator">=</span> Double.parseDouble(num1);<br>        <span class="hljs-type">double</span> <span class="hljs-variable">doubleNum2</span> <span class="hljs-operator">=</span> Double.parseDouble(num2);<br><br>        <span class="hljs-comment">// 计算两个小数的和</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> doubleNum1 + doubleNum2;<br><br>        <span class="hljs-comment">// 进行四舍五入，保留小数点后k位</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">roundedResult</span> <span class="hljs-operator">=</span> roundToDecimals(sum, k);<br><br>        <span class="hljs-comment">// 将结果以浮点数形式输出</span><br>        System.out.println(roundedResult);<br>    &#125;<br><br>    <span class="hljs-comment">// 四舍五入到指定位数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">roundToDecimals</span><span class="hljs-params">(<span class="hljs-type">double</span> value, <span class="hljs-type">int</span> decimals)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">powerOfTen</span> <span class="hljs-operator">=</span> Math.pow(<span class="hljs-number">10</span>, decimals);<br>        <span class="hljs-keyword">return</span> Math.round(value * powerOfTen) / powerOfTen;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-27-Java-Comparator"><a href="#2-27-Java-Comparator" class="headerlink" title="2.27 Java Comparator"></a>2.27 Java Comparator</h3><p><a href="https://blog.csdn.net/Madoka_Homura/article/details/107382799">Java Comparator使用指南 —- 看这一篇就够了_comparator接口-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_31635851/article/details/120269813">【Java 8 新特性】Java Comparator | 比较器-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/311621697">java8-Lambda中比较器Comparator的使用 - 知乎 (zhihu.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-comment">// 读取整数个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br><br>        <span class="hljs-comment">// 读取整数数组</span><br>        Integer[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            arr[i] = scanner.nextInt();<br>        &#125;<br><br>        <span class="hljs-comment">// 自定义排序规则</span><br>        Arrays.sort(arr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer a, Integer b)</span> &#123;<br>                <span class="hljs-comment">// 提取后三位数字进行比较</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">lastThreeA</span> <span class="hljs-operator">=</span> a % <span class="hljs-number">1000</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">lastThreeB</span> <span class="hljs-operator">=</span> b % <span class="hljs-number">1000</span>;<br>                <span class="hljs-keyword">return</span> Integer.compare(lastThreeB, lastThreeA); <span class="hljs-comment">// 从大到小排序</span><br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 输出排序后的数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            System.out.print(arr[i] + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-comment">// 读取整数个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> in.nextInt();<br><br>        <span class="hljs-comment">// 创建 Integer 数组来存储输入的整数</span><br>        Integer[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[n];<br><br>        <span class="hljs-comment">// 循环读取并存储输入的整数到数组中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            a[i] = in.nextInt();<br>        &#125;<br><br>        <span class="hljs-comment">// 使用 Arrays.sort 对整数数组进行排序，根据后三位数字从大到小</span><br>        Arrays.sort(a, (x, y) -&gt; &#123; <span class="hljs-keyword">return</span> (y % <span class="hljs-number">1000</span>) - (x % <span class="hljs-number">1000</span>); &#125;);<br><br>        <span class="hljs-comment">// 输出排序后的数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            System.out.print(a[i] + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//(y % 1000) - (x % 1000)：这个表达式会按照 y 的后三位数字减去 x 的后三位数字进行比较。如果结果为正数，表示 y 的后三位数字大于 x 的后三位数字，排序时 y 会排在 x 的前面，即按照从大到小排序。</span><br><span class="hljs-comment">//(x % 1000) - (y % 1000)：这个表达式会按照 x 的后三位数字减去 y 的后三位数字进行比较。如果结果为正数，表示 x 的后三位数字大于 y 的后三位数字，排序时 x 会排在 y 的前面，即按照从小到大排序。</span><br></code></pre></td></tr></table></figure><h3 id="2-28-hasNext、hasNextLine、next、nextLine保姆级详解"><a href="#2-28-hasNext、hasNextLine、next、nextLine保姆级详解" class="headerlink" title="2.28 hasNext、hasNextLine、next、nextLine保姆级详解"></a>2.28 hasNext、hasNextLine、next、nextLine保姆级详解</h3><p><a href="https://blog.csdn.net/m0_56079407/article/details/120576881">https://blog.csdn.net/m0_56079407/article/details/120576881</a></p><h3 id="2-29IntelliJ-IDEA快捷键大全-动图演示"><a href="#2-29IntelliJ-IDEA快捷键大全-动图演示" class="headerlink" title="2.29IntelliJ IDEA快捷键大全 + 动图演示"></a>2.29IntelliJ IDEA快捷键大全 + 动图演示</h3><p><a href="https://zhuanlan.zhihu.com/p/615560482">https://zhuanlan.zhihu.com/p/615560482</a></p><h3 id="2-30-Eclipse-快捷键"><a href="#2-30-Eclipse-快捷键" class="headerlink" title="2.30 Eclipse 快捷键"></a>2.30 Eclipse 快捷键</h3><p><a href="https://zhuanlan.zhihu.com/p/117582747">https://zhuanlan.zhihu.com/p/117582747</a></p><h3 id="2-31-List-与-new-ArrayList＜＞-与-List"><a href="#2-31-List-与-new-ArrayList＜＞-与-List" class="headerlink" title="2.31 List 与 new ArrayList＜＞() 与 List&lt;List&lt;String"></a>2.31 List 与 new ArrayList＜＞() 与 List&lt;List&lt;String</h3><p><a href="https://blog.csdn.net/weixin_46225503/article/details/135025590">我们为什么经常使用List list &#x3D; new ArrayList＜＞() 而不是ArrayListlist &#x3D; new ArrayList＜＞()-CSDN博客</a></p><p>List&lt;List<String>&gt; lists &#x3D; new ArrayList&lt;List<String>&gt;();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">lists 是一个变量，它是一个列表（List）的列表（List）的数据结构。 这意味着它可以存储多个列表，每个列表中又可以存储多个字符串元素。<br><br>在你的代码中，lists 是一个 List&lt;List&lt;String&gt;&gt; 类型的变量。 这意味着它是一个列表，其中每个元素都是一个列表，而每个内部列表中的元素都是字符串类型。<br><br>你可以通过使用 lists 来存储和操作多个列表，每个列表可以具有不同的长度和字符串元素。<br><br>例如，你可以向 lists 添加新的列表：<br><br>List&lt;String&gt; innerList1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>innerList1.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>innerList1.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>innerList1.add(<span class="hljs-string">&quot;Orange&quot;</span>);<br><br>List&lt;String&gt; innerList2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>innerList2.add(<span class="hljs-string">&quot;Cat&quot;</span>);<br>innerList2.add(<span class="hljs-string">&quot;Dog&quot;</span>);<br>innerList2.add(<span class="hljs-string">&quot;Bird&quot;</span>);<br><br>lists.add(innerList1);<br>lists.add(innerList2);<br>现在，lists 中包含了两个列表。 你可以使用索引访问它们：<br><br>List&lt;String&gt; firstList = lists.get(<span class="hljs-number">0</span>);<br>System.out.println(firstList); <span class="hljs-comment">// 输出: [Apple, Banana, Orange]</span><br><br>List&lt;String&gt; secondList = lists.get(<span class="hljs-number">1</span>);<br>System.out.println(secondList); <span class="hljs-comment">// 输出: [Cat, Dog, Bird]</span><br></code></pre></td></tr></table></figure><h3 id="2-32-Deque-deque-new-LinkedList"><a href="#2-32-Deque-deque-new-LinkedList" class="headerlink" title="2.32 Deque deque &#x3D; new LinkedList&lt;&gt;();"></a>2.32 Deque deque &#x3D; new LinkedList&lt;&gt;();</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">Deque&lt;String&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>通过使用LinkedList&lt;&gt;()时，您正在创建一个LinkedList使用 type 参数String.这意味着deque变量将能够存储和操作字符串的集合。<br><br>一个Deque是一个双端队列，这意味着您可以从两端添加或删除元素。这LinkedList实现是一个不错的选择Deque因为它在两端都提供了高效的插入和删除操作。<br><br>deque.addFirst(<span class="hljs-string">&quot;First&quot;</span>);<br>deque.addLast(<span class="hljs-string">&quot;Last&quot;</span>);<br><br>System.out.println(deque); <span class="hljs-comment">// Output: [First, Last]</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">firstElement</span> <span class="hljs-operator">=</span> deque.removeFirst();<br><span class="hljs-type">String</span> <span class="hljs-variable">lastElement</span> <span class="hljs-operator">=</span> deque.removeLast();<br><br>System.out.println(firstElement); <span class="hljs-comment">// Output: First</span><br>System.out.println(lastElement); <span class="hljs-comment">// Output: Last</span><br><br>通过使用 `<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(deque)`，你会创建一个新的 `ArrayList` 对象，并将其中的元素初始化为 `deque` 中的元素。 这样，你就可以通过这个新的`ArrayList` 对象来访问和操作 `deque` 中的元素。<br><br>请注意，这个转换过程不会改变 `deque` 本身的类型或其内部的元素。 它只是创建了一个新的`ArrayList` 对象，并将 `deque` 的元素复制到新的对象中。<br><br>例如，假设你有一个 `Deque` 对象 `deque` 包含以下元素：<br><br>复制<br><br>```<br>deque: [Apple, Banana, Orange]<br>```<br><br>当你执行 `<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(deque)` 时，将会创建一个新的 `ArrayList` 对象，并将其中的元素初始化为 `deque` 中的元素。 这样，你就可以使用这个新的`ArrayList` 对象来操作 `deque` 中的元素，比如访问、添加或删除元素。<br></code></pre></td></tr></table></figure><h3 id="2-33-Java8-Stream-API-之-IntStream-用法全解"><a href="#2-33-Java8-Stream-API-之-IntStream-用法全解" class="headerlink" title="2.33 Java8 Stream API 之 IntStream 用法全解"></a>2.33 Java8 Stream API 之 IntStream 用法全解</h3><p><a href="https://blog.csdn.net/qq_31865983/article/details/106443244">https://blog.csdn.net/qq_31865983/article/details/106443244</a></p><p><a href="https://www.jianshu.com/p/461429a5edc9">https://www.jianshu.com/p/461429a5edc9</a></p><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/stream/IntStream.html">https://www.runoob.com/manual/jdk11api/java.base/java/util/stream/IntStream.html</a></p><h3 id="2-34-Java-8-Stream"><a href="#2-34-Java-8-Stream" class="headerlink" title="2.34 Java 8 Stream"></a>2.34 Java 8 Stream</h3><p><a href="https://www.runoob.com/java/java8-streams.html">Java 8 Stream | 菜鸟教程 (runoob.com)</a></p><p><a href="https://juejin.cn/post/6990525607188627486">Java8 Stream 用法大全 - 掘金 (juejin.cn)</a></p><h3 id="2-35-LinkedList转换为数组-数组转换为LinkedList"><a href="#2-35-LinkedList转换为数组-数组转换为LinkedList" class="headerlink" title="2.35 LinkedList转换为数组,数组转换为LinkedList"></a>2.35 LinkedList转换为数组,数组转换为LinkedList</h3><p><a href="https://www.niaoge.com/java/java-examples-linkedlist-array-conversion.html">Java程序将LinkedList转换为数组,数组转换为LinkedList - Java教程 - 鸟哥教程 (niaoge.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    LinkedList&lt;String&gt; languages= <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//在链表中添加元素</span><br>    languages.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>    languages.add(<span class="hljs-string">&quot;Python&quot;</span>);<br>    languages.add(<span class="hljs-string">&quot;JavaScript&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;LinkedList: &quot;</span> + languages);<br><br>    <span class="hljs-comment">//创建一个新的String类型数组</span><br>    String[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[languages.size()];<br><br>    <span class="hljs-comment">//将LinkedList转换为字符串数组</span><br>    languages.toArray(arr);<br>    System.out.print(<span class="hljs-string">&quot;Array: &quot;</span>);<br>    <span class="hljs-keyword">for</span>(String item:arr) &#123;<br>      System.out.print(item+<span class="hljs-string">&quot;, &quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br><br>LinkedList: [Java, Python, JavaScript]<br>Array: Java, Python, JavaScript,<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-comment">//创建一个数组</span><br>    String[] array = &#123;<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;;<br>    System.out.println(<span class="hljs-string">&quot;Array: &quot;</span> + Arrays.toString(array));<br><br>    <span class="hljs-comment">//将数组转换为链表</span><br>    LinkedList&lt;String&gt; languages= <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(Arrays.asList(array));<br><br>    System.out.println(<span class="hljs-string">&quot;LinkedList: &quot;</span> + languages);<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-36-java的lambda表达式"><a href="#2-36-java的lambda表达式" class="headerlink" title="2.36 java的lambda表达式"></a>2.36 java的lambda表达式</h3><p><a href="https://www.runoob.com/java/java8-lambda-expressions.html">Java Lambda 表达式 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://blog.csdn.net/weixin_40979518/article/details/118546367">java8中的lambda表达式，看这篇就够了_java8 lambda-CSDN博客</a></p><h1 id="3-选择题"><a href="#3-选择题" class="headerlink" title="3.选择题"></a>3.选择题</h1><h2 id="3-1-命名"><a href="#3-1-命名" class="headerlink" title="3.1 命名"></a>3.1 命名</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">如果一个Java文件内定义了多个类，关于该文件的命名，以下表述必须是正确的（D）<br><br>A以调用或继承系统最高的类命名<br><br>B如果有多个公共修饰的类，则这些类名可以做文件名<br><br>C可使用第一个或者最后一个类的类名命名<br><br>D如果没有公共类，可以随意命名 <br><br>因为如果没有公共类，那么这个文件实际上是一个独立的模块或者组件，可以以任意名称进行命名。<br></code></pre></td></tr></table></figure><h2 id="3-2-线程"><a href="#3-2-线程" class="headerlink" title="3.2 线程"></a>3.2 线程</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">小明使用Java编写一段代码，实现每隔一小时查询某变量的值，并且不影响程序运行，最准确且合理的方法是（C）<br><br>A启动一个新线程，在其中设置如下循环：查询该变量；使用sleep()方法延迟1小时<br><br>B启动一个新线程，在其中设置如下循环：查询该变量；使用yield()方法延迟1小时<br><br>C使用timer.schedule（），每小时启动一个线程，在新线程中查询该变量，之后立刻关闭。<br><br>D启动一个新线程，在其中以不停顿地循环查询系统时间与上一次查询时间求差，得到差值等于1小时则查询该变量<br><br>根据题意，我们需要实现每隔一小时查询一次某个变量的值，同时不影响程序的运行。最准确且合理的方法是使用定时器（timer.schedule()）来每小时启动一个线程，在新线程中查询该变量，之后立即关闭。<br></code></pre></td></tr></table></figure><h2 id="3-3-classpath"><a href="#3-3-classpath" class="headerlink" title="3.3 classpath"></a>3.3 classpath</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">下面关于 classpath 的说法中，错误的是(D)。<br><br>A、classpath 和 path 环境变量的查看与配置的方式完全相同。<br><br>B、为了让 Java 虚拟机能找到所需的 class 文件，就需要对 classpath 环境变量进行设置。<br><br>C、从 JDK5.0 开始，如果 classpath 环境变量没有进行设置， Java 虚拟机会自动将其设置为“.”，也就是当前目录。<br><br>D、在命令行窗口中配置了 classpath 后，重新打开新命令行窗口依然生效。<br><br>当你在一个命令行窗口中配置了 classpath 环境变量后，这个设置只会在当前窗口的环境中生效。如果你关闭了当前窗口并重新打开一个新的命令行窗口，之前设置的 classpath 不会自动应用到新窗口中。 若要在新窗口中使用相同的 classpath 设置，你需要手动重新配置或者在系统中永久地设置该环境变量。<br></code></pre></td></tr></table></figure><h2 id="3-4-扩容"><a href="#3-4-扩容" class="headerlink" title="3.4  扩容"></a>3.4  扩容</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">对于 Set set = new HashSet&lt;&gt;(32); 扩容的次数为（A）<br><br>A、0<br>B、1<br>C、2<br>D、3<br><br>这段代码中创建了一个初始容量为32的HashSet实例。HashSet在内部使用哈希表实现，当元素数量超过负载因子（load factor） * 容量时，会进行扩容。负载因子是0.75，也就是说，在元素数量达到容量的75%时会触发扩容操作。<br>考虑到初始容量为32，HashSet的默认负载因子为0.75，扩容的触发点是在元素数量达到 32 * 0.75 = 24 时。因此，当向这个HashSet中添加至少25个元素时，就会触发扩容操作。而现在元素容量为0，则不会扩容<br></code></pre></td></tr></table></figure><h2 id="3-5-变量与对象"><a href="#3-5-变量与对象" class="headerlink" title="3.5  变量与对象"></a>3.5  变量与对象</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs txt">设有下面两个赋值语句：a = Integer.parseInt(“12”);b = Integer.valueOf(“12”).intValue();<br>下述说法正确的是（  D   ）。<br>A、a 是整数类型变量，b 是整数类对象<br>B、a 是整数类对象，b 是整数类型变量<br>C、a 和 b 都是整数类对象并且值相等<br>D、a 和 b 都是整数类型变量并且值相等<br><br>a = Integer.parseInt(&quot;12&quot;);<br>这行代码将字符串 &quot;12&quot; 解析为整数，并将结果赋给变量 a。Integer.parseInt 方法将字符串转换为整数类型（int）。<br>b = Integer.valueOf(&quot;12&quot;).intValue();<br>这行代码首先使用 Integer.valueOf(&quot;12&quot;) 将字符串 &quot;12&quot; 转换为对应的整数对象 Integer，然后通过 intValue() 方法获取其整数值，并将结果赋给变量 b。Integer.valueOf(&quot;12&quot;) 返回的是一个 Integer 对象，通过 intValue() 获取其整数值。<br>所以，a 被赋值为整数类型的值 12，而 b 是通过 intValue() 方法获取整数值的方式获得值为 12 的整数类型。<br><br></code></pre></td></tr></table></figure><h2 id="3-6-异常"><a href="#3-6-异常" class="headerlink" title="3.6 异常"></a>3.6 异常</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">以下关于 Error、Exception 和 RuntimeException 的说法错误的是：(D)<br><br>A、Error 和 Exception 都是 Throwable 的子类<br><br>B、RuntimeException 是 Exception 的子类<br><br>C、Error 用于指示合理的应用程序不应该视图捕获的错误<br><br>D、RuntimeException 是未检查异常，需要 try catch 或在方法上声明<br><br>因为虽然RuntimeException是未检查异常，但它并不需要强制使用try-catch块或在方法上声明。<br></code></pre></td></tr></table></figure><h2 id="3-7-覆盖-重写）和重载"><a href="#3-7-覆盖-重写）和重载" class="headerlink" title="3.7 覆盖(重写）和重载"></a>3.7 覆盖(重写）和重载</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs txt">覆盖与重载的关系是（A）<br><br>A、覆盖只有发生在父类与子类之间，而重载可以发生在同一个类中<br><br>B、覆盖方法可以不同名，而重载方法必须同名<br><br>C、final 修饰的方法可以被覆盖，但不能被重载<br><br>D、覆盖与重载是同一回事<br><br>覆盖是指子类重新定义了父类的方法，使用相同的方法名和参数列表，以实现多态性。<br>重载是指在同一个类中使用相同的方法名，但是参数列表不同，用于提供不同的方法实现。<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-考试总结&quot;&gt;&lt;a href=&quot;#1-考试总结&quot; class=&quot;headerlink&quot; title=&quot;1.考试总结&quot;&gt;&lt;/a&gt;1.考试总结&lt;/h1&gt;&lt;h2 id=&quot;1-1-变量的命名&quot;&gt;&lt;a href=&quot;#1-1-变量的命名&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="java总结" scheme="http://example.com/categories/java%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>python总结</title>
    <link href="http://example.com/2024/01/30/python%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2024/01/30/python%E6%80%BB%E7%BB%93/</id>
    <published>2024-01-30T07:30:22.000Z</published>
    <updated>2024-01-30T13:35:25.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python考试总结"><a href="#python考试总结" class="headerlink" title="python考试总结"></a>python考试总结</h1><h2 id="一-程序设计基本方法"><a href="#一-程序设计基本方法" class="headerlink" title="一.程序设计基本方法"></a>一.程序设计基本方法</h2><h3 id="1-计算机的概念"><a href="#1-计算机的概念" class="headerlink" title="1.计算机的概念"></a>1.计算机的概念</h3><p>计算机是根据指令操作数据的设备</p><p>具备两个基本特性</p><p>   功能性</p><p>   对数据的操作，表现为数据计算、输入输出处理和结果存储等。</p><p>   可编程性</p><p>   根据一系列指令自动地、可预测地、准确地完成操作者的意图  </p><p>Python语言诞生于1990年，它是最流行最好用的编程语言</p><h3 id="2-机器语言"><a href="#2-机器语言" class="headerlink" title="2.机器语言"></a>2.机器语言</h3><p>机器语言是一种二进制语言，它直接使用二进制代码表达指令，是计算机硬件可以直接识别和执行的程序设计语言。</p><h3 id="3-汇编语言"><a href="#3-汇编语言" class="headerlink" title="3.汇编语言"></a>3.汇编语言</h3><p>使用助记符与机器语言中的指令进行一一对应，在计算机发展早期帮助程序员提高编程效率</p><h3 id="4-高级语言"><a href="#4-高级语言" class="headerlink" title="4.高级语言"></a>4.高级语言</h3><p>高级语言区别于低级语言在于，高级语言是接近自然语言的一种计算机程序设计语言，更容易地描述计算问题并利用计算机解决计算问题</p><h3 id="5-编译和解释"><a href="#5-编译和解释" class="headerlink" title="5.编译和解释"></a>5.编译和解释</h3><p>编译是将源代码转换成目标代码的过程，通常，源代码是高级语言代码，目标代码是机器语言代码，执行编译的计算机程序称为编译器</p><p>解释是将源代码逐条转换成目标代码同时逐条运行目标代码的过程。执行解释的计算机程序称为解释器。</p><p>编译是一次性地翻译，一旦程序被编译，不再需要编译程序或者源代码。</p><p>对于相同源代码，编译所产生的目标代码执行速度更快。</p><p>目标代码不需要编译器就可以运行，在同类型操作系统上使用灵活。</p><p>解释则在每次程序运行时都需要解释器和源代码。</p><p>解释执行需要保留源代码，程序纠错和维护十分方便。</p><p>只要存在解释器，源代码可以在任何操作系统上运行，可移植性好 </p><p>高级语言按照计算机执行方式的不同可分成两类</p><p>静态语言</p><p>脚本语言</p><p>这里所说的执行方式指计算机执行一个程序的过程，静态语言采用编译执行，脚本语言采用解释执行</p><p>执行方式不同，优势各有不同</p><p><strong>静态语言</strong> 编译器一次性生成目标代码，优化更充分</p><p>​         程序执行速度更快</p><p><strong>脚本语言</strong> 执行程序时需要源代码，维护更灵活</p><p>​         源代码维护灵活、跨多个操作系统平台</p><h3 id="6-Python语言的诞生"><a href="#6-Python语言的诞生" class="headerlink" title="6.Python语言的诞生"></a>6.Python语言的诞生</h3><p><strong>Python语言</strong>是由荷兰人Guido van Rossum（吉多·范·罗苏姆）于1989年圣诞节期间在阿姆斯特丹休假时为了打发无聊的假期而编写的一种脚本解释程序，1991年Python第一个发行第一个公开版本。**（灵感源于无聊）</p><h3 id="7-python语言特点"><a href="#7-python语言特点" class="headerlink" title="7.python语言特点"></a>7.python语言特点</h3><p> Python语言是通用语言</p><p>Python语言是脚本语言</p><p>Python语言是开源语言</p><p>Python语言是跨平台语言</p><p>Python语言是多模型语言</p><h2 id="二-程序设计基本方法"><a href="#二-程序设计基本方法" class="headerlink" title="二.程序设计基本方法"></a>二.程序设计基本方法</h2><h3 id="1-程序的格式框架"><a href="#1-程序的格式框架" class="headerlink" title="1.程序的格式框架"></a>1.程序的格式框架</h3><p>Python语言采用严格的“缩进”来表明程序的格式框架。缩进指每一行代码开始前的空白区域，用来表示代码之间的包含和层次关系。 </p><p>1个缩进 &#x3D; 4个空格</p><p>用以在Python中标明代码的层次关系</p><p>缩进是Python语言中表明程序框架的唯一手段</p><h3 id="2-注释"><a href="#2-注释" class="headerlink" title="2.注释"></a>2.注释</h3><p>注释：用于提高代码可读性的辅助性文字，不被计算机执行</p><p>注释的两种方法：</p><p>单行注释以#开头</p><p> #Here are the comments</p><p>多行注释以 ’’’开头和结尾</p><p>’’’</p><p> This is a multiline comment</p><p> used in Python</p><p>’’’</p><h3 id="3-命名与保留字"><a href="#3-命名与保留字" class="headerlink" title="3.命名与保留字"></a>3.命名与保留字</h3><p>常量：程序中值不发生改变的元素</p><p>变量：程序中值发生改变或者可以发生改变的元素</p><p>变量命名规则：</p><p>①名称第一字符为英文字母或者下划线</p><p>②名称第一字符后可以使用英文字母、下划线和数字</p><p>③名称不能使用python的关键字或保留字符</p><p>④名称区分大小写，单词与单词之间使用下划线连接</p><p><strong>Python 3.x保留字列表 (33个)</strong></p><table><thead><tr><th>and</th><th>elif</th><th>import</th><th>raise</th></tr></thead><tbody><tr><td>as</td><td>else</td><td>in</td><td>return</td></tr><tr><td>assert</td><td>except</td><td>is</td><td>try</td></tr><tr><td>break</td><td>finally</td><td>lambda</td><td>while</td></tr><tr><td>class</td><td>for</td><td>nonlocal</td><td>with</td></tr><tr><td>continue</td><td>from</td><td>not</td><td>yield</td></tr><tr><td>def</td><td>global</td><td>or</td><td>True</td></tr><tr><td>del</td><td>if</td><td>pass</td><td>False</td></tr><tr><td></td><td></td><td></td><td>None</td></tr></tbody></table><p><strong>keyword</strong>包是Python预制的保留关键字及其相关操作的内置库。</p><p>import keyword </p><p>keyword.kwlist</p><p>keyword.ifkeyword(‘pass’)</p><h3 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4.数据类型"></a>4.数据类型</h3><p><strong>包含数据类型：字符串、整数、浮点数、列表</strong></p><p><strong>变量：</strong>指向对象的引用。Python属于动态类型定义语言，即变量不需要显式声明数据类型。根据变量的赋值，Python解释器会自动确定其数据类型。如此，变量仅仅是指向某个对象，其类型是由对象本身确定。Python也是一种强类型语言，即某个变量指向的对象均属于某个数据类型。</p><p><strong>字符串</strong></p><p>Python语言中，字符串是用两个双引号“ ”或者单引号‘ ’括起来的一个或多个字符。</p><p>Python字符串的两种序号体系</p><p><img src="https://pic.imgdb.cn/item/65b8eddf871b83018a25211a.png" alt="字符串"></p><h3 id="5-字符串的使用"><a href="#5-字符串的使用" class="headerlink" title="5.字符串的使用"></a>5.<strong>字符串的使用</strong></h3><p>使用[ ]获取字符串中一个或多个字符</p><p>-索引：返回字符串中单个字符&lt;字符串&gt;[M]</p><p>​       TempStr[-1]</p><p>-切片：返回字符串中一段字符子串&lt;字符串&gt;[M:N]</p><p>​    TempStr[0:-1]</p><h3 id="6-列表类型"><a href="#6-列表类型" class="headerlink" title="6.列表类型"></a>6.<strong>列表类型</strong></h3><p>由0个或多个数据组成的有序序列</p><p>-列表使用[]表示，采用逗号分隔各元素       </p><p>​    [‘F’,’f’]表示两个元素’F’和’f’</p><p>-使用保留字in判断一个元素是否在列表中</p><p>   TempStr[-1] in [‘F’,’f’]</p><h3 id="7-赋值语句"><a href="#7-赋值语句" class="headerlink" title="7.赋值语句"></a>7.<strong>赋值语句</strong></h3><p> Python语言中，&#x3D; 表示“赋值”，即将等号右侧的值计算后将结果值赋给左侧变量，包含等号（&#x3D;）的语句称为“赋值语句”</p><p><strong>同步赋值语句</strong>：同时给多个变量赋值 </p><p>&lt;变量1&gt;, …, &lt;变量N&gt; &#x3D; &lt;表达式1&gt;, …, &lt;表达式N&gt;</p><p>将变量x和y交换</p><p>n采用单个赋值，需要3行语句：</p><p>即通过一个临时变量t缓存x的原始值，然后将y值赋给x，再将x的原始值通过t赋值给y。</p><p>采用同步赋值语句，仅需要一行代码</p><p><img src="https://pic.imgdb.cn/item/65b8eddf871b83018a25217d.png" alt="赋值语句"></p><h3 id="8-input-函数"><a href="#8-input-函数" class="headerlink" title="8.input()函数"></a>8.<strong>input()函数</strong></h3><p>获得用户输入之前，input()函数可以包含一些提示性文字 </p><p>​        &lt;变量&gt; &#x3D; input(&lt;提示性文字&gt;)</p><h3 id="9-分支语句"><a href="#9-分支语句" class="headerlink" title="9.分支语句"></a>9.<strong>分支语句</strong></h3><p>分支语句是控制程序运行的一类重要语句，它的作用是根据判断条件选择程序执行路径，使用方式如下：</p><p>if &lt;条件1&gt;:</p><p>  &lt;语句块1&gt;</p><p>elif &lt;条件2&gt;:</p><p>  &lt;语句块2&gt;</p><p>…</p><p>else:</p><p>  &lt;语句块N&gt;</p><h3 id="10-eval（）函数"><a href="#10-eval（）函数" class="headerlink" title="10.eval（）函数"></a>10.<strong>eval（）函数</strong></h3><p>eval(&lt;字符串&gt;)函数是Python语言中一个十分重要的函数，它能够以Python表达式的方式解析并执行字符串，将返回结果输出</p><p><strong>去掉参数最外侧引号并执行余下语句的函数</strong></p><p><strong>输出函数print（）</strong></p><p>以字符形式向控制台输出结果的函数</p><p><strong>格式化函数format（）</strong></p><p>将字符串格式化&lt;字符串&gt;.format()</p><h3 id="11-turtle库和蟒蛇绘制程序"><a href="#11-turtle库和蟒蛇绘制程序" class="headerlink" title="11.turtle库和蟒蛇绘制程序"></a>11.<strong>turtle库和蟒蛇绘制程序</strong></h3><p><strong>Turtle库</strong></p><p>Turtle（海龟）库是Python语言中一个很流行的绘制图像的函数库</p><p>Turtle绘图体系：1969年诞生，入门级图形绘制函数库</p><p>Python语言的标准库之一</p><p>使用turtle库，同学们头脑里需要有这样一个概念：</p><p>-想象一个小乌龟，在一个横轴为x、纵轴为y的坐标系原点，(0,0)位置开始</p><p>-根据一组函数指令的控制，在这个平面坐标系中移动，从而在它爬行的路径上绘制了图形</p><p><strong>Turtle的绘图窗体</strong></p><p>Turtle.setup(width,height,startx,starty)</p><p>-setup()设置窗体大小及位置，不是必须的</p><p>Turtle.goto(x,y) 让海龟沿着绝对坐标进行运动</p><p>turtle规定以中心为原点（0,0）</p><p>turtle.goto(0,300)#代表x为0，中心向上300，y为300<br>turtle.goto(-100,100)#代表X为-100，代表向左100，y为100，代表向上100<br>turtle.goto(100,-100)#代表x为向右100，y为向下100</p><p>turtle.setheading(angle)&#x2F;Turtle.seth(angle)</p><p>-改变海龟行进方向，angle为绝对角度，只改变方向不行进</p><p>turtle.circle(r,angle)  以r为半径的圆移动一定角度</p><p>turtle.bk(d) 后退</p><p>turtle.fd(d) 前进</p><p>turtle.left(angle) 左旋转</p><p>turtle.right(angle) 右旋转</p><p>turtle.penup()  抬起画笔</p><p>turtle.pendown() 落笔</p><p>抬起画笔，海龟在飞行，落下画笔，海龟在爬行</p><p>turtle.pensize(25) 画笔大小</p><p>turtle.pencolor(“purple”) 画笔颜色</p><p>Turtle的RGB色彩模式，默认采用小数值，可切换为整数值。</p><p> turtle.colormode(mode)</p><p>-1.0：RGB小数值模式</p><p>-255：RGB整数值模式</p><p>turtle.done()  “turtle.done()”的作用是暂停程序，停止画笔绘制，但绘图窗体不关闭，直到用户关闭Python Turtle图形化窗⼝为止。</p><h3 id="12-库引用与import"><a href="#12-库引用与import" class="headerlink" title="12.库引用与import"></a>12.<strong>库引用与import</strong></h3><p>import &lt;库名&gt;</p><p>&lt;库名&gt;.&lt;函数名&gt;(参数)</p><p>import是一个关键字，用来引入一些外部库，这里的含义是引入一个名字叫turtle的函数库</p><p>import turtle</p><p>使用from和import保留字共同完成</p><p>From&lt;库名&gt;import&lt;函数名&gt;</p><p>From&lt;库名&gt; import *</p><p>&lt;函数名&gt;(&lt;函数参数&gt;)</p><p>使用import和as定义别名</p><p>import&lt;库名&gt;as&lt;库别名&gt;</p><p>&lt;库别名&gt;.&lt;函数名&gt;(&lt;函数参数&gt;)</p><h3 id="13-range（）函数"><a href="#13-range（）函数" class="headerlink" title="13.range（）函数"></a>13.<strong>range（）函数</strong></h3><p>range(N):产生0到N-1的整数序列，共N个</p><p>range(5)   0,1,2,3,4</p><p>Range(M,N):产生M到N-1的整数序列，共N-M个</p><p>Range(2,5)   2,3,4</p><h2 id="三-基本数据类型"><a href="#三-基本数据类型" class="headerlink" title="三.基本数据类型"></a>三.基本数据类型</h2><h3 id="1-数字类型"><a href="#1-数字类型" class="headerlink" title="1.数字类型"></a>1.数字类型</h3><p>Python语言包括三种数字类型</p><p>整数类型</p><p>浮点数类型</p><p>复数类型</p><h4 id="1-1整数类型"><a href="#1-1整数类型" class="headerlink" title="1.1整数类型"></a>1.1整数类型</h4><p>与数学中的整数概念一致，没有取值范围限制</p><p>pow(x, y)函数：计算xy</p><p>打开IDLE</p><p>程序1：pow(2,10) , pow(2,15)</p><p>程序2：pow(2, 1000)</p><p>程序3：pow(2, pow(2,15))</p><p>示例</p><p>1010, 99, -217 </p><p>0x9a, -0X89  (0x, 0X开头表示16进制数) </p><p>0b010, -0B101 (0b, 0B开头表示2进制数) </p><p>0o123, -0O456 (0o, 0O开头表示8进制数)</p><h4 id="1-2浮点数"><a href="#1-2浮点数" class="headerlink" title="1.2浮点数"></a>1.2浮点数</h4><p>带有小数点及小数的数字 </p><p>Python语言中<strong>浮点数的数值范围存在限制</strong>，小数精度也存在限制。这种限制与在不同计算机系统有关</p><p>取值范围数量级约-10308至10308，精度数量级10-16</p><p> 0.0, -77., -2.17 </p><p> 96e4, 4.3e-3, 9.6E5 （科学计数法）</p><p>科学计数法使用字母“e”或者“E”作为幂的符号，以10为基数。科学计数法含义如下：</p><p>​           <a>e<b> &#x3D; a * 10^b</p><p>浮点数间存在不确定尾数，不是bug</p><p>&gt;&gt;&gt;0.1+0.3</p><p>0.4</p><p>&gt;&gt;&gt;0.1+0.2</p><p>0.30000000000000004</p><h4 id="1-3复数类型"><a href="#1-3复数类型" class="headerlink" title="1.3复数类型"></a>1.3复数类型</h4><p>与数学中的复数概念一致, z &#x3D; a + bj， a是实数部分，b是虚数部分，a和b都是浮点类型，虚数部分用j或者J标识</p><p>示例：</p><p>​     12.3+4j,  -5.6+7j</p><p>z &#x3D; 1.23e-4+5.6e+89j（实部和虚部是什么？）</p><p>对于复数z，可以用z.real获得实数部分，z.imag获得虚数部分</p><p>z.real &#x3D; 0.000123  z.imag &#x3D; 5.6e+89</p><h3 id="2-数据类型的操作"><a href="#2-数据类型的操作" class="headerlink" title="2.数据类型的操作"></a>2.数据类型的操作</h3><h4 id="2-1内置的数值运算操作符"><a href="#2-1内置的数值运算操作符" class="headerlink" title="2.1内置的数值运算操作符"></a>2.1内置的数值运算操作符</h4><p>三种类型存在一种逐渐“扩展”的关系：</p><p>​     整数 -&gt; 浮点数 -&gt; 复数 </p><p>​    （整数是浮点数特例，浮点数是复数特例）</p><p>不同数字类型之间可以进行混合运算，运算后生成结果为最宽类型</p><p>123 + 4.0 &#x3D; 127.0 (整数 + 浮点数 &#x3D; 浮点数)</p><p>内置的数值运算操作符</p><p><img src="https://pic.imgdb.cn/item/65b8ede0871b83018a252210.png" alt="内置数组操作符"></p><p>数字类型之间相互运算所生成的结果是“更宽”的类型，基本规则是：</p><p>整数之间运算，如果数学意义上的结果是小数，结果是浮点数</p><p>整数之间运算，如果数学意义上的结果是整数，结果是整数；</p><p>整数和浮点数混合运算，输出结果是浮点数；</p><p>整数或浮点数与复数运算，输出结果是复数。</p><h4 id="2-2-内置的数值运算函数"><a href="#2-2-内置的数值运算函数" class="headerlink" title="2.2 内置的数值运算函数"></a>2.2 内置的数值运算函数</h4><p><img src="https://pic.imgdb.cn/item/65b8ede8871b83018a2541be.png" alt="内置的数值运算函数"></p><h4 id="2-3-数字类型的转换"><a href="#2-3-数字类型的转换" class="headerlink" title="2.3 数字类型的转换"></a>2.3 数字类型的转换</h4><p>数值运算操作符可以隐式地转换输出结果的数字类型</p><p>例如，两个整数采用运算符“&#x2F;”的除法将可能输出浮点数结果。此外，通过内置的数字类型转换函数可以显式地在数字类型之间进行转换 </p><p><img src="https://pic.imgdb.cn/item/65b8ede8871b83018a254230.png" alt="数字类型的转换"></p><p>三种类型可以相互转换</p><p>​     函数：int(), float(), complex()</p><p>示例：</p><p>int(4.5) &#x3D; 4 （直接去掉小数部分）</p><p>float(4) &#x3D; 4.0 （增加小数部分）</p><p>complex(4) &#x3D; 4 + 0J</p><h4 id="2-4-数据类型的判断"><a href="#2-4-数据类型的判断" class="headerlink" title="2.4 数据类型的判断"></a>2.4 数据类型的判断</h4><p>函数：type(x)，返回x的类型，适用于所有类型的判断</p><h3 id="3-math库的使用"><a href="#3-math库的使用" class="headerlink" title="3.math库的使用"></a>3.math库的使用</h3><p>math库是Python提供的内置数学类函数库</p><p>math库不支持复数类型</p><p>math库一共提供了4个数学常数和44个函数。</p><p>44个函数共分为4类，包括：16个数值表示函数、8个幂对数函数、16个三角对数函数和4个高等特殊函数</p><p>首先使用保留字import引用该库</p><p>第一种：import math </p><p>对math库中函数采用math.<b>()形式使用 </p><p>第二种，from math import &lt;函数名&gt;</p><p>对math库中函数可以直接采用&lt;函数名&gt;()形式使用</p><h4 id="3-1math库4个数学常数"><a href="#3-1math库4个数学常数" class="headerlink" title="3.1math库4个数学常数"></a>3.1math库4个数学常数</h4><p><img src="https://pic.imgdb.cn/item/65b8edf2871b83018a256ccf.png" alt="math库4个常数"></p><h4 id="3-2math库16个数值表示函数"><a href="#3-2math库16个数值表示函数" class="headerlink" title="3.2math库16个数值表示函数"></a>3.2math库16个数值表示函数</h4><p><img src="https://pic.imgdb.cn/item/65b8edf3871b83018a256dba.png" alt="16个常值函数"></p><h4 id="3-3math库中包括8个幂对数函数"><a href="#3-3math库中包括8个幂对数函数" class="headerlink" title="3.3math库中包括8个幂对数函数"></a>3.3math库中包括8个幂对数函数</h4><p><img src="https://pic.imgdb.cn/item/65b8edf3871b83018a256e72.png" alt="8个幂对数函数"></p><h4 id="3-4math库包括六个“三角双曲函数"><a href="#3-4math库包括六个“三角双曲函数" class="headerlink" title="3.4math库包括六个“三角双曲函数"></a>3.4math库包括六个“三角双曲函数</h4><p><img src="https://pic.imgdb.cn/item/65b8edf3871b83018a256f36.png" alt="六个三角双曲函数"></p><h4 id="3-5math库包括4个高等特殊函数"><a href="#3-5math库包括4个高等特殊函数" class="headerlink" title="3.5math库包括4个高等特殊函数"></a>3.5math库包括4个高等特殊函数</h4><p><img src="https://pic.imgdb.cn/item/65b8edf3871b83018a256fe9.png" alt="四个高等特殊函数"></p><h3 id="4-字符串类型及其操作"><a href="#4-字符串类型及其操作" class="headerlink" title="4.字符串类型及其操作"></a>4.字符串类型及其操作</h3><h4 id="4-1字符串类型"><a href="#4-1字符串类型" class="headerlink" title="4.1字符串类型"></a>4.1字符串类型</h4><p>字符串是用一对双引号（”）、单引号（‘）或者三引号（’’’）构成。</p><p>字符串可以保存在变量中，也可以单独存在。</p><p>可以用type()函数测试一个字符串的类型</p><p>Python语言转义符： \</p><p>\n表示换行，\表示反斜杠，\t表示制表符，\’表示单引号，\”表示双引号。</p><p>字符串是一个字符序列：字符串最左端位置标记为0，依次增加。字符串中的编号叫做“索引”</p><p>单个索引辅助访问字符串中的特定位置    格式为<string>[&lt;索引&gt;]</p><p>Python中字符串索引从0开始，一个长度为L的字符串最后一个字符的位置是L-1</p><p>Python同时允许使用负数从字符串右边末尾向左边进行反向索引，最右侧索引值是-1</p><p>可以通过两个索引值确定一个位置范围，返回这个范围的子串</p><p>  <strong>格式：</strong> <strong><string>[<start>:<end>]</strong></p><p>start和end都是整数型数值，这个子序列从索引start开始直到索引end结束，但不包括end位置</p><h4 id="4-2字符串操作符"><a href="#4-2字符串操作符" class="headerlink" title="4.2字符串操作符"></a>4.2字符串操作符</h4><p>字符串之间可以通过+或*进行连接</p><p>加法操作(+)将两个字符串连接成为一个新的字符串</p><p>乘法操作(*)生成一个由其本身字符串重复连接而成的字符串</p><p><img src="https://pic.imgdb.cn/item/65b8edfb871b83018a258e26.png" alt="字符串操作符"></p><h4 id="4-3内置的字符串处理函数"><a href="#4-3内置的字符串处理函数" class="headerlink" title="4.3内置的字符串处理函数"></a>4.3内置的字符串处理函数</h4><p><img src="https://pic.imgdb.cn/item/65b8edfb871b83018a258f2e.png" alt="内置的字符串处理函数"></p><h4 id="4-4-Python字符串的编码方式"><a href="#4-4-Python字符串的编码方式" class="headerlink" title="4.4 Python字符串的编码方式"></a>4.4 Python字符串的编码方式</h4><p><img src="https://pic.imgdb.cn/item/65b8edfb871b83018a258fd2.png" alt="字符串的编码方式"></p><h4 id="4-5-字符串的操作"><a href="#4-5-字符串的操作" class="headerlink" title="4.5 字符串的操作"></a>4.5 字符串的操作</h4><p>可以通过 for 和 in 组成的循环来遍历字符串中每个字符</p><p>格式如下：</p><p> for <var> in <string>:</p><p>​    操作</p><p>用转义符可以在字符串中表达一些不可直接打印的信息</p><p>例如：用\n表示换行</p><p>字符串”Hello\nWorld\n\nGoodbye 32\n”</p><p>用print()函数打印后的输出效果如下：</p><p>Hello</p><p>World</p><p>Goodbye 32</p><h4 id="4-6-字符串处理方法"><a href="#4-6-字符串处理方法" class="headerlink" title="4.6 字符串处理方法"></a>4.6 字符串处理方法</h4><p><img src="https://pic.imgdb.cn/item/65b8edfb871b83018a2590ab.png" alt="内置的字符串处理函数plus"></p><h4 id="4-7字符串类型的格式化"><a href="#4-7字符串类型的格式化" class="headerlink" title="4.7字符串类型的格式化"></a>4.7字符串类型的格式化</h4><h4 id="4-7-1-format-方法的基本使用"><a href="#4-7-1-format-方法的基本使用" class="headerlink" title="4.7.1 format()方法的基本使用"></a>4.7.1 format()方法的基本使用</h4><p>字符串format()方法的基本使用格式是：</p><p>&lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;)</p><p><img src="https://pic.imgdb.cn/item/65b8edfb871b83018a259133.png" alt="format()方法的基本使用"></p><h4 id="4-7-2-format-方法的格式控制"><a href="#4-7-2-format-方法的格式控制" class="headerlink" title="4.7.2 format()方法的格式控制"></a>4.7.2 format()方法的格式控制</h4><p>•format()方法中模板字符串的槽除了包括参数序号 ，还可以包括格式控制信息。此时，槽的内部样式如下：{&lt;参数序号&gt;: &lt;格式控制标记&gt;} </p><p><img src="https://pic.imgdb.cn/item/65b8ee08871b83018a25c5b6.png" alt="format方法的格式化控制"></p><p><img src="https://pic.imgdb.cn/item/65b8ee09871b83018a25c6b7.png" alt="format方法的格式化控制1"></p><h3 id="5-文本进度条"><a href="#5-文本进度条" class="headerlink" title="5.文本进度条"></a>5.文本进度条</h3><p>利用print()函数实现简单的非刷新文本进度条</p><p>基本思想是按照任务执行百分比将整个任务划分为100个单位，每执行N%输出一次进度条。每一行输出包含进度百分比，代表已完成的部分(**)和未完成的部分(..)的两种字符，以及一个跟随完成度前进的小箭头</p><h4 id="5-1静态文本进度条"><a href="#5-1静态文本进度条" class="headerlink" title="5.1静态文本进度条"></a>5.1<strong>静态文本进度条</strong></h4><p><img src="https://pic.imgdb.cn/item/65b8ee12871b83018a25eae0.png" alt="静态文本进度条"></p><p><img src="https://pic.imgdb.cn/item/65b8ee12871b83018a25eb86.png" alt="静态文本进度条结果"></p><h4 id="5-2单行动态刷新"><a href="#5-2单行动态刷新" class="headerlink" title="5.2单行动态刷新"></a>5.2<strong>单行动态刷新</strong></h4><p><img src="https://pic.imgdb.cn/item/65b8ee11871b83018a25e952.png" alt="单行动态刷新"></p><p>-函数Print()中更换参数end的默认值为””，即不换行</p><p>-增加转义符‘&#x2F;r’，把输出指针移到行首而不换行</p><p><img src="https://pic.imgdb.cn/item/65b8ee12871b83018a25ea17.png" alt="单行动态刷新1"></p><h4 id="5-3带刷新的文本进度条"><a href="#5-3带刷新的文本进度条" class="headerlink" title="5.3带刷新的文本进度条"></a>5.3<strong>带刷新的文本进度条</strong></h4><p><img src="https://pic.imgdb.cn/item/65b8ee09871b83018a25c738.png" alt="带刷新的文本进度条"></p><p><img src="https://pic.imgdb.cn/item/65b8ee09871b83018a25c7ad.png" alt="文本进度条效果"></p><h4 id="5-4五花八门的进度条设计函数"><a href="#5-4五花八门的进度条设计函数" class="headerlink" title="5.4五花八门的进度条设计函数"></a>5.4五花八门的进度条设计函数</h4><p><img src="https://pic.imgdb.cn/item/65b8ee12871b83018a25ec57.png" alt="五花八门的进度条设计函数"></p><h2 id="四-程序的控制结构"><a href="#四-程序的控制结构" class="headerlink" title="四.程序的控制结构"></a>四.程序的控制结构</h2><h3 id="4-1程序的流程图"><a href="#4-1程序的流程图" class="headerlink" title="4.1程序的流程图"></a>4.1程序的流程图</h3><p>程序流程图用一系列图形、流程线和文字说明描述程序的基本操作和控制流程，它是程序分析和过程描述的最基本方式。</p><p>流程图的基本元素包括7种</p><p><img src="https://pic.imgdb.cn/item/65b8ee18871b83018a260589.png" alt="程序流程图"></p><h3 id="4-2-程序的基本结构"><a href="#4-2-程序的基本结构" class="headerlink" title="4.2 程序的基本结构"></a>4.2 程序的基本结构</h3><p>顺序结构是程序的基础，但单一的顺序结构不可能解决所有问题。</p><p>程序由三种基本结构组成：</p><p>  顺序结构</p><p>  分支结构</p><p>  循环结构</p><p>这些基本结构都有一个入口和一个出口。任何程序都由这三种基本结构组合而成</p><p>•<strong>顺序结构</strong>是程序按照线性顺序依次执行的一种运行方式，其中语句块1和语句块2表示一个或一组顺序执行的语句</p><p><strong>分支结构</strong>是程序根据条件判断结果而选择不同向前执行路径的一种运行方式，包括单分支结构和二分支结构。由二分支结构组合形成多分支结构</p><p><strong>循环结构</strong>是程序根据条件判断结果向后反复执行的一种运行方式，根据循环体触发条件不同，包括条件循环和遍历循环结构</p><p>IPO描述主要用于区分程序的输入输出关系，重点在于结构划分，算法主要采用自然语言描述</p><p>流程图描述侧重于描述算法的具体流程关系，流程图的结构化关系相比自然语言描述更进一步，有助于阐述算法的具体操作过程</p><p>Python代码描述是最终的程序产出，最为细致</p><h3 id="4-3-程序的分支结构"><a href="#4-3-程序的分支结构" class="headerlink" title="4.3 程序的分支结构"></a>4.3 程序的分支结构</h3><h4 id="4-3-1-单分支结构-if语句"><a href="#4-3-1-单分支结构-if语句" class="headerlink" title="4.3.1 单分支结构: if语句"></a>4.3.1 单分支结构: if语句</h4><p>Python中if语句的语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> &lt;条件&gt;:<br><br>  语句块<br></code></pre></td></tr></table></figure><p>• 语句块是if条件满足后执行的一个或多个语句序列</p><p>• 语句块中语句通过与if所在行形成缩进表达包含关系</p><p>• if语句首先评估&lt;条件&gt;的结果值，如果结果为True，则执行语句块里的语句序列，然后控制转向程序的下一条语句。如果结果为False，语句块里的语句会被跳过。</p><p>if语句中语句块执行与否依赖于条件判断。但无论什么情况，控制都会转到if语句后与该语句同级别的下一条语句 </p><p>•if语中&lt;条件&gt;部分可以使用任何能够产生True或False的语句</p><p>•形成判断条件最常见的方式是采用关系操作符</p><p>•Python语言共有6个关系操作符</p><p><img src="https://pic.imgdb.cn/item/65b8ee18871b83018a2605f8.png" alt="python关系操作符"></p><h4 id="4-3-2-二分支结构-if-else语句"><a href="#4-3-2-二分支结构-if-else语句" class="headerlink" title="4.3.2 二分支结构: if-else语句"></a>4.3.2 二分支结构: if-else语句</h4><p>Python中if-else语句用来形成二分支结构，语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span>  &lt;条件&gt;:<br>    &lt;语句块<span class="hljs-number">1</span>&gt;<br><span class="hljs-keyword">else</span>:<br>    &lt;语句块<span class="hljs-number">2</span>&gt;<br></code></pre></td></tr></table></figure><p>•&lt;语句块1&gt;是在if条件满足后执行的一个或多个语句序列</p><p>•&lt;语句块2&gt;是if条件不满足后执行的语句序列</p><p>•二分支语句用于区分&lt;条件&gt;的两种可能True或者False，分别形成执行路径</p><p>二分支结构还有一种更简洁的表达方式，适合通过判断返回特定值，语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;表达式<span class="hljs-number">1</span>&gt;  <span class="hljs-keyword">if</span>  &lt;条件&gt; <span class="hljs-keyword">else</span> &lt;表达式<span class="hljs-number">2</span>&gt;   <span class="hljs-comment">#if…else的紧凑结构非常适合对特殊值处理的情况</span><br></code></pre></td></tr></table></figure><h4 id="4-3-2-多分支结构-if-elif-else语句"><a href="#4-3-2-多分支结构-if-elif-else语句" class="headerlink" title="4.3.2 多分支结构: if-elif-else语句"></a>4.3.2 多分支结构: if-elif-else语句</h4><p>Python的if-elif-else描述多分支结构，语句格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> &lt;条件<span class="hljs-number">1</span>&gt;:<br>     &lt;语句块<span class="hljs-number">1</span>&gt;<br><span class="hljs-keyword">elif</span> &lt;条件<span class="hljs-number">2</span>&gt;:<br>     &lt;语句块<span class="hljs-number">2</span>&gt;<br><span class="hljs-meta">... </span><br><span class="hljs-keyword">else</span>: <br>     &lt;语句块N&gt;  <br></code></pre></td></tr></table></figure><p>•多分支结构是二分支结构的扩展，这种形式通常用于设置同一个判断条件的多条执行路径。</p><p>•Python依次评估寻找第一个结果为True的条件，执行该条件下的语句块，同时结束后跳过整个if-elif-else结构，执行后面的语句。如果没有任何条件成立，else下面的语句块被执行。else子句是可选的 </p><h4 id="4-3-3多分支结构-match-case语句（补）"><a href="#4-3-3多分支结构-match-case语句（补）" class="headerlink" title="4.3.3多分支结构: match-case语句（补）"></a>4.3.3多分支结构: match-case语句（补）</h4><p>Python的match-case描述多分支结构，是python3.10新特性,语句格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">match</span> 变量:<br>      <span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>:<br>            &lt;语句块<span class="hljs-number">1</span>&gt;<br>      <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span> :<br>            &lt;语句块<span class="hljs-number">2</span>&gt;<br>         ... <br>      <span class="hljs-keyword">case</span> _: <br>            &lt;语句块N&gt;  <br><span class="hljs-comment">#_ 是一个特殊的“占位符”模式，用于匹配任何值</span><br></code></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/65b8ee18871b83018a26069f.png" alt="match-case语句"></p><h3 id="4-4程序的循环结构"><a href="#4-4程序的循环结构" class="headerlink" title="4.4程序的循环结构"></a>4.4程序的循环结构</h3><h4 id="4-4-1遍历循环-for语句"><a href="#4-4-1遍历循环-for语句" class="headerlink" title="4.4.1遍历循环: for语句"></a>4.4.1遍历循环: for语句</h4><p><strong>遍历循环</strong>：</p><p>  根据循环执行次数的确定性，循环可以分为确定次数循环和非确定次数循环。确定次数循环指循环体对循环次数有明确的定义，循环次数采用遍历结构中元素个数来体现</p><p>Python通过保留字for实现“遍历循环” ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span>  &lt;循环变量&gt;  <span class="hljs-keyword">in</span>  &lt;遍历结构&gt;:<br>    &lt;语句块&gt; <br></code></pre></td></tr></table></figure><p>遍历结构可以是字符串、文件、组合数据类型或range()函数：</p><p><img src="https://pic.imgdb.cn/item/65b8ee18871b83018a260706.png" alt="遍历循环"></p><p>遍历循环还有一种扩展模式，使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span>  &lt;循环变量&gt;  <span class="hljs-keyword">in</span>  &lt;遍历结构&gt;:<br>    &lt;语句块<span class="hljs-number">1</span>&gt;<br><span class="hljs-keyword">else</span>:<br>    &lt;语句块<span class="hljs-number">2</span>&gt;<br></code></pre></td></tr></table></figure><p>•当for循环正常执行之后，程序会继续执行else语句中内容。else语句只在循环正常执行之后才执行并结束。</p><p>•因此，可以在&lt;语句块2&gt;中放置判断循环执行情况的语句。</p><h4 id="4-4-2-无限循环-while语句"><a href="#4-4-2-无限循环-while语句" class="headerlink" title="4.4.2 无限循环: while语句"></a>4.4.2 无限循环: while语句</h4><p><strong>无限循环</strong>：</p><p>•无限循环一直保持循环操作直到特定循环条件不被满足才结束，不需要提前知道确定循环次数。</p><p>•Python通过保留字while实现无限循环，使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> &lt;条件&gt;:<br>    &lt;语句块&gt;<br></code></pre></td></tr></table></figure><p>•无限循环也有一种使用保留字else的扩展模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span>  &lt;条件&gt;:<br>      &lt;语句块<span class="hljs-number">1</span>&gt;<br><span class="hljs-keyword">else</span>:<br>      &lt;语句块<span class="hljs-number">2</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="4-4-3-循环保留字-break和continue"><a href="#4-4-3-循环保留字-break和continue" class="headerlink" title="4.4.3 循环保留字: break和continue"></a>4.4.3 循环保留字: break和continue</h4><p>•循环结构有两个辅助保留字：break和continue，它们用来辅助控制循环执行</p><p>•break用来跳出最内层for或while循环，脱离该循环后，程序从循环后代码继续续执行 </p><p>•每个break语句只有能力跳出当前层次循环</p><p>•continue用来结束当前当次循环，即跳出循环体中下面尚未执行的语句，但不跳出当前循环。</p><p><strong>continue语句和break语句的区别是：</strong></p><p>•continue语句只结束本次循环，而不终止整个循环的执行。</p><p>•break语句则是结束整个循环过程，不再判断执行循环的条件是否成立</p><p><strong>for循环和while循环中都存在一个else扩展用法。</strong></p><p>•else中的语句块只在一种条件下执行，即for循环正常遍历了所有内容没有因为break或return而退出。</p><p>•continue保留字对else没有影响</p><h3 id="4-5-random库的使用"><a href="#4-5-random库的使用" class="headerlink" title="4.5 random库的使用"></a>4.5 random库的使用</h3><h4 id="4-5-1-random库概述"><a href="#4-5-1-random库概述" class="headerlink" title="4.5.1 random库概述"></a>4.5.1 random库概述</h4><p>•随机数在计算机应用中十分常见，Python内置的random库主要用于产生各种分布的伪随机数序列。random库采用梅森旋转算法（Mersenne twister）生成伪随机数序列，可用于除随机性要求更高的加解密算法外的大多数工程应用。</p><p>•使用random库主要目的是生成随机数，因此，读者只需要查阅该库的随机数生成函数，找到符合使用场景的函数使用即可。这个库提供了不同类型的随机数函数，所有函数都是基于最基本的random.random()函数扩展而来。</p><p><strong>random的常用函数</strong></p><p><img src="https://pic.imgdb.cn/item/65b8ee1a871b83018a260ff0.png" alt="random库的常用函数"></p><h4 id="4-5-2-random库解析"><a href="#4-5-2-random库解析" class="headerlink" title="4.5.2 random库解析"></a>4.5.2 random库解析</h4><p><img src="https://pic.imgdb.cn/item/65b8ee23871b83018a26312e.png" alt="random库解析"></p><p>对random库的引用方法与math库一样，采用下面两种方式实现：</p><p>import random  或   from random import *</p><h4 id="4-5-3-π的计算"><a href="#4-5-3-π的计算" class="headerlink" title="4.5.3 π的计算"></a>4.5.3 <strong>π</strong>的计算</h4><p>•π（圆周率）是一个无理数，即无限不循环小数。精确求解圆周率π是几何学、物理学和很多工程学科的关键。</p><p>•对π的精确求解曾经是数学历史上一直难以解决的问题之一，因为π无法用任何精确公式表示，在电子计算机出现以前，π只能通过一些近似公式的求解得到，直到1948年，人类才以人工计算方式得到π的808位精确小数。</p><p>​    随着计算机的出现，数学家找到了另类求解π的另类方法：蒙特卡罗（Monte Carlo）方法，又称随机抽样或统计试验方法。</p><p>​    当所要求解的问题是某种事件出现的概率，或者是某个随机变量的期望值时，它们可以通过某种“试验”的方法，得到这种事件出现的频率，或者这个随机变数的平均值，并用它们作为问题的解。这就是蒙特卡罗方法的基本思想</p><p>应用蒙特卡罗方法求解π的基本步骤如下：</p><p>•随机向单位正方形和圆结构，抛洒大量“飞镖”点</p><p>•计算每个点到圆心的距离从而判断该点在圆内或者圆外</p><p>•用圆内的点数除以总点数就是π&#x2F;4值。</p><p>随机点数量越大，越充分覆盖整个图形，计算得到的π值越精确。实际上，这个方法的思想是利用离散点值表示图形的面积，通过面积比例来求解π值。 </p><p><img src="https://pic.imgdb.cn/item/65b8ee23871b83018a2631e5.png" alt="π的计算"></p><h3 id="4-6-异常处理机制"><a href="#4-6-异常处理机制" class="headerlink" title="4.6 异常处理机制"></a>4.6 异常处理机制</h3><h4 id="4-6-1异常处理-try-except语句"><a href="#4-6-1异常处理-try-except语句" class="headerlink" title="4.6.1异常处理: try-except语句"></a>4.6.1<strong>异常处理</strong>: try-except语句</h4><p>观察下面这段小程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">num=<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个整数：&quot;</span>))<br><span class="hljs-built_in">print</span>(num**<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>当用户输入的不是数字呢？</p><p><img src="https://pic.imgdb.cn/item/65b8ee23871b83018a263246.png" alt="数字异常"></p><p>Python异常信息中最重要的部分是异常类型，它表明了发生异常的原因，也是程序处理异常的依据。</p><p>Python使用try-except语句实现异常处理，基本的语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>     &lt;语句块<span class="hljs-number">1</span>&gt;<br><span class="hljs-keyword">except</span> &lt;异常类型&gt;:<br>     &lt;语句块<span class="hljs-number">2</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="4-6-2-异常的高级用法"><a href="#4-6-2-异常的高级用法" class="headerlink" title="4.6.2 异常的高级用法"></a>4.6.2 异常的高级用法</h4><p>try-except语句可以支持多个except语句，语法格式如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>&lt;语句块<span class="hljs-number">1</span>&gt;<br><span class="hljs-keyword">except</span> &lt;异常类型<span class="hljs-number">1</span>&gt;:<br>&lt;语句块<span class="hljs-number">2</span>&gt;<br>…<br><span class="hljs-keyword">except</span> &lt;异常类型N&gt;:<br>&lt;语句块N+<span class="hljs-number">1</span>&gt;<br><span class="hljs-keyword">except</span>:<br>&lt;语句块N+<span class="hljs-number">2</span>&gt;<br></code></pre></td></tr></table></figure><p>最后一个except语句没有指定任何类型，表示它对应的语句块可以处理所有其他异常。这个过程与if-elif-else语句类似，是分支结构的一种表达方式，一段代码如下： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    alp=<span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><br>    idx=<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个整数：&quot;</span>))<br>    <span class="hljs-built_in">print</span>(alp[idx])<br><span class="hljs-keyword">except</span> NameError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入错误，请输入一个整数！&quot;</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;其他错误&quot;</span>)<br></code></pre></td></tr></table></figure><p>该程序将用户输入的数字作为索引从字符串alp中返回一个字符，当用户输入非整数字符时，except NameError异常被捕获到，提示用户输入类型错误，当用户输入数字不在0到25之间时，异常被except捕获，程序打印其他错误信息</p><p>除了try和except保留字外，异常语句还可以与else和finally保留字配合使用，语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>&lt;语句块<span class="hljs-number">1</span>&gt;<br><span class="hljs-keyword">except</span> &lt;异常类型<span class="hljs-number">1</span>&gt;:<br>&lt;语句块<span class="hljs-number">2</span>&gt;<br><span class="hljs-keyword">else</span>:<br>&lt;语句块<span class="hljs-number">3</span>&gt;<br><span class="hljs-keyword">finally</span>:<br>&lt;语句块<span class="hljs-number">4</span>&gt;<br></code></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/65b8ee23871b83018a2632e1.png" alt="异常的高级用法"></p><p><img src="https://pic.imgdb.cn/item/65b8ee23871b83018a26335a.png" alt="异常的高级用法1"></p><h2 id="五-函数和代码的复用"><a href="#五-函数和代码的复用" class="headerlink" title="五.函数和代码的复用"></a>五.函数和代码的复用</h2><h3 id="5-1-函数的定义"><a href="#5-1-函数的定义" class="headerlink" title="5.1 函数的定义"></a>5.1 函数的定义</h3><p>•函数是一段具有特定功能的、可重用的语句组，用函数名来表示并通过函数名进行完成功能调用。</p><p>•函数是一种功能的抽象，一般函数表达特定功能</p><p>•作用：降低编程难度和代码重用</p><p>Python定义一个函数使用def保留字，语法形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> &lt;函数名&gt;(&lt;参数列表&gt;):<br>    &lt;函数体&gt;<br>    <span class="hljs-keyword">return</span> &lt;返回值列表&gt;<br></code></pre></td></tr></table></figure><p>函数定义时，所指定的参数是一种占位符，简称形参。</p><p>函数定义后，如果不经调用，不会被执行</p><p>函数定义时，参数是输入、函数体是处理、结果是输出</p><p>函数中，可以没有return语句</p><h3 id="5-2-函数调用的过程"><a href="#5-2-函数调用的过程" class="headerlink" title="5.2 函数调用的过程"></a>5.2 函数调用的过程</h3><p>函数调用：函数名(参数)</p><p>程序调用一个函数需要执行以下四个步骤：</p><p>（1）调用程序在调用处暂停执行；</p><p>（2）在调用时将实参复制给函数的形参；</p><p>（3）执行函数体语句；</p><p>（4）函数调用结束给出返回值，程序回到调用前的暂停处继续执行。</p><h3 id="5-3-lambda函数"><a href="#5-3-lambda函数" class="headerlink" title="5.3 lambda函数"></a>5.3 lambda函数</h3><p>Python的有33个保留字，其中一个是lambda，该保留字用于定义一种特殊的函数——匿名函数，又称lambda函数。</p><p>匿名函数并非没有名字，而是将函数名作为函数结果返回，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;函数名&gt; = <span class="hljs-keyword">lambda</span> &lt;参数列表&gt;: &lt;表达式&gt;<br></code></pre></td></tr></table></figure><p>lambda函数与正常函数一样，等价于下面形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> &lt;函数名&gt;(&lt;参数列表&gt;):<br>     <span class="hljs-keyword">return</span> &lt;表达式&gt;<br></code></pre></td></tr></table></figure><p>简单说，lambda函数用于定义简单的、能够在一行内表示的函数，返回一个函数类型</p><h3 id="5-4-函数的参数传递"><a href="#5-4-函数的参数传递" class="headerlink" title="5.4 函数的参数传递"></a>5.4 函数的参数传递</h3><h4 id="5-4-1可选参数和可变数量参数"><a href="#5-4-1可选参数和可变数量参数" class="headerlink" title="5.4.1可选参数和可变数量参数"></a>5.4.1可选参数和可变数量参数</h4><p>在定义函数时，有些参数可以存在默认值，该参数叫可选参数，其位置必须在非可选参数之后。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">def</span> <span class="hljs-title function_">dup</span>(<span class="hljs-params"><span class="hljs-built_in">str</span>, times = <span class="hljs-number">2</span></span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>*times)<br>&gt;&gt;&gt;dup(<span class="hljs-string">&quot;knock~&quot;</span>)<br>knock~knock~<br>&gt;&gt;&gt;dup(<span class="hljs-string">&quot;knock~&quot;</span>,<span class="hljs-number">4</span>)<br>knock~knock~knock~knock~<br></code></pre></td></tr></table></figure><p>在函数定义时，可以设计可变数量参数，通过参数前增加星号（*）实现，可变参数只能出现在参数列表的最后。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">def</span> <span class="hljs-title function_">vfunc</span>(<span class="hljs-params">a, *b</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(b))<br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> b:<br>             a += n<br>        <span class="hljs-keyword">return</span> a<br>&gt;&gt;&gt;vfunc(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt; <span class="hljs-comment">#可变参数b是元组类型</span><br><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>还有一种就是参数带两个星号 ******基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">functionname</span>(<span class="hljs-params">[formal_args,] **var_args_dict </span>):<br>   <span class="hljs-string">&quot;函数_文档字符串&quot;</span><br>   function_suite<br>   <span class="hljs-keyword">return</span> [expression]<br></code></pre></td></tr></table></figure><p>加了两个星号 *<strong>*</strong> 的参数会以字典的形式导入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br>  <br><span class="hljs-comment"># 可写函数说明</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">printinfo</span>(<span class="hljs-params"> arg1, **vardict </span>):<br>   <span class="hljs-string">&quot;打印任何传入的参数&quot;</span><br>   <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;输出: &quot;</span>)<br>   <span class="hljs-built_in">print</span> (arg1)<br>   <span class="hljs-built_in">print</span> (vardict)<br> <br><span class="hljs-comment"># 调用printinfo 函数</span><br>printinfo(<span class="hljs-number">1</span>, a=<span class="hljs-number">2</span>,b=<span class="hljs-number">3</span>)<br><span class="hljs-comment">#以上实例输出结果：</span><br><br>输出: <br><span class="hljs-number">1</span><br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>声明函数时，参数中星号 ***** 可以单独出现，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a,b,*,c</span>):<br>    <span class="hljs-keyword">return</span> a+b+c<br></code></pre></td></tr></table></figure><p>如果单独出现星号 *****，则星号 ***** 后的参数必须用关键字传入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a,b,*,c</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> a+b+c<br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)   <span class="hljs-comment"># 报错</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: f() takes <span class="hljs-number">2</span> positional arguments but <span class="hljs-number">3</span> were given<br><span class="hljs-meta">&gt;&gt;&gt; </span>f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,c=<span class="hljs-number">3</span>) <span class="hljs-comment"># 正常</span><br><span class="hljs-number">6</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><h4 id="5-4-2-参数的位置和名称传递"><a href="#5-4-2-参数的位置和名称传递" class="headerlink" title="5.4.2 参数的位置和名称传递"></a>5.4.2 参数的位置和名称传递</h4><p>•1、实参默认采用按照位置顺序传给函数。</p><p>•2、按照形参名称输入实参的方式，调用如下：result &#x3D; func(x2&#x3D;4, y2&#x3D;5, z2&#x3D;6, x1&#x3D;1, y1&#x3D;2, z1&#x3D;3)由于调用函数时指定了参数名称，所以参数之间的顺序可以任意调整。</p><h4 id="5-4-3-函数的返回值"><a href="#5-4-3-函数的返回值" class="headerlink" title="5.4.3 函数的返回值"></a>5.4.3 函数的返回值</h4><p>•return语句用来退出函数并将程序返回到函数被调用的位置继续执行。</p><p>•return语句同时可以将0个、1个或多个函数运算完的结果返回给函数被调用处的变量，例如以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a, b</span>):<br>        <span class="hljs-keyword">return</span> a*b<br>&gt;&gt;&gt;s = func(<span class="hljs-string">&quot;knock~&quot;</span>, <span class="hljs-number">2</span>)<br>&gt;&gt;&gt;<span class="hljs-built_in">print</span>(s)<br>knock~knock~<br></code></pre></td></tr></table></figure><p>函数可以没有return，此时函数并不返回值，如微实例5.1的happy()函数。</p><p>函数也可以用return返回多个值，多个值以元组类型保存，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a, b</span>):<br>        <span class="hljs-keyword">return</span> b,a<br>&gt;&gt;&gt;s = func(<span class="hljs-string">&quot;knock~&quot;</span>, <span class="hljs-number">2</span>)<br>&gt;&gt;&gt;<span class="hljs-built_in">print</span>(s, <span class="hljs-built_in">type</span>(s))<br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;knock~&#x27;</span>) &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="5-4-4-函数对变量的作用"><a href="#5-4-4-函数对变量的作用" class="headerlink" title="5.4.4 函数对变量的作用"></a>5.4.4 函数对变量的作用</h4><p>一个程序中的变量包括两类：全局变量和局部变量。</p><p>•<strong>全局变量</strong>指在函数之外定义的变量，一般没有缩进，在程序执行全过程有效。</p><p>•<strong>局部变量</strong>指在函数内部使用的变量，仅在函数内部有效，当函数退出时变量将不存在。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;n = <span class="hljs-number">1</span>    <span class="hljs-comment">#n是全局变量</span><br>&gt;&gt;&gt;<span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a, b</span>):<br>        c = a * b    <span class="hljs-comment">#c是局部变量，a和b作为函数参数也是局部变量</span><br>        <span class="hljs-keyword">return</span> c<br>&gt;&gt;&gt;s = func(<span class="hljs-string">&quot;knock~&quot;</span>, <span class="hljs-number">2</span>)<br>&gt;&gt;&gt;<span class="hljs-built_in">print</span>(c)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;pyshell#6&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-built_in">print</span>(c)<br>NameError: name <span class="hljs-string">&#x27;c&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined<br></code></pre></td></tr></table></figure><p>这个例子说明，当函数执行完退出后，其内部变量将被释放。如果函数内部使用了全局变量呢？ </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;n = <span class="hljs-number">1</span>    <span class="hljs-comment">#n是全局变量</span><br>&gt;&gt;&gt;<span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a, b</span>):<br>            n = b     <span class="hljs-comment">#这个n是在函数内存中新生成的局部变量，不是全局变量 </span><br>            <span class="hljs-keyword">return</span> a*b<br>&gt;&gt;&gt;s = func(<span class="hljs-string">&quot;knock~&quot;</span>, <span class="hljs-number">2</span>)<br>&gt;&gt;&gt;<span class="hljs-built_in">print</span>(s, n)  <span class="hljs-comment">#测试一下n值是否改变</span><br>knock~knock~ <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>•函数func()内部使用了变量n，并且将变量参数b赋值给变量n，为何全局变量n值没有改变？</p><p>•因为函数内n&#x3D;b是生成一个局部变量n，虽然同名但是func函数并没有把n当作全局变量。</p><p>如果希望让func()函数将n当作全局变量，需要在变量n使用前显式声明该变量为全局变量，代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;n = <span class="hljs-number">1</span>    <span class="hljs-comment">#n是全局变量</span><br>&gt;&gt;&gt;<span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a, b</span>):<br>           <span class="hljs-keyword">global</span> n<br>           n = b     <span class="hljs-comment">#将局部变量b赋值给全局变量n </span><br>           <span class="hljs-keyword">return</span> a*b<br>&gt;&gt;&gt;s = func(<span class="hljs-string">&quot;knock~&quot;</span>, <span class="hljs-number">2</span>)<br>&gt;&gt;&gt;<span class="hljs-built_in">print</span>(s, n)  <span class="hljs-comment">#测试一下n值是否改变</span><br>knock~knock~ <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>补充：</strong>在使用global声明全局变量时，不能和形参同名</p><p>•错误：<strong>SyntaxError</strong>：name ‘a’ is parameter and global</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;n = <span class="hljs-number">1</span>    <span class="hljs-comment">#n是全局变量</span><br>&gt;&gt;&gt;<span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a, b</span>):<br>           <span class="hljs-keyword">global</span> a  <span class="hljs-comment">#会报错</span><br>           n = b     <span class="hljs-comment">#将局部变量b赋值给全局变量n </span><br>           <span class="hljs-keyword">return</span> a*b<br>&gt;&gt;&gt;s = func(<span class="hljs-string">&quot;knock~&quot;</span>, <span class="hljs-number">2</span>)<br>&gt;&gt;&gt;<span class="hljs-built_in">print</span>(s, n)  <span class="hljs-comment">#测试一下n值是否改变</span><br>knock~knock~ <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>如果此时的全局变量不是整数n，而是列表类型ls，会怎么样呢？理解如下代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;ls = []    <span class="hljs-comment">#ls是全局列表变量</span><br>&gt;&gt;&gt;<span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a, b</span>):<br>        ls.append(b)   <span class="hljs-comment">#将局部变量b增加到全局列表变量ls中 </span><br>        <span class="hljs-keyword">return</span> a*b<br>&gt;&gt;&gt;s = func(<span class="hljs-string">&quot;knock~&quot;</span>, <span class="hljs-number">2</span>)<br>&gt;&gt;&gt;<span class="hljs-built_in">print</span>(s, ls)  <span class="hljs-comment">#测试一下ls值是否改变</span><br>knock~knock~ [<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>全局列表变量ls发生改变</p><p>如果func()函数内部存在一个真实创建过且名称为ls的列表，则func()将操作该列表而不会修改全局变量，例子如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;ls = []    <span class="hljs-comment">#ls是全局列表变量</span><br>&gt;&gt;&gt;<span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a, b</span>):<br>        ls = []     <span class="hljs-comment">#创建了名称为ls的局部列表变量列</span><br>        ls.append(b)   <span class="hljs-comment">#将局部变量b增加到局部列表变量ls中 </span><br>        <span class="hljs-keyword">return</span> a*b<br>&gt;&gt;&gt;s = func(<span class="hljs-string">&quot;knock~&quot;</span>, <span class="hljs-number">3</span>)<br>&gt;&gt;&gt;<span class="hljs-built_in">print</span>(s, ls)  <span class="hljs-comment">#测试一下ls值是否改变</span><br>knock~knock~ []<br></code></pre></td></tr></table></figure><h3 id="5-5-可更改与不可更改对象"><a href="#5-5-可更改与不可更改对象" class="headerlink" title="5.5 可更改与不可更改对象"></a>5.5 可更改与不可更改对象</h3><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p><p><strong>不可变类型</strong>：变量赋值 a&#x3D;5 后再赋值 a&#x3D;10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。</p><p><strong>可变类型</strong>：变量赋值 la&#x3D;[1,2,3,4] 后再赋值 la[2]&#x3D;5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</p><p><strong>不可变类型</strong>：类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。</p><p><strong>可变类型</strong>：类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响</p><p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p><h3 id="5-6-局部变量作用域"><a href="#5-6-局部变量作用域" class="headerlink" title="5.6 局部变量作用域"></a>5.6 局部变量作用域</h3><p>Python函数对局部变量的作用遵守如下原则：</p><p>•在函数内部创建简单数据类型变量，无论是否与全局变量重名，函数退出后变量被释放，全局变量值不变；</p><p>•在函数内部创建组合数据类型变量，无论是否有同名全局变量，函数退出后变量被释放，全局变量值不变。</p><p><strong>局部变量作用域只在函数内</strong></p><p><strong>Python函数对变量的作用遵守如下原则：</strong></p><p>•函数内的局部变量作用域要想超出函数，需要给该变量前加global</p><p>•在使用global声明全局变量时，不能和形参同名</p><p>global：将局部变量声明为全局变量</p><p>nonlocal：将局部变量声明为非局部变量，该关键字能将局部变量的作用域增加一个级别，并不是声明为全局变量，且该关键字<strong>只能对局部变量使用</strong>。</p><h3 id="5-7-全局变量作用域"><a href="#5-7-全局变量作用域" class="headerlink" title="5.7 全局变量作用域"></a>5.7 全局变量作用域</h3><p><strong>Python函数对全局变量的作用遵守如下原则：</strong></p><p>strings, tuples, 和 numbers做全局变量时，传入函数后，函数内的操作并不影响该变量本身的值。</p><p>列表，字典做全局变量时，传入函数后：1、函数内创建无同名局部变量，函数内的操作影响全局变量的值；2、函数内创建有同名局部变量，仅对局部变量操作，全局变量值不变。</p><h3 id="5-8-函数对变量的作用"><a href="#5-8-函数对变量的作用" class="headerlink" title="5.8 函数对变量的作用"></a>5.8 函数对变量的作用</h3><p>Python函数对变量的作用遵守如下原则：</p><p>•在函数内部创建简单数据类型变量，无论是否与全局变量重名，函数退出后变量被释放，全局变量值不变；</p><p>•简单数据类型变量在用global保留字声明后，作为全局变量；</p><p>•对于组合数据类型的全局变量，如果在函数内部没有被真实创建的同名变量，则函数内部可直接使用并修改全局变量的值；</p><p>在函数内部创建组合数据类型变量，无论是否有同名全局变量，函数退出后变量被释放，全局变量值不变</p><h3 id="5-9-datetime库的使用"><a href="#5-9-datetime库的使用" class="headerlink" title="5.9 datetime库的使用"></a>5.9 datetime库的使用</h3><h4 id="5-9-1-datetime库概述"><a href="#5-9-1-datetime库概述" class="headerlink" title="5.9.1 datetime库概述"></a>5.9.1 datetime库概述</h4><p> 以不同格式显示日期和时间是程序中最常用到的功能。<strong>Python</strong>提供了一个处理时间的标准函数库<strong>datetime</strong>，它提供了一系列由简单到复杂的时间处理方法。datetime库可以从系统中获得时间，并以用户选择的格式输出。</p><p><strong>datetime库以类的方式提供多种日期和时间表达方式：</strong></p><p>datetime.date：<strong>日期表示类</strong>，可以表示年、月、日等</p><p>datetime.time：<strong>时间表示类</strong>，可以表示小时、分钟、秒、毫秒等</p><p>datetime.datetime：<strong>日期和时间表示的类</strong>，功能覆盖date和time类</p><p>datetime.timedelta：<strong>时间间隔有关的类</strong></p><p>datetime.tzinfo：<strong>与时区有关的信息表示类</strong></p><h4 id="5-9-2-datetime库解析"><a href="#5-9-2-datetime库解析" class="headerlink" title="5.9.2 datetime库解析"></a>5.9.2 datetime库解析</h4><p>使用datetime.now()获得当前日期和时间对象，使用方法如下：</p><p> <strong>datetime.now</strong>()</p><p><strong>作用</strong>：返回一个datetime类型，表示当前的日期和时间，精确到微秒。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-meta">&gt;&gt;&gt; </span>today = datetime.now()<br><span class="hljs-meta">&gt;&gt;&gt; </span>today<br>datetime.datetime(<span class="hljs-number">2016</span>, <span class="hljs-number">9</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">29</span>, <span class="hljs-number">43</span>, <span class="hljs-number">928549</span>)<br></code></pre></td></tr></table></figure><p>使用datetime.utcnow()获得当前日期和时间对应的UTC（世界标准时间）时间对象，使用方法如下：</p><p><strong>datetime.utcnow</strong>()</p><p><strong>作用</strong>：返回datetime类型，表示当前日期和时间的UTC表示，精确到微秒。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>today = datetime.utcnow()<br><span class="hljs-meta">&gt;&gt;&gt; </span>today<br>datetime.datetime(<span class="hljs-number">2016</span>, <span class="hljs-number">9</span>, <span class="hljs-number">20</span>, <span class="hljs-number">2</span>, <span class="hljs-number">35</span>, <span class="hljs-number">1</span>, <span class="hljs-number">427954</span>)<br></code></pre></td></tr></table></figure><p>datetime.now()和datetime.utcnow()都返回一个datetime类型的对象，也可以直接使用datetime()构造一个日期和时间对象，使用方法如下：</p><p><strong>datetime(year, month, day, hour&#x3D;0, minute&#x3D;0,second&#x3D;0, microsecond&#x3D;0</strong>)</p><p><strong>作用</strong>：返回一个datetime类型，表示指定的日期和时间，可以精确到微秒。</p><p>调用datetime()函数直接创建一个datetime对象，表示2016年9月16日22:33，32秒7微秒，执行结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>someday = datetime(<span class="hljs-number">2016</span>,<span class="hljs-number">9</span>,<span class="hljs-number">16</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">32</span>,<span class="hljs-number">7</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>someday<br>datetime.datetime(<span class="hljs-number">2016</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">32</span>, <span class="hljs-number">7</span>)<br></code></pre></td></tr></table></figure><p>程序已经有了一个datetime对象，进一步可以利用这个对象的属性显示时间，为了区别datetime库名，采用上例中的someday代替生成的datetime对象</p><p><strong>datatime属性和描述</strong></p><p><img src="https://pic.imgdb.cn/item/65b8ee2a871b83018a264f4c.png" alt="datatime属性和描述"></p><p>datetime对象有3个常用的时间格式化方法，如表所示：</p><p><img src="https://pic.imgdb.cn/item/65b8ee2a871b83018a265003.png" alt="时间格式化方法"></p><p>isoformat()和isoweekday()方法的使用如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>someday = datetime(<span class="hljs-number">2016</span>,<span class="hljs-number">9</span>,<span class="hljs-number">16</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">32</span>,<span class="hljs-number">7</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>someday.isoformat()<br><span class="hljs-string">&#x27;2016-09-16T22:33:32.000007&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>someday.isoweekday()<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>strftime()方法是时间格式化最有效的方法，几乎可以以任何通用格式输出时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>someday.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)<br><span class="hljs-string">&#x27;2016-09-16 22:33:32&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>strftime()方法的格式化控制符</strong></p><p><img src="https://pic.imgdb.cn/item/65b8ee2a871b83018a2650eb.png" alt="strftime方法的格式化控制符"></p><p>strftime()格式化字符串的数字左侧会自动补零，上述格式也可以与print()的格式化函数一起使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br>&gt;&gt;&gt;now = datetime.now()<br>&gt;&gt;&gt;now.strftime(<span class="hljs-string">&quot;%Y-%m-%d&quot;</span>)<br><span class="hljs-string">&#x27;2016-09-20&#x27;</span><br>&gt;&gt;&gt;now.strftime(<span class="hljs-string">&quot;%A, %d. %B %Y %I:%M%p&quot;</span>)<br><span class="hljs-string">&#x27;Tuesday, 20. September 2016 01:53PM&#x27;</span><br><br>&gt;&gt;&gt;<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;今天是&#123;0:%Y&#125;年&#123;0:%m&#125;月&#123;0:%d&#125;日&quot;</span>.<span class="hljs-built_in">format</span>(now))<br>今天是<span class="hljs-number">2016</span>年09月<span class="hljs-number">20</span>日<br></code></pre></td></tr></table></figure><p>5.10 七段数码管绘制</p><p>七段数码管（seven-segment indicator）由7段数码管拼接而成，每段有亮或不亮两种情况，改进型的七段数码管还包括一个小数点位置</p><p>七段数码管能形成27&#x3D;128种不同状态，其中部分状态能够显示易于人们理解的数字或字母含义，因此被广泛使用</p><p><img src="https://pic.imgdb.cn/item/65b8ee2a871b83018a26522d.png" alt="七段数码管绘制"></p><p><img src="https://pic.imgdb.cn/item/65b8ee2b871b83018a265311.png" alt="七段代码管绘制1"></p><h3 id="5-10-代码的复用和模块化设计"><a href="#5-10-代码的复用和模块化设计" class="headerlink" title="5.10 代码的复用和模块化设计"></a>5.10 代码的复用和模块化设计</h3><p>  函数是程序的一种基本抽象方式，它将一系列代码组织起来通过命名供其他程序使用。</p><p>  函数封装的直接好处是代码复用，任何其他代码只要输入参数即可调用函数，从而避免相同功能代码在被调用处重复编写。代码复用产生了另一个好处，当更新函数功能时，所有被调用处的功能都被更新。</p><p>当程序的长度在百行以上，如果不划分模块就算是最好的程序员也很难理解程序含义，程序的可读性就很糟糕了。</p><p>​    解决这一问题的最好方法是将一个程序分割成短小的程序段，每一段程序完成一个小的功能。无论面向过程和面向对象编程，对程序合理划分功能模块并基于模块设计程序是一种常用方法，被称为“模块化设计”。</p><p>模块化设计一般有两个基本要求：</p><p>紧耦合：尽可能合理划分功能块，功能块内部耦合紧密；</p><p>松耦合：模块间关系尽可能简单，功能块之间耦合度低。</p><p>  使用函数只是模块化设计的必要非充分条件，根据计算需求合理划分函数十分重要。一般来说，完成特定功能或被经常复用的一组语句应该采用函数来封装，并尽可能减少函数间参数和返回值的数量。</p><h3 id="5-11-函数的递归"><a href="#5-11-函数的递归" class="headerlink" title="5.11 函数的递归"></a>5.11 函数的递归</h3><h4 id="5-11-1-递归的定义"><a href="#5-11-1-递归的定义" class="headerlink" title="5.11.1 递归的定义"></a>5.11.1 递归的定义</h4><p>  函数作为一种代码封装，可以被其他程序调用，当然，也可以被函数内部代码调用。这种函数定义中调用函数自身的方式称为递归。就像一个人站在装满镜子的房间中，看到的影像就是递归的结果。递归在数学和计算机应用上非常强大，能够非常简洁的解决重要问题。</p><p>阶乘的例子揭示了递归的2个关键特征：</p><p>（1）存在一个或多个基例，基例不需要再次递归，它是确定的表达式；</p><p>（2）所有递归链要以一个或多个基例结尾。</p><p><img src="https://pic.imgdb.cn/item/65b8ee32871b83018a2673ca.png" alt="递归实例1"></p><p><img src="https://pic.imgdb.cn/item/65b8ee33871b83018a267448.png" alt="递归实例1原理"></p><p><img src="https://pic.imgdb.cn/item/65b8ee33871b83018a2674c1.png" alt="递归实例2"></p><p>​    观察这个函数的工作过程。s[0]是首字符，s[1:]是剩余字符串，将它们反向连接，可以得到反转字符串。执行这个程序，结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">s</span>):<br>       <span class="hljs-keyword">return</span> reverse(s[<span class="hljs-number">1</span>:]) + s[<span class="hljs-number">0</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>reverse(<span class="hljs-string">&quot;ABC&quot;</span>)<br>...<br>RecursionError: maximum recursion depth exceeded<br></code></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/65b8ee33871b83018a267529.png" alt="实例2更改png"></p><h4 id="5-11-2-科赫曲线绘制"><a href="#5-11-2-科赫曲线绘制" class="headerlink" title="5.11.2 科赫曲线绘制"></a>5.11.2 科赫曲线绘制</h4><p>自然界有很多图形很规则，符合一定的数学规律，例如，蜜蜂蜂窝是天然的等边六角形等。<strong>科赫</strong>(Koch)<strong>曲线</strong>在众多经典数学曲线中非常著名，由瑞典数学家冯·科赫(H·V·Koch)于1904年提出，由于其<strong>形状类似雪花，也被称为雪花曲线</strong>。</p><p>科赫曲线的基本概念和绘制方法如下：</p><p>  正整数n代表科赫曲线的阶数，表示生成科赫曲线过程的操作次数。科赫曲线初始化阶数为0，表示一个长度为L的直线。对于直线L，将其等分为三段，中间一段用边长为L&#x2F;3的等边三角形的两个边替代，得到1阶科赫曲线，它包含四条线段。进一步对每条线段重复同样的操作后得到2阶科赫曲线。继续重复同样的操作n次可以得到n阶科赫曲线。</p><p>科赫曲线属于分形几何分支，它的绘制过程体现了递归思想，绘制过程代码。</p><h4 id="5-12-Python内置函数"><a href="#5-12-Python内置函数" class="headerlink" title="5.12 Python内置函数"></a>5.12 Python内置函数</h4><p>Python解释器提供了68个内置函数，其中，前36个已经讲解过，需要掌握。</p><p><img src="https://pic.imgdb.cn/item/65b8ee33871b83018a2675d6.png" alt="python内置函数"></p><h2 id="六-组合数据类型"><a href="#六-组合数据类型" class="headerlink" title="六.组合数据类型"></a>六.组合数据类型</h2><p>  组合数据类型能够将多个同类型或不同类型的数据组织起来，通过单一的表示使数据操作更有序更容易。 </p><p>  根据数据之间的关系，组合数据类型可以分为三类：</p><p>  序列类型、集合类型和映射类型。</p><p><img src="https://pic.imgdb.cn/item/65b8ee39871b83018a269064.png" alt="组合数据类型"></p><p>•序列类型是一个元素向量，元素之间存在先后关系，通过序号访问，元素之间不排他。</p><p>•集合类型是一个元素集合，元素之间无序，相同元素在集合中唯一存在。</p><p>•映射类型是“键-值”数据项的组合，每个元素是一个键值对，表示为(key, value)。</p><h3 id="6-1-序列类型"><a href="#6-1-序列类型" class="headerlink" title="6.1 序列类型"></a>6.1 序列类型</h3><p>序列类型是一维元素向量，元素之间存在先后关系，通过序号访问。</p><p>同样由于元素之间存在顺序关系，所以序列中可以存在相同数值但位置不同的元素。</p><p>序列类型支持成员关系操作符（in）、长度计算函数（len()）、分片（[]），元素本身也可以是序列类型。  </p><p>Python语言中有很多数据类型都是序列类型，其中比较重要的是：str（字符串）、tuple（元组）和list（列表）。</p><p>•<strong>元组</strong>是包含0个或多个数据项的不可变序列类型。元组生成后是固定的，其中任何数据项不能替换或删除。</p><p>•<strong>列表</strong>则是一个可以修改数据项的序列类型，使用也最灵活。 </p><p>​                                                                            <strong>序列类型的通用操作符</strong></p><p><img src="https://pic.imgdb.cn/item/65b8ee39871b83018a269128.png" alt="序列类型的通用操作符"></p><p>​                                                                            <strong>序列类型的通用函数</strong></p><p><img src="https://pic.imgdb.cn/item/65b8ee3a871b83018a2691da.png" alt="序列类型的通用函数"></p><p>enumerate()函数将一个可遍历的对象（如列表、元组、字符串）组合成索引序列，同时列出数据和数据下标。一般用于for循环中。</p><p> 语法格式：enumerate(sequence，[start&#x3D;0])</p><p>•sequence—–一个序列或者其他可迭代对象</p><p>•start——–设置下标起始位置，此项可省略</p><p>•返回值：enumerate(枚举)对象</p><h4 id="6-1-1-字符串"><a href="#6-1-1-字符串" class="headerlink" title="6.1.1 字符串"></a>6.1.1 字符串</h4><h4 id="6-1-2-元组"><a href="#6-1-2-元组" class="headerlink" title="6.1.2 元组"></a>6.1.2 元组</h4><p>元组（tuple）是序列类型中比较特殊的类型，因为它一旦创建就不能被修改。</p><p>元组类型在表达固定数据项、函数多返回值、多变量同步赋值、循环遍历等情况下十分有用。</p><p>Python中元组采用逗号和圆括号（可选）来表示。</p><p>tuple&#x3D;（元素1，元素2，…，元素N）</p><h5 id="创建元组"><a href="#创建元组" class="headerlink" title="创建元组"></a><strong>创建元组</strong></h5><p><strong>创建空元组：</strong>  元组名&#x3D;() 或 元组名&#x3D;tuple()</p><p><strong>创建只有一个元素的元组</strong>：  元组名&#x3D;（元素，）</p><p>   <strong>元组只包含一个元素时，需要在元素后面加逗号，否则括号会被当成运算符。</strong></p><p>​    tup&#x3D;(1)   tup的类型是int</p><p>​    tup&#x3D;(1,)   tup的类型是tuple</p><p><strong>创建多个元素的元组：</strong>   元素名&#x3D;（元素1,…元素N）元素名&#x3D;元素1，…，元素N</p><h5 id="元组访问"><a href="#元组访问" class="headerlink" title="元组访问"></a><strong>元组访问</strong></h5><p><strong>可以使用索引来访问元组中的元素。</strong></p><p><strong>访问单个元素</strong>，语法：元组名[索引] </p><p>​              返回的数据类型是元素对应的类型</p><p><strong>访问多个元素</strong>，语法：元组名[M：N] </p><p>​              返回的数据类型是元组类型</p><p><strong>访问多级元素</strong>，语法：元组名[第1级索引]   [第2级索引]</p><h5 id="元组操作"><a href="#元组操作" class="headerlink" title="元组操作"></a><strong>元组操作</strong></h5><p><strong>元组元素不允许修改、删除</strong></p><p><strong>元组可以删除，使用del语句删除整个元组</strong></p><p><strong>元组转换函数 ：tuple(iterable)</strong> </p><p><strong>将可迭代类型数据转换成元组，iterable可以是字符串、列表、集合、字典。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"> **&gt;&gt;&gt;<span class="hljs-built_in">tuple</span>(‘hello’)   <span class="hljs-comment">#****类型转换**</span><br>(<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="6-1-3-列表"><a href="#6-1-3-列表" class="headerlink" title="6.1.3 列表"></a>6.1.3 列表</h4><p>  <strong>列表（list）是包含0个或多个对象引用的有序序列，属于序列类型。</strong>与元组不同，列表的长度和内容都是可变的，可自由对列表中数据项进行增加、删除或替换。列表没有长度限制，元素类型可以不同，使用非常灵活。 列表可以采用标准的比较操作符（&lt;、&lt;&#x3D;、&#x3D;&#x3D;、!&#x3D;、&gt;&#x3D;、&gt;）进行比较，列表的比较实际上是单个数据项的逐个比较。</p><h5 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a><strong>创建列表</strong></h5><p><strong>创建空列表：</strong> </p><p>​        1、列表变量&#x3D;[]</p><p>​        2、列表变量&#x3D;list()</p><p><strong>创建多个元素的列表：</strong>   </p><p>​        1、列表变量&#x3D;[元素1,…，元素N]</p><p>​        2、列表变量&#x3D;list(seq)    将序列转换为列表</p><p>​        3、列表推导式创建</p><p><strong>列表推导式</strong>：是一个表达式，也是一个循环，该循环是可选的、包含在[]中的条件。作用是为列表生成数据项。并且可以使用if语句过滤不需要的数据项。</p><p>其语法格式如下：将iterable中的数据项生成列表，等价list(iterable)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">[表达式 <span class="hljs-keyword">for</span> 变量 <span class="hljs-keyword">in</span> 列表] <br>[out_exp_res <span class="hljs-keyword">for</span> out_exp <span class="hljs-keyword">in</span> input_list]<br>或者 <br>[表达式 <span class="hljs-keyword">for</span> 变量 <span class="hljs-keyword">in</span> 列表 <span class="hljs-keyword">if</span> 条件]<br>[out_exp_res <span class="hljs-keyword">for</span> out_exp <span class="hljs-keyword">in</span> input_list <span class="hljs-keyword">if</span> condition]<br>out_exp_res：列表生成元素表达式，可以是有返回值的函数。<br><span class="hljs-keyword">for</span> out_exp <span class="hljs-keyword">in</span> input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。<br><span class="hljs-keyword">if</span> condition：条件语句，可以过滤列表中不符合条件的值。<br></code></pre></td></tr></table></figure><h5 id="列表操作示例"><a href="#列表操作示例" class="headerlink" title="列表操作示例"></a><strong>列表操作示例</strong></h5><p>列表用中括号（[]）表示，也可以通过list()函数将元组或字符串转化成列表。直接使用list()函数会返回一个空列表。</p><p><img src="https://pic.imgdb.cn/item/65b8ee3a871b83018a26929f.png" alt="列表操作事例"></p><h5 id="列表类型的概念"><a href="#列表类型的概念" class="headerlink" title="列表类型的概念"></a><strong>列表类型的概念</strong></h5><p>与整数和字符串不同，列表要处理一组数据，因此，列表必须通过显式的数据赋值才能生成，简单将一个列表赋值给另一个列表不会生成新的列表对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;ls = [<span class="hljs-number">425</span>, <span class="hljs-string">&quot;BIT&quot;</span>, <span class="hljs-number">1024</span>]  <span class="hljs-comment">#用数据赋值产生列表ls</span><br>&gt;&gt;&gt;lt = ls       <span class="hljs-comment">#lt是ls所对应数据的引用，lt并不包含真实数据</span><br>&gt;&gt;&gt;ls[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>     <br>&gt;&gt;&gt;lt<br>[<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;BIT&#x27;</span>, <span class="hljs-number">1024</span>]<br></code></pre></td></tr></table></figure><h5 id="访问列表"><a href="#访问列表" class="headerlink" title="访问列表"></a><strong>访问列表</strong></h5><p><strong>可以使用索引来访问列表中的元素。列表可以同时使用正向递增序号和反向递减序号。</strong></p><p><strong>访问单个元素</strong>，语法：列表变量[索引] </p><p>​              返回的数据类型是元素对应的类型</p><p><strong>访问多个元素</strong>，语法：列表变量[M:N] </p><p>​              返回的数据类型是列表类型</p><p><strong>访问多级元素</strong>，语法：列表变量[第1级索引] [第2级索引]</p><h5 id="修改列表"><a href="#修改列表" class="headerlink" title="修改列表"></a><strong>修改列表</strong></h5><p><strong>更新列表元素值：</strong>  </p><p>​      列表变量[索引]&#x3D;值 </p><p><strong>添加新的列表元素：</strong>  </p><p>​    1、列表变量.append(x)  将元素x追加到列表最后</p><p>​    2、列表变量.insert(i,x)  将元素x插入到列表的第i位</p><h5 id="删除列表"><a href="#删除列表" class="headerlink" title="删除列表"></a><strong>删除列表</strong></h5><p><strong>删除列表元素：</strong> </p><p>​      1、del 列表变量[索引] </p><p>​      2、列表变量.remove(元素)</p><p><strong>清空列表：</strong></p><p>​      列表变量.clear() </p><p><strong>删除列表：</strong>  </p><p>​      del 列表变量    </p><h5 id="列表类型的操作符"><a href="#列表类型的操作符" class="headerlink" title="列表类型的操作符"></a><strong>列表类型的操作符</strong></h5><p>列表是序列类型，因此序列的操作符和函数都可应用到列表类型。</p><p>由于列表是可变的，表6.4给出了列表类型额外的14个常用函数或方法。</p><p><img src="https://pic.imgdb.cn/item/65b8ee3a871b83018a26937a.png" alt="列表特有的函数或方法"></p><p>当使用一个列表改变另一个列表值时，Python不要求两个列表长度一样，但遵循“多增少减”的原则，例子如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;vlist[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]=[<span class="hljs-string">&quot;new_bit&quot;</span>, <span class="hljs-string">&quot;new_computer&quot;</span>, <span class="hljs-number">123</span>]<br>&gt;&gt;&gt;vlist<br>[<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;new_bit&#x27;</span>, <span class="hljs-string">&#x27;new_computer&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-number">4</span>]<br>&gt;&gt;&gt;vlist[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]=[<span class="hljs-string">&quot;fewer&quot;</span>]<br>&gt;&gt;&gt;vlist<br>[<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;fewer&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p><strong>一次提取两个或多个数据项时，我们可以使用序列拆分完成，任意可迭代数据类型均可使用。注意：当*出现在赋值语句左边时，是序列拆分符。</strong></p><p><img src="https://pic.imgdb.cn/item/65b8ee3f871b83018a26a94d.png" alt="序列拆分符"></p><p>  与元组一样，列表可以通过for…in语句对其元素进行遍历，基本语法结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> &lt;任意变量名&gt; <span class="hljs-keyword">in</span> &lt;列表名&gt;:<br>    语句块<br></code></pre></td></tr></table></figure><p>   列表是一个十分灵活的数据结构，它具有处理任意长度、混合类型的能力，并提供了丰富的基础操作符和方法。当程序需要使用组合数据类型管理批量数据时，请尽量使用列表类型。</p><h3 id="6-2-集合类型"><a href="#6-2-集合类型" class="headerlink" title="6.2 集合类型"></a>6.2 集合类型</h3><p>集合类型主要用于三个场景：成员关系测试、元素去重和删除数据项，例子如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-string">&quot;BIT&quot;</span> <span class="hljs-keyword">in</span> &#123;<span class="hljs-string">&quot;PYTHON&quot;</span>, <span class="hljs-string">&quot;BIT&quot;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&quot;GOOD&quot;</span>&#125; <span class="hljs-comment">#成员关系测试</span><br><span class="hljs-literal">True</span><br>&gt;&gt;&gt;tup = (<span class="hljs-string">&quot;PYTHON&quot;</span>, <span class="hljs-string">&quot;BIT&quot;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&quot;GOOD&quot;</span>, <span class="hljs-number">123</span>) <span class="hljs-comment">#元素去重</span><br>&gt;&gt;&gt;<span class="hljs-built_in">set</span>(tup)<br>&#123;<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;GOOD&#x27;</span>, <span class="hljs-string">&#x27;BIT&#x27;</span>, <span class="hljs-string">&#x27;PYTHON&#x27;</span>&#125;<br>&gt;&gt;&gt;newtup = <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">set</span>(tup)–&#123;<span class="hljs-string">&#x27;PYTHON&#x27;</span>&#125;) <span class="hljs-comment"># 去重同时删除数据项</span><br>(<span class="hljs-string">&#x27;GOOD&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;BIT&#x27;</span>) <br></code></pre></td></tr></table></figure><p>集合类型与其他类型最大的不同在于它不包含重复元素，因此，当需要对一维数据进行去重或进行数据重复处理时，一般通过集合来完成。</p><h4 id="6-2-1-集合"><a href="#6-2-1-集合" class="headerlink" title="6.2.1 集合"></a>6.2.1 集合</h4><p>  集合类型与数学中集合的概念一致，即包含0个或多个数据项的无序组合。</p><p>  集合中元素不可重复，元素类型只能是固定数据类型，例如：整数、浮点数、字符串、元组等。</p><p>  列表、字典和集合类型本身都是可变数据类型，不能作为集合的元素出现。</p><h5 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h5><p>集合用{}表示，可以用赋值语句生成一个集合</p><p><strong>创建空集合：</strong> </p><p>​      集合名&#x3D;set()，不能直接用{}创建</p><p><strong>创建非空集合：</strong>  </p><p>​      1、集合名&#x3D;{元素1,…,元素N} </p><p>​      2、集合名&#x3D;set(x)，x为任意组合数据类型</p><p><strong>集合类型转换：</strong>set()，将任意组合类型转为集合</p><h5 id="操作集合"><a href="#操作集合" class="headerlink" title="操作集合"></a>操作集合</h5><p>由于集合无序性，没有索引和位置的概念，不能分片；打印效果与定义顺序可以不一致。</p><p>由于集合互异性，使用集合类型能够过滤掉重复元素。</p><p>集合中元素可以动态增加或删除。</p><h5 id="修改集合"><a href="#修改集合" class="headerlink" title="修改集合"></a>修改集合</h5><p><strong>添加新的集合元素：</strong>  </p><p>1、集合变量.add(x)  将元素x添加到集合中，若x已存在则不进行任何操作</p><p>2、集合变量.update(x)  将x添加到集合中，x可以是列表、元组、字典等可迭代对象。</p><h5 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h5><p><strong>删除集合元素：</strong> </p><p>​      1、集合变量.discard(x)  x若不存在，不发生错误</p><p>​      2、集合变量.remove(x)  x若不存在，会发生错误</p><p>​      3、集合变量.pop()     随机删除一个元素</p><p><strong>清空集合：</strong></p><p>​      集合变量.clear()  </p><h5 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a><strong>集合操作</strong></h5><p>集合类型具有10个操作符</p><p><img src="https://pic.imgdb.cn/item/65b8ee3f871b83018a26aa47.png" alt="集合操作"></p><p>上述操作符表达了集合类型的4种基本操作，交集（&amp;）、并集（|）、差集（-）、补集（^），操作逻辑与数学定义相同</p><p><img src="https://pic.imgdb.cn/item/65b8ee40871b83018a26aac8.png" alt="集合操作1"></p><p>集合类型有10个操作函数或方法 </p><p><img src="https://pic.imgdb.cn/item/65b8ee40871b83018a26aba7.png" alt="集合操作2"></p><h3 id="6-3映射类型"><a href="#6-3映射类型" class="headerlink" title="6.3映射类型"></a>6.3映射类型</h3><p>  映射类型是“键-值”数据项的组合，每个元素是一个键值对，即元素是(key, value)，元素之间是无序的。键值对(key, value)是一种二元关系。在Python中，映射类型主要以<strong>字典（dict</strong>）体现。</p><p><img src="https://pic.imgdb.cn/item/65b8ee40871b83018a26ac33.png" alt="映射类型"></p><h4 id="6-3-1-字典"><a href="#6-3-1-字典" class="headerlink" title="6.3.1 字典"></a>6.3.1 字典</h4><h5 id="字典类型的基本概念"><a href="#字典类型的基本概念" class="headerlink" title="字典类型的基本概念"></a>字典类型的基本概念</h5><p>   通过任意键信息查找一组数据中值信息的过程叫映射，Python语言中通过字典实现映射。Python语言中的字典可以通过大括号({})建立，建立模式如下：</p><p>{&lt;键1&gt;:&lt;值1&gt;, &lt;键2&gt;:&lt;值2&gt;, … , &lt;键n&gt;:&lt;值n&gt;}</p><p> 其中，键和值通过冒号连接，不同键值对通过逗号隔开。</p><p><strong>键必须是唯一的，值可以相同；</strong></p><p><strong>键必须是不可变的，如字符串，数字，元组。</strong></p><p><strong>值可以取任何数据类型。</strong></p><p>字典打印出来的顺序与创建之初的顺序不同，这不是错误。字典是集合类型的延续，各个元素没有顺序之分</p><h5 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h5><p><strong>创建空字典：</strong> </p><p>​      字典变量&#x3D;{}</p><p>​      字典变量&#x3D;dict()</p><p><strong>创建非空字典</strong>：  </p><p>​      字典变量&#x3D;{&lt;键1&gt;:&lt;值1&gt;, &lt;键2&gt;:&lt;值2&gt;, … , &lt;键n&gt;:&lt;值n&gt;}</p><h5 id="访问字典"><a href="#访问字典" class="headerlink" title="访问字典"></a>访问字典</h5><p>字典可以使用key来访问字典中的元素。</p><p>采用中括号格式，语法：</p><p>​          值&#x3D;字典变量[键] </p><p>采用字典类型的方法：</p><p>​           值&#x3D;字典变量.get(键,default&#x3D;None)             </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;Dcountry=&#123;<span class="hljs-string">&quot;中国&quot;</span>:<span class="hljs-string">&quot;北京&quot;</span>, <span class="hljs-string">&quot;美国&quot;</span>:<span class="hljs-string">&quot;华盛顿&quot;</span>, <span class="hljs-string">&quot;法国&quot;</span>:<span class="hljs-string">&quot;巴黎&quot;</span>&#125;<br><br>&gt;&gt;&gt;Dcountry[<span class="hljs-string">&quot;中国&quot;</span>]<br><span class="hljs-string">&#x27;北京&#x27;</span><br><br>&gt;&gt;&gt;Dcountry.get(<span class="hljs-string">&#x27;美国&#x27;</span>)<br>‘华盛顿’<br><br></code></pre></td></tr></table></figure><p>**get()**中键对应的值存在，就返回值；不存在，就返回默认值</p><h5 id="采用字典类型的方法："><a href="#采用字典类型的方法：" class="headerlink" title="采用字典类型的方法："></a><strong>采用字典类型的方法：</strong></h5><p>1、字典变量.keys()，返回字典中所有的键信息。</p><p>2、字典变量.values()，返回字典中所有的值信息。</p><p>3、字典变量.items()，返回所有的键值对。</p><p>可以使用list()将以上返回值类型转换成列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;Dcountry=&#123;<span class="hljs-string">&quot;中国&quot;</span>:<span class="hljs-string">&quot;北京&quot;</span>, <span class="hljs-string">&quot;美国&quot;</span>:<span class="hljs-string">&quot;华盛顿&quot;</span>, <span class="hljs-string">&quot;法国&quot;</span>:<span class="hljs-string">&quot;巴黎&quot;</span>&#125;<br>&gt;&gt;&gt;Dcountry.keys()<br>dict_keys([<span class="hljs-string">&#x27;中国&#x27;</span>, <span class="hljs-string">&#x27;美国&#x27;</span>, <span class="hljs-string">&#x27;法国&#x27;</span>])<br>&gt;&gt;&gt;Dcountry.values()<br>dict_values([<span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;华盛顿&#x27;</span>, <span class="hljs-string">&#x27;巴黎&#x27;</span>])<br>&gt;&gt;&gt;Dcountry.items()<br>dict_items([(<span class="hljs-string">&#x27;中国&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>), (<span class="hljs-string">&#x27;美国&#x27;</span>, <span class="hljs-string">&#x27;华盛顿&#x27;</span>), (<span class="hljs-string">&#x27;法国&#x27;</span>, <span class="hljs-string">&#x27;巴黎&#x27;</span>)])<br></code></pre></td></tr></table></figure><h5 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h5><p><strong>更新键值对信息：</strong>  </p><p>​      字典变量[键]&#x3D;值 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;Dcountry[<span class="hljs-string">&quot;中国&quot;</span>]=<span class="hljs-string">&#x27;大北京&#x27;</span><br>&gt;&gt;&gt;<span class="hljs-built_in">print</span>(Dcountry)<br>&#123;<span class="hljs-string">&#x27;中国&#x27;</span>: <span class="hljs-string">&#x27;大北京&#x27;</span>, <span class="hljs-string">&#x27;法国&#x27;</span>: <span class="hljs-string">&#x27;巴黎&#x27;</span>, <span class="hljs-string">&#x27;美国&#x27;</span>: <span class="hljs-string">&#x27;华盛顿&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>添加新的键值对：</strong>  </p><p>​      字典变量[键]&#x3D;值  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;Dcountry=&#123;<span class="hljs-string">&quot;中国&quot;</span>:<span class="hljs-string">&quot;北京&quot;</span>, <span class="hljs-string">&quot;美国&quot;</span>:<span class="hljs-string">&quot;华盛顿&quot;</span>, <span class="hljs-string">&quot;法国&quot;</span>:<span class="hljs-string">&quot;巴黎&quot;</span>&#125;<br>&gt;&gt;&gt;Dcountry[<span class="hljs-string">&quot;英国&quot;</span>]=<span class="hljs-string">&quot;伦敦&quot;</span><br>&gt;&gt;&gt;<span class="hljs-built_in">print</span>(Dcountry)<br>&#123;<span class="hljs-string">&#x27;中国&#x27;</span>: <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;法国&#x27;</span>: <span class="hljs-string">&#x27;巴黎&#x27;</span>, <span class="hljs-string">&#x27;美国&#x27;</span>: <span class="hljs-string">&#x27;华盛顿&#x27;</span>, <span class="hljs-string">&#x27;英国&#x27;</span>: <span class="hljs-string">&#x27;伦敦&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h5 id="删除字典"><a href="#删除字典" class="headerlink" title="删除字典"></a>删除字典</h5><p>删除键值对： </p><p>​      del 字典变量[键] </p><p>清空字典： </p><p>​      字典变量.clear()  </p><p>删除字典：  </p><p>​      del 字典变量</p><h5 id="字典类型的操作"><a href="#字典类型的操作" class="headerlink" title="字典类型的操作"></a>字典类型的操作</h5><p>字典是实现键值对映射的数据结构，请理解如下基本原则：</p><p>字典是一个键值对的集合，该集合以键为索引，一个键信息只对应一个值信息；</p><p>字典中元素以键信息为索引访问；</p><p>字典长度是可变的，可以通过对键信息赋值实现增加或修改键值对。 </p><p><img src="https://pic.imgdb.cn/item/65b8ee45871b83018a26c1f8.png" alt="字典类型的操作"></p><p>  与其他组合类型一样，字典可以通过for…in语句对其元素进行遍历，基本语法结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> &lt;变量名&gt; <span class="hljs-keyword">in</span> &lt;字典名&gt;:<br><br>      语句块<br></code></pre></td></tr></table></figure><p>此时for循环返回的变量名是字典的索引值key</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> Dcountry:<br>   <span class="hljs-built_in">print</span>(key)<br>中国<br>美国<br>法国<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> &lt;字典名&gt;.items():<br><br>    语句块<br></code></pre></td></tr></table></figure><p>此时for循环返回的两个变量是字典的key和value</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">dic=&#123;<span class="hljs-string">&quot;中国&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;美国&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;俄罗斯&quot;</span>:<span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(dic.items(),key= <span class="hljs-keyword">lambda</span> item:item[<span class="hljs-number">1</span>],reverse=<span class="hljs-literal">True</span>):<span class="hljs-comment">#</span><br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;&#125; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(k,v))<br>俄罗斯 <span class="hljs-number">3</span><br>美国 <span class="hljs-number">2</span><br>中国 <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h5 id="补充内容：sorted"><a href="#补充内容：sorted" class="headerlink" title="补充内容：sorted()"></a>补充内容：sorted()</h5><p>   sorted() 函数对所有可迭代的对象进行排序操作。    </p><p>   sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</p><p>   语法格式：sorted(iterable, key&#x3D;None, reverse&#x3D;False)</p><p>•iterable—–可迭代对象</p><p>•key——–设置用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</p><p>•返回值：返回重新排序的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;dic=&#123;<span class="hljs-string">&quot;中国&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;美国&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;俄罗斯&quot;</span>:<span class="hljs-number">3</span>&#125;<br>&gt;&gt;&gt;<span class="hljs-built_in">sorted</span>(dic.items(),key= <span class="hljs-keyword">lambda</span> item:item[<span class="hljs-number">1</span>],reverse=<span class="hljs-literal">True</span>):<br><span class="hljs-comment">#item[1]表示按字典的value排序，item[0]按字典的key排序</span><br> [(<span class="hljs-string">&#x27;俄罗斯&#x27;</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&#x27;美国&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;中国&#x27;</span>, <span class="hljs-number">1</span>)]<br>   <br>&gt;&gt;&gt;<span class="hljs-built_in">sorted</span>(dic) <span class="hljs-comment">#给dic的key排序</span><br>[<span class="hljs-string">&#x27;中国&#x27;</span>, <span class="hljs-string">&#x27;俄罗斯&#x27;</span>, <span class="hljs-string">&#x27;美国&#x27;</span>]<br><br></code></pre></td></tr></table></figure><h3 id="6-4-基本统计值的计算"><a href="#6-4-基本统计值的计算" class="headerlink" title="6.4 基本统计值的计算"></a>6.4 基本统计值的计算</h3><p>   以最简单的统计问题为例，求解一组不定长数据的基本统计值，即平均值、标准差、中位数。</p><p>由于平均数、标准差和中位数是三个不同的计算目标，使用函数方式编写计算程序。</p><p> getNum()函数从用户输入获得数据</p><p> mean()函数计算平均值</p><p> dev()函数计算标准差</p><p> median()函数计算中位数</p><p>列表在实现基本数据统计时发挥了重要作用，表现在：</p><p>列表是一个动态长度的数据结构，可以根据需求增加或减少元素；</p><p>列表的一系列方法或操作符为计算提供了简单的元素运算手段；</p><p>列表提供了对每个元素的简单访问方式及所有元素的遍历方式。</p><h3 id="6-5-jieba库的使用"><a href="#6-5-jieba库的使用" class="headerlink" title="6.5 jieba库的使用"></a>6.5 jieba库的使用</h3><h4 id="6-5-1-jieba库的概述"><a href="#6-5-1-jieba库的概述" class="headerlink" title="6.5.1 jieba库的概述"></a>6.5.1 jieba库的概述</h4><p>jieba是Python中一个重要的第三方<strong>中文分词函数库</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">import</span> jieba<br>&gt;&gt;&gt;jieba.lcut(<span class="hljs-string">&quot;中国是一个伟大的国家&quot;</span>)<br>[<span class="hljs-string">&#x27;中国&#x27;</span>, <span class="hljs-string">&#x27;是&#x27;</span>, <span class="hljs-string">&#x27;一个&#x27;</span>, <span class="hljs-string">&#x27;伟大&#x27;</span>, <span class="hljs-string">&#x27;的&#x27;</span>, <span class="hljs-string">&#x27;国家&#x27;</span>]<br></code></pre></td></tr></table></figure><p>jieba库是第三方库，不是安装包自带，需要通过pip指令安装</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">:\&gt;pip install jieba   # 或者 pip3 install jieba<br></code></pre></td></tr></table></figure><p><strong>jieba</strong>函数库支持三种分词模式：</p><p>1.<strong>精确模式：</strong>将句子最精准地切开，适合文本分析</p><p>2.<strong>全模式：</strong>把句子所有可以成词的词语都扫描出来，速度非常快，但是不能消除歧义</p><p>3.<strong>搜索引擎模式：</strong>在精确模式的基础上，对长词再次切分，适用于搜索引擎分词</p><p><img src="https://pic.imgdb.cn/item/65b8ee46871b83018a26c59e.png" alt="jieba库"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">import</span> jieba<br>&gt;&gt;&gt;jieba.lcut(<span class="hljs-string">&quot;中华人民共和国是一个伟大的国家&quot;</span>)<br>[<span class="hljs-string">&#x27;中华人民共和国&#x27;</span>, <span class="hljs-string">&#x27;是&#x27;</span>, <span class="hljs-string">&#x27;一个&#x27;</span>, <span class="hljs-string">&#x27;伟大&#x27;</span>, <span class="hljs-string">&#x27;的&#x27;</span>, <span class="hljs-string">&#x27;国家&#x27;</span>]<br>&gt;&gt;&gt;jieba.lcut(<span class="hljs-string">&quot;中华人民共和国是一个伟大的国家&quot;</span>, cut_all=<span class="hljs-literal">True</span>)<br>[<span class="hljs-string">&#x27;中华&#x27;</span>, <span class="hljs-string">&#x27;中华人民&#x27;</span>, <span class="hljs-string">&#x27;中华人民共和国&#x27;</span>, <span class="hljs-string">&#x27;华人&#x27;</span>, <span class="hljs-string">&#x27;人民&#x27;</span>, <span class="hljs-string">&#x27;人民共和国&#x27;</span>, <span class="hljs-string">&#x27;共和&#x27;</span>, <span class="hljs-string">&#x27;共和国&#x27;</span>, <span class="hljs-string">&#x27;国是&#x27;</span>, <span class="hljs-string">&#x27;一个&#x27;</span>, <span class="hljs-string">&#x27;伟大&#x27;</span>, <span class="hljs-string">&#x27;的&#x27;</span>, <span class="hljs-string">&#x27;国家&#x27;</span>]<br>&gt;&gt;&gt;jieba.lcut_for_search(<span class="hljs-string">&quot;中华人民共和国是一个伟大的国家&quot;</span>)<br>[<span class="hljs-string">&#x27;中华&#x27;</span>, <span class="hljs-string">&#x27;华人&#x27;</span>, <span class="hljs-string">&#x27;人民&#x27;</span>, <span class="hljs-string">&#x27;共和&#x27;</span>, <span class="hljs-string">&#x27;共和国&#x27;</span>, <span class="hljs-string">&#x27;中华人民共和国&#x27;</span>, <span class="hljs-string">&#x27;是&#x27;</span>, <span class="hljs-string">&#x27;一个&#x27;</span>, <span class="hljs-string">&#x27;伟大&#x27;</span>, <span class="hljs-string">&#x27;的&#x27;</span>, <span class="hljs-string">&#x27;国家&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="6-5-2-文本词频统计"><a href="#6-5-2-文本词频统计" class="headerlink" title="6.5.2 文本词频统计"></a>6.5.2 文本词频统计</h4><p><strong>《Hamlet》英文词频统计</strong></p><p><img src="https://pic.imgdb.cn/item/65b8ee46871b83018a26c67a.png" alt="英文词频统计"></p><p>运行程序后，输出结果如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt; <br>to          <span class="hljs-number">754</span><br>hamlet      <span class="hljs-number">462</span><br>it          <span class="hljs-number">416</span><br>that        <span class="hljs-number">391</span><br><span class="hljs-keyword">is</span>          <span class="hljs-number">340</span><br><span class="hljs-keyword">not</span>         <span class="hljs-number">314</span><br>lord        <span class="hljs-number">309</span><br>his         <span class="hljs-number">296</span><br>this        <span class="hljs-number">295</span><br>but         <span class="hljs-number">269</span><br></code></pre></td></tr></table></figure><p><strong>《三国演义》人物出场统计</strong></p><p><img src="https://pic.imgdb.cn/item/65b8ee46871b83018a26c76f.png" alt="三国演义人物出场统计"></p><p><img src="https://pic.imgdb.cn/item/65b8ee46871b83018a26c81c.png" alt="三国演义人物出场统计1"></p><p>输出排序前5的单词，运行程序后，输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt; <br>曹操         <span class="hljs-number">1451</span><br>孔明         <span class="hljs-number">1383</span><br>刘备         <span class="hljs-number">1252</span><br>关羽          <span class="hljs-number">784</span><br>张飞          <span class="hljs-number">358</span><br></code></pre></td></tr></table></figure><h2 id="七-网络爬虫"><a href="#七-网络爬虫" class="headerlink" title="七.网络爬虫"></a>七.网络爬虫</h2><p>requests库——爬取HTML页面  </p><p>Beautiful S oup库——-解析HTML页面  </p><p>Re库——正则表达式库，提取页面关键信息  </p><p>Scrapy库——-专业网络爬虫框架</p><h3 id="7-1-Http协议及requests库方法"><a href="#7-1-Http协议及requests库方法" class="headerlink" title="7.1 Http协议及requests库方法"></a>7.1 Http协议及requests库方法</h3><p><strong>HTTP协议</strong> HTTP(Hypertextꢀ Transferꢀ Protoco)，超文本传输协议。是用 于从万维网（ WWW:World Wide Web ）服务器传输超文本到本地浏 览器的传送协议。  HTTP 工作原理：  • HTTP 协议工作于客户端-服务端架构上。  • 浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器 发送所有请求。  • Web 服务器根据接收到的请求后，向客户端发送响应信息。</p><p>HTTP协议 HTTP协议采用URL作为定位网络资源的标识，</p><p>URL格式如下：  <a href="http://host[:port][path]">http://host[:port][path]</a> </p><p>host:合法的Internet主机域名或IP地址  </p><p>port: 端口号，缺省端口为80</p><p>path:请求资源的路径，服务器上的内部路径</p><h3 id="7-2-HTTP协议对资源的操作"><a href="#7-2-HTTP协议对资源的操作" class="headerlink" title="7.2 HTTP协议对资源的操作"></a>7.2 HTTP协议对资源的操作</h3><p><img src="https://pic.imgdb.cn/item/65b8ee52871b83018a26f8c3.png" alt="http协议对资源的操作"></p><p><strong>理解PATCH和PUT的区别</strong> </p><p>假设URL位置有一组数据UserInfo，包括UserID、UserName等 20个字段  需求：用户修改了UserName，其他不变  • 采用PATCH，仅向URL提交UserName的局部更新请求  • 采用PUT，必须将所有20个字段一并提交到URL，未提交字段被删除  PATCH的最主要好处：节省网络带宽</p><p><strong>HTTP协议与Requests库</strong> </p><p><img src="https://pic.imgdb.cn/item/65b8ee52871b83018a26f9bf.png" alt="http协议与request库"></p><h3 id="7-3Requests库的7个主要方法"><a href="#7-3Requests库的7个主要方法" class="headerlink" title="7.3Requests库的7个主要方法"></a>7.3<strong>Requests库的7个主要方法</strong></h3><p><img src="https://pic.imgdb.cn/item/65b8ee52871b83018a26fb13.png" alt="request库的七个主要方法"></p><p>**requests.get(url, params&#x3D;None,****kwargs)</p><p>**requests.request(method, url, <strong>kwargs)</strong> </p><p><strong>method :请求方式，对应get&#x2F;put&#x2F;post等7种</strong>  </p><p><strong>url :  拟获取页面的url链接</strong>  </p><p><strong>kwargs:控制访问的参数，共13个</strong></p><p><strong>method :请求方式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">r=requests.request(<span class="hljs-string">&#x27;GET&#x27;</span>, url, **kwargs)<br>r=requests.request(<span class="hljs-string">&#x27;HEAD&#x27;</span>, url, **kwargs)<br>r=requests.request(<span class="hljs-string">&#x27;POST&#x27;</span>, url, **kwargs)<br>r=requests.request(<span class="hljs-string">&#x27;PUT&#x27;</span>, url, **kwargs)<br>r=requests.request(<span class="hljs-string">&#x27;PATCH&#x27;</span>, url, **kwargs)<br>r=requests.request(<span class="hljs-string">&#x27;DELETE&#x27;</span>, url, **kwargs)<br>r=requests.request(<span class="hljs-string">&#x27;OPTIONS&#x27;</span>, url, **kwargs)<br><br></code></pre></td></tr></table></figure><p><strong>kwargs:控制访问的参数，均为可选项</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">params :字典或字节序列，作为参数增加到url中<br>data:字典、字节序列或文件对象，作为Request的内容<br>json: JSON格式的数据，作为Request的内容<br>headers:字典，HTTP定制头<br>cookies:字典或CookieJar，Request中的cookie<br>auth:元组，支持HTTP认证功能<br>files:字典类型，传输文件<br>timeout:设定超时时间，秒为单位<br>proxies:字典类型，设定访问代理服务器，可以增加登录认证<br>allow_redirects :<span class="hljs-literal">True</span>/<span class="hljs-literal">False</span>，默认为<span class="hljs-literal">True</span>，重定向开关<br>stream:<span class="hljs-literal">True</span>/<span class="hljs-literal">False</span>，默认为<span class="hljs-literal">True</span>，获取内容立即下载开关<br>verify:<span class="hljs-literal">True</span>/<span class="hljs-literal">False</span>，默认为<span class="hljs-literal">True</span>，认证SSL证书开关<br>cert:本地SSL证书路径<br><br></code></pre></td></tr></table></figure><p>requests.get(<strong>url</strong>, <strong>params&#x3D;None</strong>,**kwargs)</p><p>requests.head(<strong>url</strong>, **kwargs)</p><p>requests.put(<strong>url</strong>, <strong>data&#x3D;None</strong>,****kwargs)</p><p>requests.post(<strong>url</strong>, <strong>data&#x3D;None</strong>,<strong>json&#x3D;None</strong>,**kwargs)</p><p>向URL POST一个字典 自动编码为form（表单）</p><p>向URL POST一个字符串 自动编码为data</p><p>requests.patch(<strong>url</strong>, <strong>data&#x3D;None</strong>,**kwargs)</p><p>requests.delete(<strong>url</strong>, **kwargs)</p><p><img src="https://pic.imgdb.cn/item/65b8ee52871b83018a26fbed.png" alt="request.get()"></p><p>Response对象包含爬虫返回的内容  Response对象包含服务器返回的所有信息，也包含请求的 Request信息</p><h3 id="7-4-Response对象的属性"><a href="#7-4-Response对象的属性" class="headerlink" title="7.4 Response对象的属性"></a>7.4 Response对象的属性</h3><p><img src="https://pic.imgdb.cn/item/65b8ee57871b83018a270f20.png" alt="response对象的属性"></p><p><img src="https://pic.imgdb.cn/item/65b8ee57871b83018a270fc6.png" alt="response对象的属性2"></p><h3 id="7-5理解Response的编码"><a href="#7-5理解Response的编码" class="headerlink" title="7.5理解Response的编码"></a><strong>7.5理解Response的编码</strong></h3><p> r.encoding 从HTTP header中猜测的响应内容编码方式</p><p> r.apparent_encoding 从内容中分析出的响应内容编码方式（备选编码方式） </p><p> r.encoding：如果header中不存在charset，则认为编码为 ISO‐8859‐1，r.text根据r.encoding显示网页内容 </p><p> r.apparent_encoding：根据网页内容分析出的编码方式， 可以看作是r.encoding的备选</p><h3 id="7-6爬取网页的通用代码框架"><a href="#7-6爬取网页的通用代码框架" class="headerlink" title="7.6爬取网页的通用代码框架"></a>7.6爬取网页的通用代码框架</h3><h4 id="7-6-1理解Requests库的异常"><a href="#7-6-1理解Requests库的异常" class="headerlink" title="7.6.1理解Requests库的异常"></a>7.6.1理解Requests库的异常</h4><p><img src="https://pic.imgdb.cn/item/65b8ee57871b83018a271081.png" alt="request库的异常"></p><p><img src="https://pic.imgdb.cn/item/65b8ee57871b83018a271145.png" alt="requests的异常"></p><h4 id="7-6-2-爬取网页的通用代码框架"><a href="#7-6-2-爬取网页的通用代码框架" class="headerlink" title="7.6.2   爬取网页的通用代码框架"></a>7.6.2   爬取网页的通用代码框架</h4><p><img src="https://pic.imgdb.cn/item/65b8ee58871b83018a271214.png" alt="爬取网页的通用代码框架"></p><h2 id="八-数据分析与处理"><a href="#八-数据分析与处理" class="headerlink" title="八.数据分析与处理"></a>八.数据分析与处理</h2><h3 id="8-1-Beautiful-Soup库"><a href="#8-1-Beautiful-Soup库" class="headerlink" title="8.1 Beautiful Soup库"></a>8.1 Beautiful Soup库</h3><p><a href="http://www.crummy.com/software/BeautifulSoup/">Beautiful Soup</a> 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时间.</p><h4 id="8-1-1-Beautiful-Soup库的基本元素"><a href="#8-1-1-Beautiful-Soup库的基本元素" class="headerlink" title="8.1.1 Beautiful Soup库的基本元素"></a>8.1.1 Beautiful Soup库的基本元素</h4><p><img src="https://pic.imgdb.cn/item/65b8ee5e871b83018a272f6c.png" alt="Beautiful Soap库的理解"></p><p><img src="https://pic.imgdb.cn/item/65b8ee5f871b83018a27303b.png" alt="Beautiful Soup库的理解"></p><h4 id="8-1-2-Beautiful-Soup库的引用"><a href="#8-1-2-Beautiful-Soup库的引用" class="headerlink" title="8.1.2 Beautiful Soup库的引用"></a>8.1.2 Beautiful Soup库的引用</h4><p>Beautiful Soup库，也叫beautifulsoup4 或 bs4 约定引用方式如下，即主要是用BeautifulSoup类</p><p>from bs4 import BeautifulSoup </p><p>import bs4</p><h4 id="8-1-3-BeautifulSoup类"><a href="#8-1-3-BeautifulSoup类" class="headerlink" title="8.1.3 BeautifulSoup类"></a>8.1.3 BeautifulSoup类</h4><p><img src="https://pic.imgdb.cn/item/65b8ee5f871b83018a273144.png" alt="beautiful类"></p><h4 id="8-1-4-Beautiful-Soup库解析器"><a href="#8-1-4-Beautiful-Soup库解析器" class="headerlink" title="8.1.4 Beautiful Soup库解析器"></a>8.1.4 Beautiful Soup库解析器</h4><p><img src="https://pic.imgdb.cn/item/65b8ee5f871b83018a273202.png" alt="beautifulsoup库1"></p><h4 id="8-1-5-BeautifulSoup类的基本元素"><a href="#8-1-5-BeautifulSoup类的基本元素" class="headerlink" title="8.1.5 BeautifulSoup类的基本元素"></a>8.1.5 BeautifulSoup类的基本元素</h4><p><img src="https://pic.imgdb.cn/item/65b8ee60871b83018a2735a3.png" alt="beautifulsoup类的基本元素"></p><p><img src="https://pic.imgdb.cn/item/65b8ee64871b83018a274788.png" alt="tag标签"></p><p><img src="https://pic.imgdb.cn/item/65b8ee64871b83018a274850.png" alt="tag的name"></p><p><img src="https://pic.imgdb.cn/item/65b8ee64871b83018a274955.png" alt="tag的attrs(属性)"></p><p><img src="https://pic.imgdb.cn/item/65b8ee65871b83018a274a9b.png" alt="tag的navigablestring"></p><p><img src="https://pic.imgdb.cn/item/65b8ee65871b83018a274bb2.png" alt="tag的comment"></p><h4 id="8-1-6-基于bs4库的HTML内容遍历方法"><a href="#8-1-6-基于bs4库的HTML内容遍历方法" class="headerlink" title="8.1.6 基于bs4库的HTML内容遍历方法"></a>8.1.6 基于bs4库的HTML内容遍历方法</h4><p><img src="https://pic.imgdb.cn/item/65b8ee6a871b83018a276051.png" alt="html遍历"></p><p><img src="https://pic.imgdb.cn/item/65b8ee6a871b83018a27610c.png" alt="标签树的下行遍历"></p><p><img src="https://pic.imgdb.cn/item/65b8ee6a871b83018a2761f6.png" alt="标签树的下行遍历1"></p><p><img src="https://pic.imgdb.cn/item/65b8ee6a871b83018a2762a2.png" alt="标签树的下行遍历2"></p><p><img src="https://pic.imgdb.cn/item/65b8ee6a871b83018a27634d.png" alt="标签树的上行遍历1"></p><p><img src="https://pic.imgdb.cn/item/65b8ee6f871b83018a277522.png" alt="标签树的上行遍历2"></p><p><img src="https://pic.imgdb.cn/item/65b8ee6f871b83018a2775b6.png" alt="标签树的上行遍历3"></p><p><img src="https://pic.imgdb.cn/item/65b8ee6f871b83018a277671.png" alt="标签树的平行遍历1"></p><p><img src="https://pic.imgdb.cn/item/65b8ee6f871b83018a277700.png" alt="标签树的平行遍历2"></p><p><img src="https://pic.imgdb.cn/item/65b8ee6f871b83018a277801.png" alt="标签树的平行遍历3"></p><p><img src="https://pic.imgdb.cn/item/65b8ee77871b83018a279520.png" alt="标签树的平行遍历4"></p><p><img src="https://pic.imgdb.cn/item/65b8ee77871b83018a2795f1.png" alt="下上平遍历总结"></p><h4 id="8-1-7-基于bs4库的HTML格式输出"><a href="#8-1-7-基于bs4库的HTML格式输出" class="headerlink" title="8.1.7 基于bs4库的HTML格式输出"></a>8.1.7 基于bs4库的HTML格式输出</h4><p>能否让HTML内容更加“友好”的显示？</p><p><img src="https://pic.imgdb.cn/item/65b8ee77871b83018a2796bd.png" alt="bs4库的prettify()方法"></p><p><img src="https://pic.imgdb.cn/item/65b8ee77871b83018a2798f3.png" alt="bs4库的prettify()方法1"></p><p><img src="https://pic.imgdb.cn/item/65b8ee78871b83018a2799d2.png" alt="bs4库的prettify()方法2"></p><p><img src="https://pic.imgdb.cn/item/65b8ee7c871b83018a27ac27.png" alt="bs4库的prettify()方法3"></p><h4 id="8-1-8-bs4库的编码"><a href="#8-1-8-bs4库的编码" class="headerlink" title="8.1.8 bs4库的编码"></a>8.1.8 bs4库的编码</h4><p><img src="https://pic.imgdb.cn/item/65b8ee7c871b83018a27aba3.png" alt="bs4库的编码"></p><h3 id="8-2-信息标记与提取方式"><a href="#8-2-信息标记与提取方式" class="headerlink" title="8.2  信息标记与提取方式"></a>8.2  信息标记与提取方式</h3><h4 id="8-2-1信息标记"><a href="#8-2-1信息标记" class="headerlink" title="8.2.1信息标记"></a>8.2.1信息标记</h4><p><img src="https://pic.imgdb.cn/item/65b8ee7c871b83018a27ad30.png" alt="信息的标记"></p><p>标记后的信息可形成信息组织结构，增加了信息维度  </p><p>标记的结构与信息一样具有重要价值  </p><p>标记后的信息可用于通信、存储或展示  </p><p>标记后的信息更利于程序理解和运用</p><p>8.2.2信息标记的三种形式</p><p>xml json yaml</p><p><img src="https://pic.imgdb.cn/item/65b8ee7c871b83018a27ade8.png" alt="xml"></p><p><img src="https://pic.imgdb.cn/item/65b8ee7d871b83018a27ae62.png" alt="xml1"></p><p><img src="https://pic.imgdb.cn/item/65b8ee82871b83018a27c2ce.png" alt="xml2"></p><p><img src="https://pic.imgdb.cn/item/65b8ee82871b83018a27c3c1.png" alt="json1"></p><p><img src="https://pic.imgdb.cn/item/65b8ee82871b83018a27c481.png" alt="json2"></p><p><img src="https://pic.imgdb.cn/item/65b8ee82871b83018a27c551.png" alt="json3"></p><p><img src="https://pic.imgdb.cn/item/65b8ee82871b83018a27c5ea.png" alt="yaml1"></p><p><img src="https://pic.imgdb.cn/item/65b8ee89871b83018a27e34a.png" alt="yaml2"></p><p><img src="https://pic.imgdb.cn/item/65b8ee89871b83018a27e3d8.png" alt="yaml3"></p><p><img src="https://pic.imgdb.cn/item/65b8ee89871b83018a27e4bd.png" alt="yaml4"></p><h4 id="8-2-2三种信息标记形式的比较"><a href="#8-2-2三种信息标记形式的比较" class="headerlink" title="8.2.2三种信息标记形式的比较"></a>8.2.2三种信息标记形式的比较</h4><p><img src="https://pic.imgdb.cn/item/65b8ee89871b83018a27e59d.png" alt="标记比较"></p><p><img src="https://pic.imgdb.cn/item/65b8ee8a871b83018a27e6ca.png" alt="标记实例比较"></p><p>XML最早的通用信息标记语言，可扩展性好，但繁琐  </p><p>JSON信息有类型，适合程序处理(js)，较XML简洁  </p><p>YAML信息无类型，文本信息比例最高，可读性好</p><p>XML  Internet上的信息交互与传递  </p><p>JSON 移动应用云端和节点的信息通信，无注释</p><p>YAML 各类系统的配置文件，有注释易读</p><h4 id="8-2-3信息提取的一般方法"><a href="#8-2-3信息提取的一般方法" class="headerlink" title="8.2.3信息提取的一般方法"></a>8.2.3信息提取的一般方法</h4><p>方法一：完整解析信息的标记形式，再提取关键信息  XML JSON YAML </p><p>需要标记解析器，例如：bs4库的标签树遍历  优点：信息解析准确  缺点：提取过程繁琐，速度慢</p><p>方法二：无视标记形式，直接搜索关键信息  搜索  对信息的文本查找函数即可  </p><p>优点：提取过程简洁，速度较快  缺点：提取结果准确性与信息内容相关</p><p>融合方法：结合形式解析与搜索方法，提取关键信息  XML JSON YAML 搜索  需要标记解析器及文本查找函数</p><h4 id="8-2-4基于bs4库的HTML内容查找方法"><a href="#8-2-4基于bs4库的HTML内容查找方法" class="headerlink" title="8.2.4基于bs4库的HTML内容查找方法"></a>8.2.4基于bs4库的HTML内容查找方法</h4><p><img src="https://pic.imgdb.cn/item/65b8ee95871b83018a28194c.png" alt="bs查找"></p><p><img src="https://pic.imgdb.cn/item/65b8ee95871b83018a281b30.png" alt="bs查找2"></p><p><strong>扩展方法</strong></p><p><img src="https://pic.imgdb.cn/item/65b8ee96871b83018a281be2.png" alt="bs查找扩展方法"></p><h3 id="8-3-re-正则表达式-入门"><a href="#8-3-re-正则表达式-入门" class="headerlink" title="8.3 re(正则表达式)入门"></a>8.3 re(正则表达式)入门</h3><h4 id="8-3-1正则表达式概念"><a href="#8-3-1正则表达式概念" class="headerlink" title="8.3.1正则表达式概念"></a>8.3.1正则表达式概念</h4><p><img src="https://pic.imgdb.cn/item/65b8ee96871b83018a281d68.png" alt="正则表达式概念"></p><h4 id="8-3-2正则表达式语法"><a href="#8-3-2正则表达式语法" class="headerlink" title="8.3.2正则表达式语法"></a>8.3.2正则表达式语法</h4><p><img src="https://pic.imgdb.cn/item/65b8ee97871b83018a281f70.png" alt="正则表达式语法"></p><h4 id="8-3-3-re库的使用"><a href="#8-3-3-re库的使用" class="headerlink" title="8.3.3 re库的使用"></a>8.3.3 re库的使用</h4><p><img src="https://pic.imgdb.cn/item/65b8eea1871b83018a284c68.png" alt="re库使用"></p><p><strong>re库主要功能函数</strong></p><p><img src="https://pic.imgdb.cn/item/65b8eea1871b83018a284d09.png" alt="re主要功能函数"></p><p><img src="https://pic.imgdb.cn/item/65b8eea2871b83018a284eec.png" alt="re函数"></p><p><img src="https://pic.imgdb.cn/item/65b8eea2871b83018a285082.png" alt="re函数2"></p><p><strong>re库的另一种等价用法</strong></p><p><img src="https://pic.imgdb.cn/item/65b8eea2871b83018a2851a2.png" alt="re库的另一种等价用法"></p><p><strong>re的match对象</strong></p><p><img src="https://pic.imgdb.cn/item/65b8eea6871b83018a286099.png" alt="re的match对象"></p><p><strong>re 的贪婪匹配和最小匹配</strong></p><p><img src="https://pic.imgdb.cn/item/65b8eea6871b83018a2861f5.png" alt="re的贪婪和最小"></p><h3 id="8-4-文件的读写"><a href="#8-4-文件的读写" class="headerlink" title="8.4 文件的读写"></a>8.4 文件的读写</h3><p>Python3 File(文件) 方法</p><p><strong>open() 方法</strong></p><p>Python <strong>open()</strong> 方法用于打开一个文件，并返回文件对象。</p><p>在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 <strong>OSError</strong>。</p><p><strong>注意：</strong>使用 <strong>open()</strong> 方法一定要保证关闭文件对象，即调用 <strong>close()</strong> 方法。</p><p><strong>open()</strong> 函数常用形式是接收两个参数：文件名(file)和模式(mode)。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(file, mode=<span class="hljs-string">&#x27;r&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure><p>完整的语法格式为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">open(file, <span class="hljs-attribute">mode</span>=<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-attribute">buffering</span>=-1, <span class="hljs-attribute">encoding</span>=None, <span class="hljs-attribute">errors</span>=None, <span class="hljs-attribute">newline</span>=None, <span class="hljs-attribute">closefd</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">opener</span>=None)<br></code></pre></td></tr></table></figure><p>参数说明:</p><ul><li>file: 必需，文件路径（相对或者绝对路径）。</li><li>mode: 可选，文件打开模式</li><li>buffering: 设置缓冲</li><li>encoding: 一般使用utf8</li><li>errors: 报错级别</li><li>newline: 区分换行符</li><li>closefd: 传入的file参数类型</li><li>opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。</li></ul><p>mode 参数有：</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">t</td><td align="left">文本模式 (默认)。</td></tr><tr><td align="left">x</td><td align="left">写模式，新建一个文件，如果该文件已存在则会报错。</td></tr><tr><td align="left">b</td><td align="left">二进制模式。</td></tr><tr><td align="left">+</td><td align="left">打开一个文件进行更新(可读可写)。</td></tr><tr><td align="left">U</td><td align="left">通用换行模式（<strong>Python 3 不支持</strong>）。</td></tr><tr><td align="left">r</td><td align="left">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td align="left">rb</td><td align="left">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td></tr><tr><td align="left">r+</td><td align="left">打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td align="left">rb+</td><td align="left">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td></tr><tr><td align="left">w</td><td align="left">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">wb</td><td align="left">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td align="left">w+</td><td align="left">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">wb+</td><td align="left">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td align="left">a</td><td align="left">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="left">ab</td><td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="left">a+</td><td align="left">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td align="left">ab+</td><td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><p>默认为文本模式，如果要以二进制模式打开，加上 <strong>b</strong> 。</p><p><strong>file 对象</strong></p><p>file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：</p><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-close.html">file.close()</a>关闭文件。关闭后文件不能再进行读写操作。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-flush.html">file.flush()</a>刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-fileno.html">file.fileno()</a>返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-isatty.html">file.isatty()</a>如果文件连接到一个终端设备返回 True，否则返回 False。</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-next.html">file.next()</a><strong>Python 3 中的 File 对象不支持 next() 方法。</strong>返回文件下一行。</td></tr><tr><td align="left">6</td><td align="left">[file.read(<a href="https://www.runoob.com/python3/python3-file-read.html">size])</a>从文件读取指定的字节数，如果未给定或为负则读取所有。</td></tr><tr><td align="left">7</td><td align="left">[file.readline(<a href="https://www.runoob.com/python3/python3-file-readline.html">size])</a>读取整行，包括 “\n” 字符。</td></tr><tr><td align="left">8</td><td align="left">[file.readlines(<a href="https://www.runoob.com/python3/python3-file-readlines.html">sizeint])</a>读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。</td></tr><tr><td align="left">9</td><td align="left">[file.seek(offset<a href="https://www.runoob.com/python3/python3-file-seek.html">, whence])</a>移动文件读取指针到指定位置</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-tell.html">file.tell()</a>返回文件当前位置。</td></tr><tr><td align="left">11</td><td align="left">[file.truncate(<a href="https://www.runoob.com/python3/python3-file-truncate.html">size])</a>从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-write.html">file.write(str)</a>将字符串写入文件，返回的是写入的字符长度。</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-writelines.html">file.writelines(sequence)</a>向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td></tr></tbody></table><h4 id="Python-with-关键字"><a href="#Python-with-关键字" class="headerlink" title="Python with 关键字"></a>Python with 关键字</h4><p>Python 中的 <strong>with</strong> 语句用于异常处理，封装了 <strong>try…except…finally</strong> 编码范式，提高了易用性。</p><p><strong>with</strong> 语句使代码更清晰、更具可读性， 它简化了文件流等公共资源的管理。</p><p>在处理文件对象时使用 with 关键字是一种很好的做法。</p><p>我们可以看下以下几种代码实例：</p><p>不使用 <strong>with</strong>，也不使用 <strong>try…except…finally</strong></p><p><strong>实例</strong></p><p>file &#x3D; open(‘.&#x2F;test_runoob.txt’, ‘w’)<br>file.write(‘hello world !’)<br>file.close()</p><p>以上代码如果在调用 write 的过程中，出现了异常，则 close 方法将无法被执行，因此资源就会一直被该程序占用而无法被释放。 接下来我们呢可以使用 <strong>try…except…finally</strong> 来改进代码：</p><p><strong>实例</strong></p><p>file &#x3D; open(‘.&#x2F;test_runoob.txt’, ‘w’)<br><strong>try</strong>:<br>  file.write(‘hello world’)<br><strong>finally</strong>:<br>  file.close()</p><p>以上代码我们对可能发生异常的代码处进行 try 捕获，发生异常时执行 except 代码块，finally 代码块是无论什么情况都会执行，所以文件会被关闭，不会因为执行异常而占用资源。</p><p>使用 <strong>with</strong> 关键字：</p><p><strong>实例</strong></p><p><strong>with</strong> open(‘.&#x2F;test_runoob.txt’, ‘w’) <strong>as</strong> file:<br>  file.write(‘hello world !’)</p><p>使用 <strong>with</strong> 关键字系统会自动调用 f.close() 方法， with 的作用等效于 try&#x2F;finally 语句是一样的。</p><p>我们可以在执行 with 关键字后检验文件是否关闭：</p><p><strong>实例</strong></p><p>&gt;&gt;&gt; <strong>with</strong> open(‘.&#x2F;test_runoob.txt’) <strong>as</strong> f:<br>…   read_data &#x3D; f.read()</p><p>&gt;&gt;&gt; # 查看文件是否关闭<br>&gt;&gt;&gt; f.closed<br>True</p><p>with 语句实现原理建立在上下文管理器之上。</p><p>上下文管理器是一个实现 <strong><strong>enter</strong></strong> 和 <strong><strong>exit</strong></strong> 方法的类。</p><p>使用 with 语句确保在嵌套块的末尾调用 <strong>exit</strong> 方法。</p><p>这个概念类似于 try…finally 块的使用。</p><p><strong>实例</strong></p><p><strong>with</strong> open(‘.&#x2F;test_runoob.txt’, ‘w’) <strong>as</strong> my_file:<br>  my_file.write(‘hello world!’)</p><p>以上实例将 <strong>hello world!</strong> 写到 .&#x2F;test_runoob.txt 文件上。</p><p>在文件对象中定义了 <strong>enter</strong> 和 <strong>exit</strong> 方法，即文件对象也实现了上下文管理器，首先调用 <strong>enter</strong> 方法，然后执行 with 语句中的代码，最后调用 <strong>exit</strong> 方法。 即使出现错误，也会调用 <strong>exit</strong> 方法，也就是会关闭文件流。</p><h3 id="8-5-Python3-OS-文件-目录方法"><a href="#8-5-Python3-OS-文件-目录方法" class="headerlink" title="8.5  Python3 OS 文件&#x2F;目录方法"></a>8.5  Python3 OS 文件&#x2F;目录方法</h3><p><strong>os</strong> 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示：</p><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-access.html">os.access(path, mode)</a> 检验权限模式</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-chdir.html">os.chdir(path)</a> 改变当前工作目录</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-chflags.html">os.chflags(path, flags)</a> 设置路径的标记为数字标记。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-chmod.html">os.chmod(path, mode)</a> 更改权限</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-chown.html">os.chown(path, uid, gid)</a> 更改文件所有者</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-chroot.html">os.chroot(path)</a> 改变当前进程的根目录</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-close.html">os.close(fd)</a> 关闭文件描述符 fd</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-closerange.html">os.closerange(fd_low, fd_high)</a> 关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-dup.html">os.dup(fd)</a> 复制文件描述符 fd</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-dup2.html">os.dup2(fd, fd2)</a> 将一个文件描述符 fd 复制到另一个 fd2</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fchdir.html">os.fchdir(fd)</a> 通过文件描述符改变当前工作目录</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fchmod.html">os.fchmod(fd, mode)</a> 改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fchown.html">os.fchown(fd, uid, gid)</a> 修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。</td></tr><tr><td align="left">14</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fdatasync.html">os.fdatasync(fd)</a> 强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。</td></tr><tr><td align="left">15</td><td align="left">[os.fdopen(fd<a href="https://www.runoob.com/python3/python3-os-fdopen.html">, mode[, bufsize]])</a> 通过文件描述符 fd 创建一个文件对象，并返回这个文件对象</td></tr><tr><td align="left">16</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fpathconf.html">os.fpathconf(fd, name)</a> 返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。</td></tr><tr><td align="left">17</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fstat.html">os.fstat(fd)</a> 返回文件描述符fd的状态，像stat()。</td></tr><tr><td align="left">18</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fstatvfs.html">os.fstatvfs(fd)</a> 返回包含文件描述符fd的文件的文件系统的信息，Python 3.3 相等于 statvfs()。</td></tr><tr><td align="left">19</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fsync.html">os.fsync(fd)</a> 强制将文件描述符为fd的文件写入硬盘。</td></tr><tr><td align="left">20</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-ftruncate.html">os.ftruncate(fd, length)</a> 裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。</td></tr><tr><td align="left">21</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-getcwd.html">os.getcwd()</a> 返回当前工作目录</td></tr><tr><td align="left">22</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-getcwdb.html">os.getcwdb()</a> 返回一个当前工作目录的Unicode对象</td></tr><tr><td align="left">23</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-isatty.html">os.isatty(fd)</a> 如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。</td></tr><tr><td align="left">24</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-lchflags.html">os.lchflags(path, flags)</a> 设置路径的标记为数字标记，类似 chflags()，但是没有软链接</td></tr><tr><td align="left">25</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-lchmod.html">os.lchmod(path, mode)</a> 修改连接文件权限</td></tr><tr><td align="left">26</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-lchown.html">os.lchown(path, uid, gid)</a> 更改文件所有者，类似 chown，但是不追踪链接。</td></tr><tr><td align="left">27</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-link.html">os.link(src, dst)</a> 创建硬链接，名为参数 dst，指向参数 src</td></tr><tr><td align="left">28</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-listdir.html">os.listdir(path)</a> 返回path指定的文件夹包含的文件或文件夹的名字的列表。</td></tr><tr><td align="left">29</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-lseek.html">os.lseek(fd, pos, how)</a> 设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效</td></tr><tr><td align="left">30</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-lstat.html">os.lstat(path)</a> 像stat(),但是没有软链接</td></tr><tr><td align="left">31</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-major.html">os.major(device)</a> 从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。</td></tr><tr><td align="left">32</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-makedev.html">os.makedev(major, minor)</a> 以major和minor设备号组成一个原始设备号</td></tr><tr><td align="left">33</td><td align="left">[os.makedirs(path<a href="https://www.runoob.com/python3/python3-os-makedirs.html">, mode])</a> 递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。</td></tr><tr><td align="left">34</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-minor.html">os.minor(device)</a> 从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。</td></tr><tr><td align="left">35</td><td align="left">[os.mkdir(path<a href="https://www.runoob.com/python3/python3-os-mkdir.html">, mode])</a> 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。</td></tr><tr><td align="left">36</td><td align="left">[os.mkfifo(path<a href="https://www.runoob.com/python3/python3-os-mkfifo.html">, mode])</a> 创建命名管道，mode 为数字，默认为 0666 (八进制)</td></tr><tr><td align="left">37</td><td align="left">[os.mknod(filename<a href="https://www.runoob.com/python3/python3-os-mknod.html">, mode&#x3D;0600, device])</a> 创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。</td></tr><tr><td align="left">38</td><td align="left">[os.open(file, flags<a href="https://www.runoob.com/python3/python3-os-open.html">, mode])</a> 打开一个文件，并且设置需要的打开选项，mode参数是可选的</td></tr><tr><td align="left">39</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-openpty.html">os.openpty()</a> 打开一个新的伪终端对。返回 pty 和 tty的文件描述符。</td></tr><tr><td align="left">40</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-pathconf.html">os.pathconf(path, name)</a> 返回相关文件的系统配置信息。</td></tr><tr><td align="left">41</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-pipe.html">os.pipe()</a> 创建一个管道. 返回一对文件描述符(r, w) 分别为读和写</td></tr><tr><td align="left">42</td><td align="left">[os.popen(command<a href="https://www.runoob.com/python3/python3-os-popen.html">, mode[, bufsize]])</a> 从一个 command 打开一个管道</td></tr><tr><td align="left">43</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-read.html">os.read(fd, n)</a> 从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。</td></tr><tr><td align="left">44</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-readlink.html">os.readlink(path)</a> 返回软链接所指向的文件</td></tr><tr><td align="left">45</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-remove.html">os.remove(path)</a> 删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。</td></tr><tr><td align="left">46</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-removedirs.html">os.removedirs(path)</a> 递归删除目录。</td></tr><tr><td align="left">47</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-rename.html">os.rename(src, dst)</a> 重命名文件或目录，从 src 到 dst</td></tr><tr><td align="left">48</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-renames.html">os.renames(old, new)</a> 递归地对目录进行更名，也可以对文件进行更名。</td></tr><tr><td align="left">49</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-rmdir.html">os.rmdir(path)</a> 删除path指定的空目录，如果目录非空，则抛出一个OSError异常。</td></tr><tr><td align="left">50</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-stat.html">os.stat(path)</a> 获取path指定的路径的信息，功能等同于C API中的stat()系统调用。</td></tr><tr><td align="left">51</td><td align="left">[os.stat_float_times(<a href="https://www.runoob.com/python3/python3-os-stat_float_times.html">newvalue])</a> 决定stat_result是否以float对象显示时间戳</td></tr><tr><td align="left">52</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-statvfs.html">os.statvfs(path)</a> 获取指定路径的文件系统统计信息</td></tr><tr><td align="left">53</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-symlink.html">os.symlink(src, dst)</a> 创建一个软链接</td></tr><tr><td align="left">54</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-tcgetpgrp.html">os.tcgetpgrp(fd)</a> 返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组</td></tr><tr><td align="left">55</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-tcsetpgrp.html">os.tcsetpgrp(fd, pg)</a> 设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。</td></tr><tr><td align="left">56</td><td align="left">os.tempnam([dir[, prefix]]) <strong>Python3 中已删除。</strong>返回唯一的路径名用于创建临时文件。</td></tr><tr><td align="left">57</td><td align="left">os.tmpfile() <strong>Python3 中已删除。</strong>返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。</td></tr><tr><td align="left">58</td><td align="left">os.tmpnam() <strong>Python3 中已删除。</strong>为创建一个临时文件返回一个唯一的路径</td></tr><tr><td align="left">59</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-ttyname.html">os.ttyname(fd)</a> 返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。</td></tr><tr><td align="left">60</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-unlink.html">os.unlink(path)</a> 删除文件路径</td></tr><tr><td align="left">61</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-utime.html">os.utime(path, times)</a> 返回指定的path文件的访问和修改的时间。</td></tr><tr><td align="left">62</td><td align="left">[os.walk(top[, topdown&#x3D;True[, onerror&#x3D;None[, followlinks&#x3D;False]]])](<a href="https://www.runoob.com/python3/python3-os-walk.html">https://www.runoob.com/python3/python3-os-walk.html</a>) 输出在文件夹中的文件名通过在树中游走，向上或者向下。</td></tr><tr><td align="left">63</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-write.html">os.write(fd, str)</a> 写入字符串到文件描述符 fd中. 返回实际写入的字符串长度</td></tr><tr><td align="left">64</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-path.html">os.path 模块</a> 获取文件的属性信息。</td></tr><tr><td align="left">65</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-pardir.html">os.pardir()</a> 获取当前目录的父目录，以字符串形式显示目录名。</td></tr><tr><td align="left">66</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-replace.html">os.replace()</a> 重命名文件或目录。</td></tr></tbody></table><h1 id="python知识点总结"><a href="#python知识点总结" class="headerlink" title="python知识点总结"></a>python知识点总结</h1><h3 id="1-and和or的用法"><a href="#1-and和or的用法" class="headerlink" title="1.and和or的用法"></a>1.and和or的用法</h3><p><a href="https://blog.csdn.net/Echo_Zhang12/article/details/111330901">https://blog.csdn.net/Echo_Zhang12/article/details/111330901</a></p><p><strong>在python中：None、任何数值类型中的0、空字符串“”、空元组()、空列表[]、空字典{}都被当作False，还有自定义类型，如果实现了 　__ nonzero __ ()　或　__ len __ () 方法且方法返回 0 或False，则其实例也被当作False，其他对象均为True。</strong></p><h3 id="2-list-‘-1-2-3-’"><a href="#2-list-‘-1-2-3-’" class="headerlink" title="2.list(‘[1,2,3]’)"></a>2.list(‘[1,2,3]’)</h3><p>在Python中，字符串按照字典顺序进行比较。在字典顺序中，比较的是字符串的第一个字符，如果第一个字符相同，则比较下一个字符，以此类推，直到找到不相等的字符为止。如果一个字符串已经结束而另一个字符串还有剩余字符，则较短的字符串被视为更小。<br>在比较 ‘11’，’2’ 和 ‘3’ 时，首先会比较第一个字符。在这里，’1’ 是比 ‘2’ 和 ‘3’ 更小的，因此 ‘11’ 被认为比 ‘2’ 和 ‘3’ 更小，即使后面的字符不同，因为在第一个位置上就有明确的大小关系。</p><h3 id="3-min-‘11’，’2’-’3’"><a href="#3-min-‘11’，’2’-’3’" class="headerlink" title="3.min([‘11’，’2’,’3’])"></a>3.min([‘11’，’2’,’3’])</h3><p>在Python中，字符串按照字典顺序进行比较。在字典顺序中，比较的是字符串的第一个字符，如果第一个字符相同，则比较下一个字符，以此类推，直到找到不相等的字符为止。如果一个字符串已经结束而另一个字符串还有剩余字符，则较短的字符串被视为更小。<br>在比较 ‘11’，’2’ 和 ‘3’ 时，首先会比较第一个字符。在这里，’1’ 是比 ‘2’ 和 ‘3’ 更小的，因此 ‘11’ 被认为比 ‘2’ 和 ‘3’ 更小，即使后面的字符不同，因为在第一个位置上就有明确的大小关系。</p><ol start="4"><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python考试总结&quot;&gt;&lt;a href=&quot;#python考试总结&quot; class=&quot;headerlink&quot; title=&quot;python考试总结&quot;&gt;&lt;/a&gt;python考试总结&lt;/h1&gt;&lt;h2 id=&quot;一-程序设计基本方法&quot;&gt;&lt;a href=&quot;#一-程序设计基本方法&quot;</summary>
      
    
    
    
    <category term="python总结" scheme="http://example.com/categories/python%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
</feed>
